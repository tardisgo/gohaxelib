<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.sort.MergeSort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurense of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurense of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/cpp/_std/Date.hx">
		<fromString public="1" set="method" line="63" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<mSeconds><x path="Float"/></mSeconds>
		<toString public="1" set="method" line="48">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="26">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There is some extra functions available in the `DateTools` class.

	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="cpp.Lib" params="" file="/usr/lib/haxe/std/cpp/Lib.hx">
		<load public="1" set="method" line="29" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="48" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Tries to load, and always returns a valid function, but the function may throw
		if called.</haxe_doc>
		</loadLazy>
		<rethrow public="1" set="method" line="64" static="1"><f a="inExp">
	<d/>
	<x path="Void"/>
</f></rethrow>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="ImportAll" params="" file="ImportAll.hx"><run public="1" set="method" line="167" static="1"><f a="?pack" v="null">
	<unknown/>
	<x path="Void"/>
</f></run></class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<iterator public="1" set="method" line="161">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="Map.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="Map.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="Map.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="Map.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"><e>K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map" interface="1"><meta><m n=":keep"/></meta></class>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter, 
		specified by the constant, Ï€. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. 

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. 

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with NaN as an operand will result in NaN.

		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.

		In order to test if a value is NaN, you should use Math.isNaN() function.

		@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, 
		see [https://bugs.php.net/bug.php?id=42143]</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result 
		is -`v`.
		
		If `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is 
		POSITIVE_INFINITY.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are NaN, the result is NaN.
		If `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		If `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are NaN, the result is NaN.
		If `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`, 
		in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`, 
		in radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of 
		two specified numbers, in radians.
		
		If parameter `x` or `y`  is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is NaN.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.
		
		exp(1.0) is approximately 2.718281828459.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `v` is NEGATIVE_INFINITY, the result is 0.0.
		If `v` is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.
		
		This is the mathematical inverse operation of exp, 
		i.e. `log(exp(v)) == v` always holds.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result 
		is NaN.
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `v` is 0.0, the result is NEGATIVE_INFINITY.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result 
		is NaN.
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		If `v` is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.
		
		If `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY 
		or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY 
		or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY 
		or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0, 
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a Float.

		If `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a Float.

		If `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		If `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, 
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result 
		is false, otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is NaN, the result is true, otherwise the result is false. 
		In particular, both POSITIVE_INFINITY and NEGATIVE_INFINITY are
		not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta><m n=":include"><e>"hxMath"</e></m></meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/cpp/_std/Reflect.hx">
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<fields public="1" set="method" line="53" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<compare public="1" params="T" set="method" line="64" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<isObject public="1" set="method" line="76" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- Class<T>
		- Enum<T>

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="83" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" line="87" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<makeVarArgs public="1" set="method" line="104" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/cpp/_std/Std.hx">
		<is public="1" set="method" line="23" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<instance public="1" params="T:S" set="method" line="27" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Checks if object `value` is an instance of class `c`.

		Compiles only if the class specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the class specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with interfaces or core types such
		as String, Array and Date.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</instance>
		<string public="1" set="method" line="31" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="35" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="39" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a NaN value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="47" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.

	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.

	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.

	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.

	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.

		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, null is returned.

		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the string literal syntax "string value".

	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/cpp/_std/StringBuf.hx">
		<b><c path="Array"><c path="String"/></c></b>
		<add public="1" params="T" set="method" line="40">
			<f a="x">
				<c path="add.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.

		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).

		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="36" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="61" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<startsWith public="1" set="method" line="127" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is null, the result is unspecified.

		If `start` is the empty String "", the result is true.</haxe_doc>
		</startsWith>
		<replace public="1" set="method" line="291" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String "", `by` is inserted after each character
		of `s`. If `by` is also the empty String "", `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="313" static="1">
			<f a="n:?digits" v=":null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its length equals `digits`.</haxe_doc>
		</hex>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Sys" params="" file="/usr/lib/haxe/std/cpp/_std/Sys.hx">
		<print public="1" set="method" line="24" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="28" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<time public="1" set="method" line="111" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<sys_time line="143" static="1"><f a=""><x path="Float"/></f></sys_time>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="35" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getClassName public="1" set="method" line="56" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="62" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="66" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="73" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="80" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="86" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="90" static="1">
			<f a="e:constr:?params" v="::null">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<getEnumConstructs public="1" set="method" line="108" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="112" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="128" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumParameters public="1" set="method" line="136" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="/usr/lib/haxe/std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned Int type is only defined for Flash9 and C#.
	Simulate it for other platforms.</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="/usr/lib/haxe/std/UInt.hx" private="1" module="UInt"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<enum path="haxe.StackItem" params="" file="/usr/lib/haxe/lib/lime/2,0,0/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<LocalFunction a="v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
	</enum>
	<class path="haxe.CallStack" params="" file="/usr/lib/haxe/lib/lime/2,0,0/haxe/CallStack.hx">
		<callStack public="1" set="method" line="43" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="123" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<meta><m n=":noStack"/></meta>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="189" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<itemToString set="method" line="202" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
		<makeStack set="method" line="229" static="1">
			<f a="s">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":noStack"/></meta>
		</makeStack>
		<haxe_doc>Get informations about the call stack.</haxe_doc>
	</class>
	<abstract path="haxe.EnumFlags" params="T" file="/usr/lib/haxe/std/haxe/EnumFlags.hx">
		<this><x path="Int"/></this>
		<haxe_doc>A typed interface for bit flags. This is not a real object, only a typed
	interface for an actual Int. Each flag can be tested/set with the
	corresponding enum instance. Up to 32 flags can be stored that way.

	Enum constructor indices are preserved from haxe syntax, so the first
	declared is index 0, the next index 1 etc. The methods are optimized if the
	enum instance is passed directly, e.g. as has(EnumCtor). Otherwise
	Type.enumIndex() reflection is used.</haxe_doc>
		<impl><class path="haxe._EnumFlags.EnumFlags_Impl_" params="" file="/usr/lib/haxe/std/haxe/EnumFlags.hx" private="1" module="haxe.EnumFlags"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params" v="::null">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params" v="::null">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array [] if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos" v=":null">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Serializer" params="" file="/usr/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="55" static="1">
			<x path="Bool"/>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set USE_CACHE to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="67" static="1">
			<x path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="69" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="526" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="115">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		http://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="150"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="169"><f a="v">
	<unknown/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="206"><f a="v">
	<unknown/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="224">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<new public="1" set="method" line="100">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc>The Serializer class can be used to encode values and objects into a String,
	from which the Unserializer class can recreate the original representation.

	This class can be used in two ways:

	- create a new Serializer() instance, call its serialize() method with
		any argument and finally retrieve the String representation from
		toString()
	- call Serializer.run() to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	`http://haxe.org/manual/serialization/format`</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.Timer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/haxe/Timer.hx">
		<sRunningTimers line="211" static="1"><c path="Array"><c path="haxe.Timer"/></c></sRunningTimers>
		<delay public="1" set="method" line="228" static="1"><f a="f:time">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<getMS set="method" line="244" static="1"><f a=""><x path="Float"/></f></getMS>
		<measure public="1" params="T" set="method" line="251" static="1"><f a="f:?pos" v=":null">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<stamp public="1" set="method" line="268" static="1"><f a=""><x path="Float"/></f></stamp>
		<__checkTimers public="1" set="method" line="309" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__checkTimers>
		<__nextWake public="1" set="method" line="338" static="1">
			<f a="limit">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__nextWake>
		<lime_time_stamp static="1"><d/></lime_time_stamp>
		<mTime><x path="Float"/></mTime>
		<mFireAt><x path="Float"/></mFireAt>
		<mRunning><x path="Bool"/></mRunning>
		<run public="1" set="dynamic" line="261"><f a=""><x path="Void"/></f></run>
		<stop public="1" set="method" line="275"><f a=""><x path="Void"/></f></stop>
		<__check set="method" line="297">
			<f a="inTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__check>
		<new public="1" set="method" line="218"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="60" static="1">
			<t path="haxe.TypeResolver"/>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a Class or Enum instance from a given String. By
		default, the haxe Type Api is used.

		A type resolver must provide two methods:

		1. resolveClass(name:String):Class<Dynamic> is called to determine a
				Class from a class name
		2. resolveEnum(name:String):Enum<Dynamic> is called to determine an
				Enum from an enum name

		This value is applied when a new Unserializer instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 line="62" static="1"><c path="String"/></BASE64>
		<CODES line="65" static="1"><c path="Array"><x path="Int"/></c></CODES>
		<initCodes set="method" line="67" static="1"><f a=""><c path="Array"><x path="Int"/></c></f></initCodes>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" set="method" line="124">
			<f a="r">
				<t path="haxe.TypeResolver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the type resolver of `this` Unserializer instance to `r`.

		If `r` is null, a special resolver is used which returns null for all
		input values.

		See DEFAULT_RESOLVER for more information on type resolvers.</haxe_doc>
		</setResolver>
		<readDigits set="method" line="147"><f a=""><x path="Int"/></f></readDigits>
		<unserializeObject set="method" line="172"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="187"><f a="edecl:tag">
	<x path="Enum"><unknown/></x>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="219">
			<f a=""><d/></f>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from Type.createEmptyInstance, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="99">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc>The Unserializer class is the complement to the Serializer class. It parses
	a serialization String and creates objects from the contained data.

	This class can be used in two ways:

	- create a new Unserializer() instance with a given serialization
		String, then call its unserialize() method until all values are
		extracted
	- call Unserializer.run() to unserialize a single value from a given
		String</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/usr/lib/haxe/std/haxe/crypto/BaseCode.hx">
		<haxe_doc>Allows to encode/decode String and bytes using a power of two base dictionnary.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx">
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<t path="Null"><c path="haxe.ds.BalancedTree.V"/></t>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<setLoop set="method" line="132"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<balance set="method" line="187"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="201"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/usr/lib/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<new public="1" set="method" line="220"><f a="l:k:v:r:?h" v="::::-1">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.TreeNode.K"/>
		<c path="haxe.ds.TreeNode.V"/>
	</c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="33" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="42"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="52"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/IntMap.hx">
		<implements path="IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<keys public="1" set="method" line="48">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/ObjectMap.hx">
		<implements path="IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<__Internal><c path="haxe.ds.IntMap"><c path="haxe.ds.ObjectMap.V"/></c></__Internal>
		<__KeyRefs><c path="haxe.ds.IntMap"><c path="haxe.ds.ObjectMap.K"/></c></__KeyRefs>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="40">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<keys public="1" set="method" line="54">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/cpp/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<__Internal><d/></__Internal>
		<set public="1" set="method" line="31">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="35">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="39">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="43">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="47">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="/usr/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="/usr/lib/haxe/std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="357" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="382" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="435" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<blit public="1" set="method" line="75"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<sub public="1" set="method" line="127"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<getDouble public="1" set="method" line="203"><f a="pos">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getFloat public="1" set="method" line="218"><f a="pos">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat>
		<setDouble public="1" set="method" line="233"><f a="pos:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setDouble>
		<setFloat public="1" set="method" line="247"><f a="pos:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<new set="method" line="33"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><t path="haxe.io.BytesData"/></b>
		<getBytes public="1" set="method" line="173">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Unsigned_char__" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx" module="haxe.io.BytesData" extern="1"/>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><c path="haxe.io.Unsigned_char__"/></c></typedef>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<readByte public="1" set="method" line="37"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="46"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="67"><f a=""><x path="Void"/></f></close>
		<readLine public="1" set="method" line="127"><f a=""><c path="String"/></f></readLine>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Output" params="" file="/usr/lib/haxe/std/haxe/io/Output.hx">
		<writeByte public="1" set="method" line="38"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="42"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="68"><f a=""><x path="Void"/></f></close>
		<write public="1" set="method" line="78"><f a="s">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></write>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<typedef path="haxe.macro.Position" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><x path="Int"/></min>
	<max><x path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<typedef path="haxe.macro.Expr" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.Case" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<guard>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</guard>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Var" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></typedef>
	<typedef path="haxe.macro.Catch" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></typedef>
	<typedef path="haxe.macro.TypePath" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params>
		<c path="Array"><e path="haxe.macro.TypeParam"/></c>
		<meta><m n=":optional"/></meta>
	</params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<params>
		<c path="Array"><t path="haxe.macro.TypeParamDecl"/></c>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
	<constraints>
		<c path="Array"><e path="haxe.macro.ComplexType"/></c>
		<meta><m n=":optional"/></meta>
	</constraints>
</a></typedef>
	<typedef path="haxe.macro.Function" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params>
		<c path="Array"><t path="haxe.macro.TypeParamDecl"/></c>
		<meta><m n=":optional"/></meta>
	</params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params>
		<c path="Array"><t path="haxe.macro.Expr"/></c>
		<meta><m n=":optional"/></meta>
	</params>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><t path="haxe.macro.MetadataEntry"/></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="haxe.macro.Metadata"/>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<c path="Array"><e path="haxe.macro.Access"/></c>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/usr/lib/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params>
		<c path="Array"><t path="haxe.macro.TypeParamDecl"/></c>
		<meta><m n=":optional"/></meta>
	</params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta>
		<t path="haxe.macro.Metadata"/>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<typedef path="haxe.macro.Ref" params="T" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<toString set="method"><f a=""><c path="String"/></f></toString>
	<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
</a></typedef>
	<typedef path="haxe.macro.AnonType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<status><e path="haxe.macro.AnonStatus"/></status>
	<fields><c path="Array"><t path="haxe.macro.ClassField"/></c></fields>
</a></typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.BaseType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassField" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.FieldKind"/></kind>
	<isPublic><x path="Bool"/></isPublic>
	<expr set="method"><f a=""><t path="Null"><t path="haxe.macro.TypedExpr"/></t></f></expr>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<superClass><t path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></t></superClass>
	<statics><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></statics>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<overrides><c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c></overrides>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.ClassKind"/></kind>
	<isPrivate><x path="Bool"/></isPrivate>
	<isInterface><x path="Bool"/></isInterface>
	<isExtern><x path="Bool"/></isExtern>
	<interfaces><c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c></interfaces>
	<init><t path="Null"><t path="haxe.macro.TypedExpr"/></t></init>
	<fields><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></fields>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructor><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></t></constructor>
</a></typedef>
	<typedef path="haxe.macro.EnumField" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<index><x path="Int"/></index>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.EnumType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<names><c path="Array"><c path="String"/></c></names>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructs><c path="haxe.ds.StringMap"><t path="haxe.macro.EnumField"/></c></constructs>
</a></typedef>
	<typedef path="haxe.macro.DefType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<unops><c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c></unops>
	<type><e path="haxe.macro.Type"/></type>
	<to><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><t path="Null"><t path="haxe.macro.ClassField"/></t></field>
</a></c></to>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><x path="Bool"/></isPrivate>
	<isExtern><x path="Bool"/></isExtern>
	<impl><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t></impl>
	<from><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><t path="Null"><t path="haxe.macro.ClassField"/></t></field>
</a></c></from>
	<exclude set="method"><f a=""><x path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<binops><c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c></binops>
	<array><c path="Array"><t path="haxe.macro.ClassField"/></c></array>
</a></typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
	<id><x path="Int"/></id>
	<extra><t path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><t path="Null"><t path="haxe.macro.TypedExpr"/></t></expr>
</a></t></extra>
	<capture><x path="Bool"/></capture>
</a></typedef>
	<typedef path="haxe.macro.TFunc" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<expr><t path="haxe.macro.TypedExpr"/></expr>
	<args><c path="Array"><a>
	<value><t path="Null"><e path="haxe.macro.TConstant"/></t></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c></args>
</a></typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="/usr/lib/haxe/std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<t><e path="haxe.macro.Type"/></t>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.TypedExprDef"/></expr>
</a></typedef>
	<class path="haxe.zip.Compress" params="" file="/usr/lib/haxe/std/cpp/_std/haxe/zip/Compress.hx">
		<run public="1" set="method" line="45" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_deflate_init line="56" static="1"><f a="">
	<x path="Int"/>
	<unknown/>
</f></_deflate_init>
		<_deflate_bound line="57" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
</f></_deflate_bound>
		<_deflate_buffer line="58" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></_deflate_buffer>
		<_deflate_end line="59" static="1"><f a="">
	<d/>
	<unknown/>
</f></_deflate_end>
		<_set_flush_mode line="60" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="level">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="haxe.zip.FlushMode" params="" file="/usr/lib/haxe/std/haxe/zip/FlushMode.hx">
		<NO/>
		<SYNC/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="haxe.zip.Uncompress" params="" file="/usr/lib/haxe/std/cpp/_std/haxe/zip/Uncompress.hx">
		<run public="1" set="method" line="44" static="1"><f a="src:?bufsize" v=":null">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init line="62" static="1"><f a="">
	<t path="Null"><x path="Int"/></t>
	<unknown/>
</f></_inflate_init>
		<_inflate_buffer line="63" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></_inflate_buffer>
		<_inflate_end line="64" static="1"><f a="">
	<d/>
	<unknown/>
</f></_inflate_end>
		<_set_flush_mode line="65" static="1"><f a=":">
	<d/>
	<unknown/>
	<unknown/>
</f></_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="32"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="36"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="40"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="28"><f a="?windowBits" v="null">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="lime.AssetCache" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/Assets.hx" module="lime.Assets">
		<audio public="1"><x path="Map">
	<c path="String"/>
	<c path="lime.audio.AudioBuffer"/>
</x></audio>
		<enabled public="1"><x path="Bool"/></enabled>
		<image public="1"><x path="Map">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</x></image>
		<font public="1"><x path="Map">
	<c path="String"/>
	<d/>
</x></font>
		<clear public="1" set="method" line="1164"><f a="?prefix" v="null">
	<c path="String"/>
	<x path="Void"/>
</f></clear>
		<new public="1" set="method" line="1155"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.Assets" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/Assets.hx">
		<cache public="1" line="34" static="1"><c path="lime.AssetCache"/></cache>
		<libraries public="1" set="null" line="35" static="1"><x path="Map">
	<c path="String"/>
	<c path="lime.AssetLibrary"/>
</x></libraries>
		<initialized line="37" static="1"><x path="Bool"/></initialized>
		<exists public="1" set="method" line="40" static="1"><f a="id:?type" v=":null">
	<c path="String"/>
	<x path="lime.AssetType"/>
	<x path="Bool"/>
</f></exists>
		<getAudioBuffer public="1" set="method" line="75" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.audio.AudioBuffer"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getAudioBuffer>
		<getBytes public="1" set="method" line="144" static="1">
			<f a="id">
				<c path="String"/>
				<c path="lime.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="193" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getImage public="1" set="method" line="257" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap(Assets.getBitmapData("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache(Default: true)
	 * @return		A new BitmapData object</haxe_doc>
		</getImage>
		<getLibrary set="method" line="320" static="1"><f a="name">
	<c path="String"/>
	<c path="lime.AssetLibrary"/>
</f></getLibrary>
		<getPath public="1" set="method" line="408" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded streaming sound
	 * @usage		var sound = Assets.getMusic("sound.ogg");
	 * @param	id		The ID or asset path for the music track
	 * @return		A new Sound object</haxe_doc>
		</getPath>
		<getText public="1" set="method" line="449" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<initialize set="method" line="492" static="1"><f a=""><x path="Void"/></f></initialize>
		<isLocal public="1" set="method" line="509" static="1"><f a="id:?type:?useCache" v=":null:true">
	<c path="String"/>
	<x path="lime.AssetType"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></isLocal>
		<isValidAudio set="method" line="554" static="1"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></isValidAudio>
		<isValidImage set="method" line="568" static="1"><f a="buffer">
	<c path="lime.graphics.Image"/>
	<x path="Bool"/>
</f></isValidImage>
		<list public="1" set="method" line="597" static="1"><f a="?type" v="null">
	<x path="lime.AssetType"/>
	<c path="Array"><c path="String"/></c>
</f></list>
		<loadAudioBuffer public="1" set="method" line="620" static="1"><f a="id:handler:?useCache" v="::true">
	<c path="String"/>
	<f a="">
		<c path="lime.audio.AudioBuffer"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadAudioBuffer>
		<loadBytes public="1" set="method" line="683" static="1"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="lime.utils.ByteArray"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBytes>
		<loadImage public="1" set="method" line="719" static="1"><f a="id:handler:?useCache" v="::true">
	<c path="String"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadImage>
		<loadLibrary public="1" set="method" line="782" static="1"><f a="name:handler">
	<c path="String"/>
	<f a="">
		<c path="lime.AssetLibrary"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadLibrary>
		<loadText public="1" set="method" line="872" static="1"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadText>
		<registerLibrary public="1" set="method" line="908" static="1"><f a="name:library">
	<c path="String"/>
	<c path="lime.AssetLibrary"/>
	<x path="Void"/>
</f></registerLibrary>
		<unloadLibrary public="1" set="method" line="927" static="1"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></unloadLibrary>
		<library_onEvent set="method" line="956" static="1"><f a="library:type">
	<c path="lime.AssetLibrary"/>
	<c path="String"/>
	<x path="Void"/>
</f></library_onEvent>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="lime.AssetLibrary" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/Assets.hx" module="lime.Assets">
		<eventCallback public="1"><d/></eventCallback>
		<exists public="1" set="method" line="984"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAudioBuffer public="1" set="method" line="991"><f a="id">
	<c path="String"/>
	<c path="lime.audio.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="998"><f a="id">
	<c path="String"/>
	<c path="lime.utils.ByteArray"/>
</f></getBytes>
		<getFont public="1" set="method" line="1005"><f a="id">
	<c path="String"/>
	<d/>
</f></getFont>
		<getImage public="1" set="method" line="1012"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="1026"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getText public="1" set="method" line="1033"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<isLocal public="1" set="method" line="1058"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<list public="1" set="method" line="1065"><f a="type">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></list>
		<load set="method" line="1072"><f a="handler">
	<f a="">
		<c path="lime.AssetLibrary"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></load>
		<loadAudioBuffer public="1" set="method" line="1079"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="lime.audio.AudioBuffer"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadAudioBuffer>
		<loadBytes public="1" set="method" line="1086"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="lime.utils.ByteArray"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadBytes>
		<loadFont public="1" set="method" line="1093"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadFont>
		<loadImage public="1" set="method" line="1100"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadImage>
		<loadText public="1" set="method" line="1114"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadText>
		<new public="1" set="method" line="977"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="lime.AssetType" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/Assets.hx" module="lime.Assets">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._Assets.AssetType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/Assets.hx" private="1" module="lime.Assets">
	<BINARY public="1" get="inline" set="null" line="1220" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BINARY>
	<FONT public="1" get="inline" set="null" line="1221" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONT>
	<IMAGE public="1" get="inline" set="null" line="1222" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</IMAGE>
	<MUSIC public="1" get="inline" set="null" line="1223" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUSIC>
	<SOUND public="1" get="inline" set="null" line="1224" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOUND>
	<TEMPLATE public="1" get="inline" set="null" line="1225" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEMPLATE>
	<TEXT public="1" get="inline" set="null" line="1226" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime._Assets.AssetType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/Assets.hx" private="1" module="lime.Assets">
		<BINARY public="1" get="inline" set="null" line="1220" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BINARY>
		<FONT public="1" get="inline" set="null" line="1221" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONT>
		<IMAGE public="1" get="inline" set="null" line="1222" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</IMAGE>
		<MUSIC public="1" get="inline" set="null" line="1223" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUSIC>
		<SOUND public="1" get="inline" set="null" line="1224" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOUND>
		<TEMPLATE public="1" get="inline" set="null" line="1225" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEMPLATE>
		<TEXT public="1" get="inline" set="null" line="1226" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.app.Module" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/app/Module.hx"><new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new></class>
	<class path="lime.app._Application.UpdateEventInfo" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/app/Application.hx" private="1" module="lime.app.Application">
		<deltaTime public="1"><x path="Int"/></deltaTime>
		<type public="1"><x path="lime.app._Application.UpdateEventType"/></type>
		<clone public="1" set="method" line="454"><f a=""><c path="lime.app._Application.UpdateEventInfo"/></f></clone>
		<new public="1" set="method" line="446"><f a="?type:?deltaTime" v="null:0">
	<x path="lime.app._Application.UpdateEventType"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.system.System" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/system/System.hx">
		<disableCFFI public="1" static="1"><x path="Bool"/></disableCFFI>
		<__moduleNames line="21" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__moduleNames>
		<findHaxeLib set="method" line="86" static="1"><f a="library">
	<c path="String"/>
	<c path="String"/>
</f></findHaxeLib>
		<load public="1" set="method" line="131" static="1"><f a="library:method:?args:?lazy" v="::0:false">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Bool"/>
	<d/>
</f></load>
		<sysName set="method" line="244" static="1"><f a=""><c path="String"/></f></sysName>
		<tryLoad set="method" line="260" static="1"><f a="name:library:func:args">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></tryLoad>
		<loaderTrace set="method" line="297" static="1"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></loaderTrace>
	</class>
	<class path="sys.io.Process" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/Process.hx">
		<_run line="123" static="1"><f a=":">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></_run>
		<_close line="126" static="1"><f a="">
	<d/>
	<unknown/>
</f></_close>
		<p><d/></p>
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<close public="1" set="method" line="115"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="100"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io._Process.Stdin" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Output"/>
		<_stdin_write line="53" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stdin_write>
		<_stdin_close line="54" static="1"><f a="">
	<d/>
	<unknown/>
</f></_stdin_close>
		<p><d/></p>
		<buf><c path="haxe.io.Bytes"/></buf>
		<close public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></close>
		<writeByte public="1" set="method" line="39" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="44" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<new public="1" set="method" line="29"><f a="p">
	<unknown/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="sys.io._Process.Stdout" params="" file="/usr/lib/haxe/std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Input"/>
		<_stdout_read line="87" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stdout_read>
		<_stderr_read line="88" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></_stderr_read>
		<p><d/></p>
		<out><x path="Bool"/></out>
		<buf><c path="haxe.io.Bytes"/></buf>
		<readByte public="1" set="method" line="70" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="76" override="1"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="64"><f a="p:out">
	<unknown/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="lime.app.Event" params="T" file="/usr/lib/haxe/lib/lime/2,0,0/lime/app/Event.hx">
		<listeners public="1">
			<c path="Array"><c path="lime.app.Event.T"/></c>
			<meta><m n=":noCompletion"/></meta>
		</listeners>
		<repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta><m n=":noCompletion"/></meta>
		</repeat>
		<priorities><c path="Array"><x path="Int"/></c></priorities>
		<add public="1" set="method" line="26"><f a="listener:?once:?priority" v=":false:0">
	<c path="lime.app.Event.T"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="79"><f a="listener">
	<c path="lime.app.Event.T"/>
	<x path="Void"/>
</f></remove>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.app.Application" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/app/Application.hx">
		<extends path="lime.app.Module"/>
		<onUpdate public="1" line="28" static="1">
			<c path="lime.app.Event"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<haxe_doc>* Update events are dispatched each frame (usually just before rendering)</haxe_doc>
		</onUpdate>
		<__eventInfo line="30" static="1"><c path="lime.app._Application.UpdateEventInfo"/></__eventInfo>
		<__initialized static="1"><x path="Bool"/></__initialized>
		<__instance static="1"><c path="lime.app.Application"/></__instance>
		<__registered static="1"><x path="Bool"/></__registered>
		<__dispatch set="method" line="393" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__dispatch>
		<lime_application_create line="427" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></lime_application_create>
		<lime_application_init line="428" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_application_init>
		<lime_application_update line="429" static="1"><f a="">
	<d/>
	<x path="Bool"/>
</f></lime_application_update>
		<lime_application_quit line="430" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></lime_application_quit>
		<lime_application_get_ticks line="431" static="1"><unknown/></lime_application_get_ticks>
		<lime_update_event_manager_register line="432" static="1"><f a=":">
	<f a=""><x path="Void"/></f>
	<c path="lime.app._Application.UpdateEventInfo"/>
	<unknown/>
</f></lime_update_event_manager_register>
		<config public="1" set="null"><t path="lime.app.Config"/></config>
		<window public="1" get="accessor" set="null"><c path="lime.ui.Window"/></window>
		<windows public="1" set="null"><c path="Array"><c path="lime.ui.Window"/></c></windows>
		<__handle>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<addWindow public="1" set="method" line="70">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new Window to the Application. By default, this is
	 * called automatically by create()
	 * @param	window	A Window object to add</haxe_doc>
		</addWindow>
		<create public="1" set="method" line="84">
			<f a="config">
				<t path="lime.app.Config"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initializes the Application, using the settings defined in
	 * the config instance. By default, this is called automatically
	 * when building the project using Lime's command-line tools
	 * @param	config	A Config object</haxe_doc>
		</create>
		<exec public="1" set="method" line="137">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Execute the Application. On native platforms, this method
	 * blocks until the application is finished running. On other 
	 * platforms, it will return immediately
	 * @return An exit code, 0 if there was no error</haxe_doc>
		</exec>
		<__cleanup set="method" line="227">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__cleanup>
		<init public="1" set="method" line="240">
			<f a="context">
				<e path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The init() method is called once before the first render()
	 * call. This can be used to do initial set-up for the current
	 * render context
	 * @param	context The current render context</haxe_doc>
		</init>
		<onKeyDown public="1" set="method" line="252">
			<f a="keyCode:modifier">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a key down event is fired
	 * @param	keyCode	The code of the key that was pressed
	 * @param	modifier	The modifier of the key that was pressed</haxe_doc>
		</onKeyDown>
		<onKeyUp public="1" set="method" line="260">
			<f a="keyCode:modifier">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a key up event is fired
	 * @param	keyCode	The code of the key that was released
	 * @param	modifier	The modifier of the key that was released</haxe_doc>
		</onKeyUp>
		<onMouseDown public="1" set="method" line="269">
			<f a="x:y:button">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse down event is fired
	 * @param	x	The current x coordinate of the mouse
	 * @param	y	The current y coordinate of the mouse
	 * @param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseDown>
		<onMouseMove public="1" set="method" line="278">
			<f a="x:y:button">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse move event is fired
	 * @param	x	The current x coordinate of the mouse
	 * @param	y	The current y coordinate of the mouse
	 * @param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseMove>
		<onMouseUp public="1" set="method" line="287">
			<f a="x:y:button">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse up event is fired
	 * @param	x	The current x coordinate of the mouse
	 * @param	y	The current y coordinate of the mouse
	 * @param	button	The ID of the button that was released</haxe_doc>
		</onMouseUp>
		<onMouseWheel public="1" set="method" line="295">
			<f a="deltaX:deltaY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse wheel event is fired
	 * @param	deltaX	The amount of horizontal scrolling (if applicable)
	 * @param	deltaY	The amount of vertical scrolling (if applicable)</haxe_doc>
		</onMouseWheel>
		<onTouchEnd public="1" set="method" line="304">
			<f a="x:y:id">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a touch end event is fired
	 * @param	x	The current x coordinate of the touch point
	 * @param	y	The current y coordinate of the touch point
	 * @param	id	The ID of the touch point</haxe_doc>
		</onTouchEnd>
		<onTouchMove public="1" set="method" line="313">
			<f a="x:y:id">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a touch move event is fired
	 * @param	x	The current x coordinate of the touch point
	 * @param	y	The current y coordinate of the touch point
	 * @param	id	The ID of the touch point</haxe_doc>
		</onTouchMove>
		<onTouchStart public="1" set="method" line="322">
			<f a="x:y:id">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a touch start event is fired
	 * @param	x	The current x coordinate of the touch point
	 * @param	y	The current y coordinate of the touch point
	 * @param	id	The ID of the touch point</haxe_doc>
		</onTouchStart>
		<onWindowActivate public="1" set="method" line="328">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when a window activate event is fired</haxe_doc>
		</onWindowActivate>
		<onWindowClose public="1" set="method" line="334">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when a window close event is fired</haxe_doc>
		</onWindowClose>
		<onWindowDeactivate public="1" set="method" line="340">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when a window deactivate event is fired</haxe_doc>
		</onWindowDeactivate>
		<onWindowFocusIn public="1" set="method" line="346">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when a window focus in event is fired</haxe_doc>
		</onWindowFocusIn>
		<onWindowFocusOut public="1" set="method" line="352">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when a window focus out event is fired</haxe_doc>
		</onWindowFocusOut>
		<onWindowMove public="1" set="method" line="360">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window move event is fired
	 * @param	x	The x position of the window
	 * @param	y	The y position of the window</haxe_doc>
		</onWindowMove>
		<onWindowResize public="1" set="method" line="368">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window resize event is fired
	 * @param	width	The width of the window
	 * @param	height	The height of the window</haxe_doc>
		</onWindowResize>
		<render public="1" set="method" line="375">
			<f a="context">
				<e path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a render event is fired
	 * @param	context	The current render context</haxe_doc>
		</render>
		<update public="1" set="method" line="386">
			<f a="deltaTime">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when an update event is fired
	 * @param	deltaTime	The amount of time in milliseconds that has elapsed since the last update</haxe_doc>
		</update>
		<__triggerFrame set="method" line="405">
			<f a="?_" v="null">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__triggerFrame>
		<get_window get="inline" set="null" line="419">
			<f a=""><c path="lime.ui.Window"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_window>
		<new public="1" set="method" line="42"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* The Application class forms the foundation for most Lime projects.
 * It is common to extend this class in a main class. It is then possible
 * to override "on" functions in the class in order to handle standard events
 * that are relevant.</haxe_doc>
	</class>
	<abstract path="lime.app._Application.UpdateEventType" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/app/Application.hx" private="1" module="lime.app.Application">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.app._Application.UpdateEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/app/Application.hx" private="1" module="lime.app.Application">
	<UPDATE public="1" get="inline" set="null" line="466" static="1">
		<x path="lime.app._Application.UpdateEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UPDATE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.app._Application.UpdateEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/app/Application.hx" private="1" module="lime.app.Application">
		<UPDATE public="1" get="inline" set="null" line="466" static="1">
			<x path="lime.app._Application.UpdateEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UPDATE>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="lime.app.Config" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/app/Config.hx"><a>
	<width>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</width>
	<vsync>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</vsync>
	<title>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</title>
	<stencilBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</stencilBuffer>
	<resizable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</resizable>
	<orientation>
		<c path="String"/>
		<meta><m n=":optional"/></meta>
	</orientation>
	<height>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</height>
	<fullscreen>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</fullscreen>
	<fps>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</fps>
	<depthBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</depthBuffer>
	<borderless>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</borderless>
	<background>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</background>
	<antialiasing>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</antialiasing>
</a></typedef>
	<class path="lime.audio.ALAudioContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/ALAudioContext.hx">
		<NONE public="1"><x path="Int"/></NONE>
		<FALSE public="1"><x path="Int"/></FALSE>
		<TRUE public="1"><x path="Int"/></TRUE>
		<SOURCE_RELATIVE public="1"><x path="Int"/></SOURCE_RELATIVE>
		<CONE_INNER_ANGLE public="1"><x path="Int"/></CONE_INNER_ANGLE>
		<CONE_OUTER_ANGLE public="1"><x path="Int"/></CONE_OUTER_ANGLE>
		<PITCH public="1"><x path="Int"/></PITCH>
		<POSITION public="1"><x path="Int"/></POSITION>
		<DIRECTION public="1"><x path="Int"/></DIRECTION>
		<VELOCITY public="1"><x path="Int"/></VELOCITY>
		<LOOPING public="1"><x path="Int"/></LOOPING>
		<BUFFER public="1"><x path="Int"/></BUFFER>
		<GAIN public="1"><x path="Int"/></GAIN>
		<MIN_GAIN public="1"><x path="Int"/></MIN_GAIN>
		<MAX_GAIN public="1"><x path="Int"/></MAX_GAIN>
		<ORIENTATION public="1"><x path="Int"/></ORIENTATION>
		<SOURCE_STATE public="1"><x path="Int"/></SOURCE_STATE>
		<INITIAL public="1"><x path="Int"/></INITIAL>
		<PLAYING public="1"><x path="Int"/></PLAYING>
		<PAUSED public="1"><x path="Int"/></PAUSED>
		<STOPPED public="1"><x path="Int"/></STOPPED>
		<BUFFERS_QUEUED public="1"><x path="Int"/></BUFFERS_QUEUED>
		<BUFFERS_PROCESSED public="1"><x path="Int"/></BUFFERS_PROCESSED>
		<REFERENCE_DISTANCE public="1"><x path="Int"/></REFERENCE_DISTANCE>
		<ROLLOFF_FACTOR public="1"><x path="Int"/></ROLLOFF_FACTOR>
		<CONE_OUTER_GAIN public="1"><x path="Int"/></CONE_OUTER_GAIN>
		<MAX_DISTANCE public="1"><x path="Int"/></MAX_DISTANCE>
		<SEC_OFFSET public="1"><x path="Int"/></SEC_OFFSET>
		<SAMPLE_OFFSET public="1"><x path="Int"/></SAMPLE_OFFSET>
		<BYTE_OFFSET public="1"><x path="Int"/></BYTE_OFFSET>
		<SOURCE_TYPE public="1"><x path="Int"/></SOURCE_TYPE>
		<STATIC public="1"><x path="Int"/></STATIC>
		<STREAMING public="1"><x path="Int"/></STREAMING>
		<UNDETERMINED public="1"><x path="Int"/></UNDETERMINED>
		<FORMAT_MONO8 public="1"><x path="Int"/></FORMAT_MONO8>
		<FORMAT_MONO16 public="1"><x path="Int"/></FORMAT_MONO16>
		<FORMAT_STEREO8 public="1"><x path="Int"/></FORMAT_STEREO8>
		<FORMAT_STEREO16 public="1"><x path="Int"/></FORMAT_STEREO16>
		<FREQUENCY public="1"><x path="Int"/></FREQUENCY>
		<BITS public="1"><x path="Int"/></BITS>
		<CHANNELS public="1"><x path="Int"/></CHANNELS>
		<SIZE public="1"><x path="Int"/></SIZE>
		<NO_ERROR public="1"><x path="Int"/></NO_ERROR>
		<INVALID_NAME public="1"><x path="Int"/></INVALID_NAME>
		<INVALID_ENUM public="1"><x path="Int"/></INVALID_ENUM>
		<INVALID_VALUE public="1"><x path="Int"/></INVALID_VALUE>
		<INVALID_OPERATION public="1"><x path="Int"/></INVALID_OPERATION>
		<OUT_OF_MEMORY public="1"><x path="Int"/></OUT_OF_MEMORY>
		<VENDOR public="1"><x path="Int"/></VENDOR>
		<VERSION public="1"><x path="Int"/></VERSION>
		<RENDERER public="1"><x path="Int"/></RENDERER>
		<EXTENSIONS public="1"><x path="Int"/></EXTENSIONS>
		<DOPPLER_FACTOR public="1"><x path="Int"/></DOPPLER_FACTOR>
		<SPEED_OF_SOUND public="1"><x path="Int"/></SPEED_OF_SOUND>
		<DOPPLER_VELOCITY public="1"><x path="Int"/></DOPPLER_VELOCITY>
		<DISTANCE_MODEL public="1"><x path="Int"/></DISTANCE_MODEL>
		<INVERSE_DISTANCE public="1"><x path="Int"/></INVERSE_DISTANCE>
		<INVERSE_DISTANCE_CLAMPED public="1"><x path="Int"/></INVERSE_DISTANCE_CLAMPED>
		<LINEAR_DISTANCE public="1"><x path="Int"/></LINEAR_DISTANCE>
		<LINEAR_DISTANCE_CLAMPED public="1"><x path="Int"/></LINEAR_DISTANCE_CLAMPED>
		<EXPONENT_DISTANCE public="1"><x path="Int"/></EXPONENT_DISTANCE>
		<EXPONENT_DISTANCE_CLAMPED public="1"><x path="Int"/></EXPONENT_DISTANCE_CLAMPED>
		<bufferData public="1" set="method" line="82"><f a="buffer:format:data:size:freq">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<buffer3f public="1" set="method" line="89"><f a="buffer:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></buffer3f>
		<buffer3i public="1" set="method" line="96"><f a="buffer:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></buffer3i>
		<bufferf public="1" set="method" line="103"><f a="buffer:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bufferf>
		<bufferfv public="1" set="method" line="110"><f a="buffer:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></bufferfv>
		<bufferi public="1" set="method" line="117"><f a="buffer:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferi>
		<bufferiv public="1" set="method" line="124"><f a="buffer:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></bufferiv>
		<deleteBuffer public="1" set="method" line="131"><f a="buffer">
	<x path="Int"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteBuffers public="1" set="method" line="138"><f a="buffers">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></deleteBuffers>
		<deleteSource public="1" set="method" line="145"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></deleteSource>
		<deleteSources public="1" set="method" line="152"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></deleteSources>
		<disable public="1" set="method" line="159"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<distanceModel public="1" set="method" line="166"><f a="distanceModel">
	<x path="Int"/>
	<x path="Void"/>
</f></distanceModel>
		<dopplerFactor public="1" set="method" line="173"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></dopplerFactor>
		<dopplerVelocity public="1" set="method" line="180"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></dopplerVelocity>
		<enable public="1" set="method" line="187"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<genSource public="1" set="method" line="194"><f a=""><x path="Int"/></f></genSource>
		<genSources public="1" set="method" line="201"><f a="n">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></genSources>
		<genBuffer public="1" set="method" line="208"><f a=""><x path="Int"/></f></genBuffer>
		<genBuffers public="1" set="method" line="215"><f a="n">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></genBuffers>
		<getBoolean public="1" set="method" line="222"><f a="param">
	<x path="Int"/>
	<x path="Bool"/>
</f></getBoolean>
		<getBooleanv public="1" set="method" line="229"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Bool"/></c>
</f></getBooleanv>
		<getBuffer3f public="1" set="method" line="236"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getBuffer3f>
		<getBuffer3i public="1" set="method" line="243"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getBuffer3i>
		<getBufferf public="1" set="method" line="250"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getBufferf>
		<getBufferfv public="1" set="method" line="257"><f a="buffer:param:?count" v="::1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getBufferfv>
		<getBufferi public="1" set="method" line="264"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferi>
		<getBufferiv public="1" set="method" line="271"><f a="buffer:param:?count" v="::1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getBufferiv>
		<getDouble public="1" set="method" line="278"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getDoublev public="1" set="method" line="285"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getDoublev>
		<getEnumValue public="1" set="method" line="292"><f a="ename">
	<c path="String"/>
	<x path="Int"/>
</f></getEnumValue>
		<getError public="1" set="method" line="299"><f a=""><x path="Int"/></f></getError>
		<getErrorString public="1" set="method" line="306"><f a=""><c path="String"/></f></getErrorString>
		<getFloat public="1" set="method" line="313"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat>
		<getFloatv public="1" set="method" line="320"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getFloatv>
		<getInteger public="1" set="method" line="327"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getInteger>
		<getIntegerv public="1" set="method" line="334"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getIntegerv>
		<getListener3f public="1" set="method" line="341"><f a="param">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getListener3f>
		<getListener3i public="1" set="method" line="348"><f a="param">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getListener3i>
		<getListenerf public="1" set="method" line="355"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getListenerf>
		<getListenerfv public="1" set="method" line="362"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getListenerfv>
		<getListeneri public="1" set="method" line="369"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getListeneri>
		<getListeneriv public="1" set="method" line="376"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getListeneriv>
		<getProcAddress public="1" set="method" line="383"><f a="fname">
	<c path="String"/>
	<d/>
</f></getProcAddress>
		<getSource3f public="1" set="method" line="390"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getSource3f>
		<getSourcef public="1" set="method" line="397"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getSourcef>
		<getSource3i public="1" set="method" line="404"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getSource3i>
		<getSourcefv public="1" set="method" line="411"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getSourcefv>
		<getSourcei public="1" set="method" line="418"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getSourcei>
		<getSourceiv public="1" set="method" line="425"><f a="source:param:?count" v="::1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getSourceiv>
		<getString public="1" set="method" line="432"><f a="param">
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<isBuffer public="1" set="method" line="439"><f a="buffer">
	<x path="Int"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" set="method" line="446"><f a="capability">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isExtensionPresent public="1" set="method" line="453"><f a="extname">
	<c path="String"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<isSource public="1" set="method" line="460"><f a="source">
	<x path="Int"/>
	<x path="Bool"/>
</f></isSource>
		<listener3f public="1" set="method" line="467"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></listener3f>
		<listener3i public="1" set="method" line="474"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listener3i>
		<listenerf public="1" set="method" line="481"><f a="param:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></listenerf>
		<listenerfv public="1" set="method" line="488"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></listenerfv>
		<listeneri public="1" set="method" line="495"><f a="param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listeneri>
		<listeneriv public="1" set="method" line="502"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></listeneriv>
		<source3f public="1" set="method" line="509"><f a="source:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></source3f>
		<source3i public="1" set="method" line="516"><f a="source:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></source3i>
		<sourcef public="1" set="method" line="523"><f a="source:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></sourcef>
		<sourcefv public="1" set="method" line="530"><f a="source:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></sourcefv>
		<sourcei public="1" set="method" line="537"><f a="source:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourcei>
		<sourceiv public="1" set="method" line="544"><f a="source:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceiv>
		<sourcePlay public="1" set="method" line="551"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourcePlay>
		<sourcePlayv public="1" set="method" line="558"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourcePlayv>
		<sourceStop public="1" set="method" line="565"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourceStop>
		<sourceStopv public="1" set="method" line="572"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceStopv>
		<sourceRewind public="1" set="method" line="579"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourceRewind>
		<sourceRewindv public="1" set="method" line="586"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceRewindv>
		<sourcePause public="1" set="method" line="593"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourcePause>
		<sourcePausev public="1" set="method" line="600"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourcePausev>
		<sourceQueueBuffer public="1" set="method" line="607"><f a="source:buffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourceQueueBuffer>
		<sourceQueueBuffers public="1" set="method" line="614"><f a="source:nb:buffers">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceQueueBuffers>
		<sourceUnqueueBuffer public="1" set="method" line="621"><f a="source">
	<x path="Int"/>
	<x path="Int"/>
</f></sourceUnqueueBuffer>
		<sourceUnqueueBuffers public="1" set="method" line="628"><f a="source:nb">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></sourceUnqueueBuffers>
		<speedOfSound public="1" set="method" line="635"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></speedOfSound>
		<new public="1" set="method" line="75"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.audio.ALCAudioContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/ALCAudioContext.hx">
		<FALSE public="1"><x path="Int"/></FALSE>
		<TRUE public="1"><x path="Int"/></TRUE>
		<FREQUENCY public="1"><x path="Int"/></FREQUENCY>
		<REFRESH public="1"><x path="Int"/></REFRESH>
		<SYNC public="1"><x path="Int"/></SYNC>
		<MONO_SOURCES public="1"><x path="Int"/></MONO_SOURCES>
		<STEREO_SOURCES public="1"><x path="Int"/></STEREO_SOURCES>
		<NO_ERROR public="1"><x path="Int"/></NO_ERROR>
		<INVALID_DEVICE public="1"><x path="Int"/></INVALID_DEVICE>
		<INVALID_CONTEXT public="1"><x path="Int"/></INVALID_CONTEXT>
		<INVALID_ENUM public="1"><x path="Int"/></INVALID_ENUM>
		<INVALID_VALUE public="1"><x path="Int"/></INVALID_VALUE>
		<OUT_OF_MEMORY public="1"><x path="Int"/></OUT_OF_MEMORY>
		<ATTRIBUTES_SIZE public="1"><x path="Int"/></ATTRIBUTES_SIZE>
		<ALL_ATTRIBUTES public="1"><x path="Int"/></ALL_ATTRIBUTES>
		<DEFAULT_DEVICE_SPECIFIER public="1"><x path="Int"/></DEFAULT_DEVICE_SPECIFIER>
		<DEVICE_SPECIFIER public="1"><x path="Int"/></DEVICE_SPECIFIER>
		<EXTENSIONS public="1"><x path="Int"/></EXTENSIONS>
		<ENUMERATE_ALL_EXT public="1"><x path="Int"/></ENUMERATE_ALL_EXT>
		<DEFAULT_ALL_DEVICES_SPECIFIER public="1"><x path="Int"/></DEFAULT_ALL_DEVICES_SPECIFIER>
		<ALL_DEVICES_SPECIFIER public="1"><x path="Int"/></ALL_DEVICES_SPECIFIER>
		<closeDevice public="1" set="method" line="42"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Bool"/>
</f></closeDevice>
		<createContext public="1" set="method" line="49"><f a="device:?attrlist" v=":null">
	<x path="lime.audio.openal.ALDevice"/>
	<c path="Array"><x path="Int"/></c>
	<x path="lime.audio.openal.ALContext"/>
</f></createContext>
		<destroyContext public="1" set="method" line="56"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></destroyContext>
		<getContextsDevice public="1" set="method" line="63"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="lime.audio.openal.ALDevice"/>
</f></getContextsDevice>
		<getCurrentContext public="1" set="method" line="70"><f a=""><x path="lime.audio.openal.ALContext"/></f></getCurrentContext>
		<getError public="1" set="method" line="77"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
</f></getError>
		<getErrorString public="1" set="method" line="84"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<c path="String"/>
</f></getErrorString>
		<getIntegerv public="1" set="method" line="91"><f a="device:param:?count" v="::1">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getIntegerv>
		<getString public="1" set="method" line="98"><f a="device:param">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<makeContextCurrent public="1" set="method" line="105"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Bool"/>
</f></makeContextCurrent>
		<openDevice public="1" set="method" line="112"><f a="?deviceName" v="null">
	<c path="String"/>
	<x path="lime.audio.openal.ALDevice"/>
</f></openDevice>
		<processContext public="1" set="method" line="119"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></processContext>
		<suspendContext public="1" set="method" line="126"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></suspendContext>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.audio.AudioBuffer" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/AudioBuffer.hx">
		<fromBytes public="1" set="method" line="48" static="1"><f a="bytes">
	<c path="lime.utils.ByteArray"/>
	<c path="lime.audio.AudioBuffer"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="72" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.audio.AudioBuffer"/>
</f></fromFile>
		<fromURL public="1" set="method" line="96" static="1"><f a="url:handler">
	<c path="String"/>
	<f a="">
		<c path="lime.audio.AudioBuffer"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></fromURL>
		<lime_audio_load line="104" static="1"><d/></lime_audio_load>
		<bitsPerSample public="1"><x path="Int"/></bitsPerSample>
		<channels public="1"><x path="Int"/></channels>
		<data public="1"><c path="lime.utils.ByteArray"/></data>
		<id public="1"><x path="UInt"/></id>
		<sampleRate public="1"><x path="Int"/></sampleRate>
		<src public="1"><d/></src>
		<dispose public="1" set="method" line="41"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="lime.audio.AudioContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/AudioContext.hx">
		<OPENAL a="alc:al">
			<c path="lime.audio.ALCAudioContext"/>
			<c path="lime.audio.ALAudioContext"/>
		</OPENAL>
		<HTML5 a="context"><c path="lime.audio.HTML5AudioContext"/></HTML5>
		<WEB a="context"><c path="lime.audio.WebAudioContext"/></WEB>
		<FLASH a="context"><c path="lime.audio.FlashAudioContext"/></FLASH>
		<CUSTOM a="data"><d/></CUSTOM>
	</enum>
	<class path="lime.audio.AudioManager" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/AudioManager.hx">
		<context public="1" static="1"><e path="lime.audio.AudioContext"/></context>
		<init public="1" set="method" line="20" static="1"><f a="?context" v="null">
	<e path="lime.audio.AudioContext"/>
	<x path="Void"/>
</f></init>
		<resume public="1" set="method" line="56" static="1"><f a=""><x path="Void"/></f></resume>
		<shutdown public="1" set="method" line="75" static="1"><f a=""><x path="Void"/></f></shutdown>
		<suspend public="1" set="method" line="103" static="1"><f a=""><x path="Void"/></f></suspend>
	</class>
	<class path="lime.audio.AudioSource" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/AudioSource.hx">
		<onComplete public="1"><c path="lime.app.Event"><f a=""><x path="Void"/></f></c></onComplete>
		<buffer public="1"><c path="lime.audio.AudioBuffer"/></buffer>
		<gain public="1" get="accessor" set="accessor"><x path="Float"/></gain>
		<timeOffset public="1" get="accessor" set="accessor"><x path="Int"/></timeOffset>
		<id><x path="UInt"/></id>
		<pauseTime><x path="Int"/></pauseTime>
		<init set="method" line="44"><f a=""><x path="Void"/></f></init>
		<play public="1" set="method" line="96"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="109"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="126"><f a=""><x path="Void"/></f></stop>
		<get_gain set="method" line="146"><f a=""><x path="Float"/></f></get_gain>
		<set_gain set="method" line="155"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gain>
		<get_timeOffset set="method" line="164"><f a=""><x path="Int"/></f></get_timeOffset>
		<set_timeOffset set="method" line="173"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_timeOffset>
		<new public="1" set="method" line="29"><f a="?buffer" v="null">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.audio.FlashAudioContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/FlashAudioContext.hx">
		<createBuffer public="1" set="method" line="19"><f a="?stream:?context" v="null:null">
	<d/>
	<d/>
	<c path="lime.audio.AudioBuffer"/>
</f></createBuffer>
		<getBytesLoaded public="1" set="method" line="32"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="UInt"/>
</f></getBytesLoaded>
		<getBytesTotal public="1" set="method" line="47"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Int"/>
</f></getBytesTotal>
		<getID3 public="1" set="method" line="62"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getID3>
		<getIsBuffering public="1" set="method" line="77"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getIsBuffering>
		<getIsURLInaccessible public="1" set="method" line="92"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getIsURLInaccessible>
		<getLength public="1" set="method" line="107"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getLength>
		<getURL public="1" set="method" line="122"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
</f></getURL>
		<close public="1" set="method" line="137"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></close>
		<extract public="1" set="method" line="150"><f a="buffer:target:length:?startPosition" v=":::-1">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></extract>
		<load public="1" set="method" line="165"><f a="buffer:stream:?context" v="::null">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
	<d/>
	<x path="Void"/>
</f></load>
		<loadCompressedDataFromByteArray public="1" set="method" line="178"><f a="buffer:bytes:bytesLength">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
	<x path="UInt"/>
	<x path="Void"/>
</f></loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method" line="191"><f a="buffer:bytes:samples:?format:?stereo:?sampleRate" v=":::null:true:44100">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
	<x path="UInt"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></loadPCMFromByteArray>
		<play public="1" set="method" line="204"><f a="buffer:?startTime:?loops:?sndTransform" v=":0:0:null">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
	<x path="Int"/>
	<d/>
	<d/>
</f></play>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.audio.HTML5AudioContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/HTML5AudioContext.hx">
		<HAVE_CURRENT_DATA public="1"><x path="Int"/></HAVE_CURRENT_DATA>
		<HAVE_ENOUGH_DATA public="1"><x path="Int"/></HAVE_ENOUGH_DATA>
		<HAVE_FUTURE_DATA public="1"><x path="Int"/></HAVE_FUTURE_DATA>
		<HAVE_METADATA public="1"><x path="Int"/></HAVE_METADATA>
		<HAVE_NOTHING public="1"><x path="Int"/></HAVE_NOTHING>
		<NETWORK_EMPTY public="1"><x path="Int"/></NETWORK_EMPTY>
		<NETWORK_IDLE public="1"><x path="Int"/></NETWORK_IDLE>
		<NETWORK_LOADING public="1"><x path="Int"/></NETWORK_LOADING>
		<NETWORK_NO_SOURCE public="1"><x path="Int"/></NETWORK_NO_SOURCE>
		<canPlayType public="1" set="method" line="30"><f a="buffer:type">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
	<c path="String"/>
</f></canPlayType>
		<createBuffer public="1" set="method" line="45"><f a="?urlString" v="null">
	<c path="String"/>
	<c path="lime.audio.AudioBuffer"/>
</f></createBuffer>
		<getAudioDecodedByteCount public="1" set="method" line="59"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Int"/>
</f></getAudioDecodedByteCount>
		<getAutoplay public="1" set="method" line="74"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getAutoplay>
		<getBuffered public="1" set="method" line="89"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getBuffered>
		<getController public="1" set="method" line="104"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getController>
		<getCurrentSrc public="1" set="method" line="119"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
</f></getCurrentSrc>
		<getCurrentTime public="1" set="method" line="134"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getCurrentTime>
		<getDefaultPlaybackRate public="1" set="method" line="149"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getDefaultPlaybackRate>
		<getDuration public="1" set="method" line="164"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getDuration>
		<getEnded public="1" set="method" line="179"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getEnded>
		<getError public="1" set="method" line="194"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getError>
		<getInitialTime public="1" set="method" line="209"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getInitialTime>
		<getLoop public="1" set="method" line="224"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getLoop>
		<getMediaGroup public="1" set="method" line="239"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
</f></getMediaGroup>
		<getMuted public="1" set="method" line="254"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getMuted>
		<getNetworkState public="1" set="method" line="269"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Int"/>
</f></getNetworkState>
		<getPaused public="1" set="method" line="284"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getPaused>
		<getPlaybackRate public="1" set="method" line="299"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getPlaybackRate>
		<getPlayed public="1" set="method" line="314"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getPlayed>
		<getPreload public="1" set="method" line="329"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
</f></getPreload>
		<getReadyState public="1" set="method" line="344"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Int"/>
</f></getReadyState>
		<getSeekable public="1" set="method" line="359"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getSeekable>
		<getSeeking public="1" set="method" line="374"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getSeeking>
		<getSrc public="1" set="method" line="389"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
</f></getSrc>
		<getStartTime public="1" set="method" line="404"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getStartTime>
		<getVolume public="1" set="method" line="419"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getVolume>
		<load public="1" set="method" line="434"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></load>
		<pause public="1" set="method" line="447"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></pause>
		<play public="1" set="method" line="460"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></play>
		<setAutoplay public="1" set="method" line="473"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setAutoplay>
		<setController public="1" set="method" line="486"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
	<x path="Void"/>
</f></setController>
		<setCurrentTime public="1" set="method" line="499"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setCurrentTime>
		<setDefaultPlaybackRate public="1" set="method" line="512"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setDefaultPlaybackRate>
		<setLoop public="1" set="method" line="525"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoop>
		<setMediaGroup public="1" set="method" line="538"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
	<x path="Void"/>
</f></setMediaGroup>
		<setMuted public="1" set="method" line="551"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setMuted>
		<setPlaybackRate public="1" set="method" line="564"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPlaybackRate>
		<setPreload public="1" set="method" line="577"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
	<x path="Void"/>
</f></setPreload>
		<setSrc public="1" set="method" line="590"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
	<x path="Void"/>
</f></setSrc>
		<setVolume public="1" set="method" line="603"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVolume>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.audio.WebAudioContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/WebAudioContext.hx">
		<activeSourceCount public="1" set="null"><x path="Int"/></activeSourceCount>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<destination public="1" set="null"><d/></destination>
		<listener public="1" set="null"><d/></listener>
		<oncomplete public="1"><d/></oncomplete>
		<sampleRate public="1" set="null"><x path="Float"/></sampleRate>
		<createAnalyser public="1" set="method" line="22"><f a=""><d/></f></createAnalyser>
		<createBiquadFilter public="1" set="method" line="23"><f a=""><d/></f></createBiquadFilter>
		<createBuffer public="1" set="method" line="25">
			<f a="buffer:mixToMono">
				<d/>
				<x path="Bool"/>
				<d/>
			</f>
			<overloads><createBuffer public="1" set="method"><f a="numberOfChannels:numberOfFrames:sampleRate">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<d/>
</f></createBuffer></overloads>
		</createBuffer>
		<createBufferSource public="1" set="method" line="26"><f a=""><d/></f></createBufferSource>
		<createChannelMerger public="1" set="method" line="27"><f a="?numberOfInputs" v="null">
	<x path="Int"/>
	<d/>
</f></createChannelMerger>
		<createChannelSplitter public="1" set="method" line="28"><f a="?numberOfOutputs" v="null">
	<x path="Int"/>
	<d/>
</f></createChannelSplitter>
		<createConvolver public="1" set="method" line="29"><f a=""><d/></f></createConvolver>
		<createDelay public="1" set="method" line="30"><f a="?maxDelayTime" v="null">
	<x path="Float"/>
	<d/>
</f></createDelay>
		<createDynamicsCompressor public="1" set="method" line="31"><f a=""><d/></f></createDynamicsCompressor>
		<createGain public="1" set="method" line="32"><f a=""><d/></f></createGain>
		<createMediaElementSource public="1" set="method" line="33"><f a="mediaElement">
	<d/>
	<d/>
</f></createMediaElementSource>
		<createMediaStreamSource public="1" set="method" line="34"><f a="mediaStream">
	<d/>
	<d/>
</f></createMediaStreamSource>
		<createOscillator public="1" set="method" line="35"><f a=""><d/></f></createOscillator>
		<createPanner public="1" set="method" line="36"><f a=""><d/></f></createPanner>
		<createScriptProcessor public="1" set="method" line="37"><f a="bufferSize:?numberOfInputChannels:?numberOfOutputChannels" v=":null:null">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></createScriptProcessor>
		<createWaveShaper public="1" set="method" line="38"><f a=""><d/></f></createWaveShaper>
		<createWaveTable public="1" set="method" line="39"><f a="real:imag">
	<d/>
	<d/>
	<d/>
</f></createWaveTable>
		<decodeAudioData public="1" set="method" line="40"><f a="audioData:successCallback:?errorCallback" v="::null">
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></decodeAudioData>
		<startRendering public="1" set="method" line="41"><f a=""><x path="Void"/></f></startRendering>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.audio.openal.AL" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/openal/AL.hx">
		<NONE public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></NONE>
		<FALSE public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></FALSE>
		<TRUE public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></TRUE>
		<SOURCE_RELATIVE public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></SOURCE_RELATIVE>
		<CONE_INNER_ANGLE public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></CONE_INNER_ANGLE>
		<CONE_OUTER_ANGLE public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></CONE_OUTER_ANGLE>
		<PITCH public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></PITCH>
		<POSITION public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></POSITION>
		<DIRECTION public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></DIRECTION>
		<VELOCITY public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></VELOCITY>
		<LOOPING public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></LOOPING>
		<BUFFER public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></BUFFER>
		<GAIN public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></GAIN>
		<MIN_GAIN public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></MIN_GAIN>
		<MAX_GAIN public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></MAX_GAIN>
		<ORIENTATION public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></ORIENTATION>
		<SOURCE_STATE public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></SOURCE_STATE>
		<INITIAL public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></INITIAL>
		<PLAYING public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></PLAYING>
		<PAUSED public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></PAUSED>
		<STOPPED public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></STOPPED>
		<BUFFERS_QUEUED public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></BUFFERS_QUEUED>
		<BUFFERS_PROCESSED public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></BUFFERS_PROCESSED>
		<REFERENCE_DISTANCE public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></REFERENCE_DISTANCE>
		<ROLLOFF_FACTOR public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></ROLLOFF_FACTOR>
		<CONE_OUTER_GAIN public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></CONE_OUTER_GAIN>
		<MAX_DISTANCE public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></MAX_DISTANCE>
		<SEC_OFFSET public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></SEC_OFFSET>
		<SAMPLE_OFFSET public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></SAMPLE_OFFSET>
		<BYTE_OFFSET public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></BYTE_OFFSET>
		<SOURCE_TYPE public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></SOURCE_TYPE>
		<STATIC public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></STATIC>
		<STREAMING public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></STREAMING>
		<UNDETERMINED public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></UNDETERMINED>
		<FORMAT_MONO8 public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></FORMAT_MONO8>
		<FORMAT_MONO16 public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></FORMAT_MONO16>
		<FORMAT_STEREO8 public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></FORMAT_STEREO8>
		<FORMAT_STEREO16 public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></FORMAT_STEREO16>
		<FREQUENCY public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></FREQUENCY>
		<BITS public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></BITS>
		<CHANNELS public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></CHANNELS>
		<SIZE public="1" get="inline" set="null" line="52" static="1"><x path="Int"/></SIZE>
		<NO_ERROR public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></NO_ERROR>
		<INVALID_NAME public="1" get="inline" set="null" line="54" static="1"><x path="Int"/></INVALID_NAME>
		<INVALID_ENUM public="1" get="inline" set="null" line="55" static="1"><x path="Int"/></INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" line="56" static="1"><x path="Int"/></INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" line="57" static="1"><x path="Int"/></INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" line="58" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<VENDOR public="1" get="inline" set="null" line="59" static="1"><x path="Int"/></VENDOR>
		<VERSION public="1" get="inline" set="null" line="60" static="1"><x path="Int"/></VERSION>
		<RENDERER public="1" get="inline" set="null" line="61" static="1"><x path="Int"/></RENDERER>
		<EXTENSIONS public="1" get="inline" set="null" line="62" static="1"><x path="Int"/></EXTENSIONS>
		<DOPPLER_FACTOR public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></DOPPLER_FACTOR>
		<SPEED_OF_SOUND public="1" get="inline" set="null" line="64" static="1"><x path="Int"/></SPEED_OF_SOUND>
		<DOPPLER_VELOCITY public="1" get="inline" set="null" line="65" static="1"><x path="Int"/></DOPPLER_VELOCITY>
		<DISTANCE_MODEL public="1" get="inline" set="null" line="66" static="1"><x path="Int"/></DISTANCE_MODEL>
		<INVERSE_DISTANCE public="1" get="inline" set="null" line="67" static="1"><x path="Int"/></INVERSE_DISTANCE>
		<INVERSE_DISTANCE_CLAMPED public="1" get="inline" set="null" line="68" static="1"><x path="Int"/></INVERSE_DISTANCE_CLAMPED>
		<LINEAR_DISTANCE public="1" get="inline" set="null" line="69" static="1"><x path="Int"/></LINEAR_DISTANCE>
		<LINEAR_DISTANCE_CLAMPED public="1" get="inline" set="null" line="70" static="1"><x path="Int"/></LINEAR_DISTANCE_CLAMPED>
		<EXPONENT_DISTANCE public="1" get="inline" set="null" line="71" static="1"><x path="Int"/></EXPONENT_DISTANCE>
		<EXPONENT_DISTANCE_CLAMPED public="1" get="inline" set="null" line="72" static="1"><x path="Int"/></EXPONENT_DISTANCE_CLAMPED>
		<bufferData public="1" set="method" line="75" static="1"><f a="buffer:format:data:size:freq">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<buffer3f public="1" set="method" line="86" static="1"><f a="buffer:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></buffer3f>
		<buffer3i public="1" set="method" line="95" static="1"><f a="buffer:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></buffer3i>
		<bufferf public="1" set="method" line="104" static="1"><f a="buffer:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bufferf>
		<bufferfv public="1" set="method" line="113" static="1"><f a="buffer:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></bufferfv>
		<bufferi public="1" set="method" line="122" static="1"><f a="buffer:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferi>
		<bufferiv public="1" set="method" line="131" static="1"><f a="buffer:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></bufferiv>
		<deleteBuffer public="1" set="method" line="140" static="1"><f a="buffer">
	<x path="Int"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteBuffers public="1" set="method" line="149" static="1"><f a="buffers">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></deleteBuffers>
		<deleteSource public="1" set="method" line="158" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></deleteSource>
		<deleteSources public="1" set="method" line="167" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></deleteSources>
		<disable public="1" set="method" line="176" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<distanceModel public="1" set="method" line="185" static="1"><f a="distanceModel">
	<x path="Int"/>
	<x path="Void"/>
</f></distanceModel>
		<dopplerFactor public="1" set="method" line="194" static="1"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></dopplerFactor>
		<dopplerVelocity public="1" set="method" line="203" static="1"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></dopplerVelocity>
		<enable public="1" set="method" line="212" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<genSource public="1" set="method" line="221" static="1"><f a=""><x path="Int"/></f></genSource>
		<genSources public="1" set="method" line="232" static="1"><f a="n">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></genSources>
		<genBuffer public="1" set="method" line="243" static="1"><f a=""><x path="Int"/></f></genBuffer>
		<genBuffers public="1" set="method" line="254" static="1"><f a="n">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></genBuffers>
		<getBoolean public="1" set="method" line="265" static="1"><f a="param">
	<x path="Int"/>
	<x path="Bool"/>
</f></getBoolean>
		<getBooleanv public="1" set="method" line="276" static="1"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Bool"/></c>
</f></getBooleanv>
		<getBuffer3f public="1" set="method" line="287" static="1"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getBuffer3f>
		<getBuffer3i public="1" set="method" line="298" static="1"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getBuffer3i>
		<getBufferf public="1" set="method" line="309" static="1"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getBufferf>
		<getBufferfv public="1" set="method" line="320" static="1"><f a="buffer:param:?count" v="::1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getBufferfv>
		<getBufferi public="1" set="method" line="331" static="1"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferi>
		<getBufferiv public="1" set="method" line="342" static="1"><f a="buffer:param:?count" v="::1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getBufferiv>
		<getDouble public="1" set="method" line="353" static="1"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getDoublev public="1" set="method" line="364" static="1"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getDoublev>
		<getEnumValue public="1" set="method" line="375" static="1"><f a="ename">
	<c path="String"/>
	<x path="Int"/>
</f></getEnumValue>
		<getError public="1" set="method" line="386" static="1"><f a=""><x path="Int"/></f></getError>
		<getErrorString public="1" set="method" line="397" static="1"><f a=""><c path="String"/></f></getErrorString>
		<getFloat public="1" set="method" line="413" static="1"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat>
		<getFloatv public="1" set="method" line="424" static="1"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getFloatv>
		<getInteger public="1" set="method" line="435" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getInteger>
		<getIntegerv public="1" set="method" line="446" static="1"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getIntegerv>
		<getListener3f public="1" set="method" line="457" static="1"><f a="param">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getListener3f>
		<getListener3i public="1" set="method" line="468" static="1"><f a="param">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getListener3i>
		<getListenerf public="1" set="method" line="479" static="1"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getListenerf>
		<getListenerfv public="1" set="method" line="490" static="1"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getListenerfv>
		<getListeneri public="1" set="method" line="501" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getListeneri>
		<getListeneriv public="1" set="method" line="512" static="1"><f a="param:?count" v=":1">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getListeneriv>
		<getProcAddress public="1" set="method" line="523" static="1"><f a="fname">
	<c path="String"/>
	<d/>
</f></getProcAddress>
		<getSource3f public="1" set="method" line="530" static="1"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getSource3f>
		<getSourcef public="1" set="method" line="541" static="1"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getSourcef>
		<getSource3i public="1" set="method" line="552" static="1"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getSource3i>
		<getSourcefv public="1" set="method" line="563" static="1"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getSourcefv>
		<getSourcei public="1" set="method" line="574" static="1"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getSourcei>
		<getSourceiv public="1" set="method" line="585" static="1"><f a="source:param:?count" v="::1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getSourceiv>
		<getString public="1" set="method" line="596" static="1"><f a="param">
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<isBuffer public="1" set="method" line="607" static="1"><f a="buffer">
	<x path="Int"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" set="method" line="618" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isExtensionPresent public="1" set="method" line="629" static="1"><f a="extname">
	<c path="String"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<isSource public="1" set="method" line="640" static="1"><f a="source">
	<x path="Int"/>
	<x path="Bool"/>
</f></isSource>
		<listener3f public="1" set="method" line="651" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></listener3f>
		<listener3i public="1" set="method" line="660" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listener3i>
		<listenerf public="1" set="method" line="669" static="1"><f a="param:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></listenerf>
		<listenerfv public="1" set="method" line="678" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></listenerfv>
		<listeneri public="1" set="method" line="687" static="1"><f a="param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listeneri>
		<listeneriv public="1" set="method" line="696" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></listeneriv>
		<source3f public="1" set="method" line="705" static="1"><f a="source:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></source3f>
		<source3i public="1" set="method" line="714" static="1"><f a="source:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></source3i>
		<sourcef public="1" set="method" line="723" static="1"><f a="source:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></sourcef>
		<sourcefv public="1" set="method" line="732" static="1"><f a="source:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></sourcefv>
		<sourcei public="1" set="method" line="741" static="1"><f a="source:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourcei>
		<sourceiv public="1" set="method" line="750" static="1"><f a="source:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceiv>
		<sourcePlay public="1" set="method" line="759" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourcePlay>
		<sourcePlayv public="1" set="method" line="768" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourcePlayv>
		<sourceStop public="1" set="method" line="777" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourceStop>
		<sourceStopv public="1" set="method" line="786" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceStopv>
		<sourceRewind public="1" set="method" line="795" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourceRewind>
		<sourceRewindv public="1" set="method" line="804" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceRewindv>
		<sourcePause public="1" set="method" line="813" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourcePause>
		<sourcePausev public="1" set="method" line="822" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourcePausev>
		<sourceQueueBuffer public="1" set="method" line="831" static="1"><f a="source:buffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourceQueueBuffer>
		<sourceQueueBuffers public="1" set="method" line="840" static="1"><f a="source:nb:buffers">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceQueueBuffers>
		<sourceUnqueueBuffer public="1" set="method" line="849" static="1"><f a="source">
	<x path="Int"/>
	<x path="Int"/>
</f></sourceUnqueueBuffer>
		<sourceUnqueueBuffers public="1" set="method" line="861" static="1"><f a="source:nb">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></sourceUnqueueBuffers>
		<speedOfSound public="1" set="method" line="872" static="1"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></speedOfSound>
	</class>
	<class path="lime.audio.openal.ALC" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/openal/ALC.hx">
		<FALSE public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></FALSE>
		<TRUE public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></TRUE>
		<FREQUENCY public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></FREQUENCY>
		<REFRESH public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></REFRESH>
		<SYNC public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></SYNC>
		<MONO_SOURCES public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></MONO_SOURCES>
		<STEREO_SOURCES public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></STEREO_SOURCES>
		<NO_ERROR public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></NO_ERROR>
		<INVALID_DEVICE public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></INVALID_DEVICE>
		<INVALID_CONTEXT public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></INVALID_CONTEXT>
		<INVALID_ENUM public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></INVALID_VALUE>
		<OUT_OF_MEMORY public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<ATTRIBUTES_SIZE public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></ATTRIBUTES_SIZE>
		<ALL_ATTRIBUTES public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></ALL_ATTRIBUTES>
		<DEFAULT_DEVICE_SPECIFIER public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></DEFAULT_DEVICE_SPECIFIER>
		<DEVICE_SPECIFIER public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></DEVICE_SPECIFIER>
		<EXTENSIONS public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></EXTENSIONS>
		<ENUMERATE_ALL_EXT public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></ENUMERATE_ALL_EXT>
		<DEFAULT_ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></DEFAULT_ALL_DEVICES_SPECIFIER>
		<ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></ALL_DEVICES_SPECIFIER>
		<closeDevice public="1" set="method" line="33" static="1"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Bool"/>
</f></closeDevice>
		<createContext public="1" set="method" line="44" static="1"><f a="device:?attrlist" v=":null">
	<x path="lime.audio.openal.ALDevice"/>
	<c path="Array"><x path="Int"/></c>
	<x path="lime.audio.openal.ALContext"/>
</f></createContext>
		<destroyContext public="1" set="method" line="61" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></destroyContext>
		<getContextsDevice public="1" set="method" line="70" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="lime.audio.openal.ALDevice"/>
</f></getContextsDevice>
		<getCurrentContext public="1" set="method" line="87" static="1"><f a=""><x path="lime.audio.openal.ALContext"/></f></getCurrentContext>
		<getError public="1" set="method" line="104" static="1"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
</f></getError>
		<getErrorString public="1" set="method" line="115" static="1"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<c path="String"/>
</f></getErrorString>
		<getIntegerv public="1" set="method" line="131" static="1"><f a="device:param:size">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getIntegerv>
		<getString public="1" set="method" line="142" static="1"><f a="device:param">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<makeContextCurrent public="1" set="method" line="153" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Bool"/>
</f></makeContextCurrent>
		<openDevice public="1" set="method" line="164" static="1"><f a="?deviceName" v="null">
	<c path="String"/>
	<x path="lime.audio.openal.ALDevice"/>
</f></openDevice>
		<processContext public="1" set="method" line="181" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></processContext>
		<suspendContext public="1" set="method" line="190" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></suspendContext>
	</class>
	<abstract path="lime.audio.openal.ALContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/openal/ALContext.hx">
		<from><icast><t path="Null"><x path="Float"/></t></icast></from>
		<this><t path="Null"><x path="Float"/></t></this>
		<to><icast><t path="Null"><x path="Float"/></t></icast></to>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
		<impl><class path="lime.audio.openal._ALContext.ALContext_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/openal/ALContext.hx" private="1" module="lime.audio.openal.ALContext">
	<_new set="method" line="11" static="1">
		<f a="handle">
			<x path="Float"/>
			<t path="Null"><x path="Float"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<meta>
		<m n=":allow"><e>'???'</e></m>
		<m n=":allow"><e>'???'</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.audio.openal._ALContext.ALContext_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/openal/ALContext.hx" private="1" module="lime.audio.openal.ALContext">
		<_new set="method" line="11" static="1">
			<f a="handle">
				<x path="Float"/>
				<t path="Null"><x path="Float"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
	</class>
	<abstract path="lime.audio.openal.ALDevice" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/openal/ALDevice.hx">
		<from><icast><t path="Null"><x path="Float"/></t></icast></from>
		<this><t path="Null"><x path="Float"/></t></this>
		<to><icast><t path="Null"><x path="Float"/></t></icast></to>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
		<impl><class path="lime.audio.openal._ALDevice.ALDevice_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/openal/ALDevice.hx" private="1" module="lime.audio.openal.ALDevice">
	<_new set="method" line="11" static="1">
		<f a="handle">
			<x path="Float"/>
			<t path="Null"><x path="Float"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<meta>
		<m n=":allow"><e>'???'</e></m>
		<m n=":allow"><e>'???'</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.audio.openal._ALDevice.ALDevice_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/audio/openal/ALDevice.hx" private="1" module="lime.audio.openal.ALDevice">
		<_new set="method" line="11" static="1">
			<f a="handle">
				<x path="Float"/>
				<t path="Null"><x path="Float"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
	</class>
	<class path="lime.graphics.CanvasRenderContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/CanvasRenderContext.hx">
		<backingStorePixelRatio public="1" set="null"><x path="Float"/></backingStorePixelRatio>
		<canvas public="1"><d/></canvas>
		<fillStyle public="1"><d/></fillStyle>
		<font public="1"><c path="String"/></font>
		<globalAlpha public="1"><x path="Float"/></globalAlpha>
		<globalCompositeOperation public="1"><c path="String"/></globalCompositeOperation>
		<imageSmoothingEnabled public="1"><x path="Bool"/></imageSmoothingEnabled>
		<lineCap public="1"><c path="String"/></lineCap>
		<lineDash public="1"><c path="Array"><d/></c></lineDash>
		<lineDashOffset public="1"><x path="Float"/></lineDashOffset>
		<lineJoin public="1"><c path="String"/></lineJoin>
		<lineWidth public="1"><x path="Float"/></lineWidth>
		<miterLimit public="1"><x path="Float"/></miterLimit>
		<shadowBlur public="1"><x path="Float"/></shadowBlur>
		<shadowColor public="1"><c path="String"/></shadowColor>
		<shadowOffsetX public="1"><x path="Float"/></shadowOffsetX>
		<shadowOffsetY public="1"><x path="Float"/></shadowOffsetY>
		<strokeStyle public="1"><d/></strokeStyle>
		<textAlign public="1"><c path="String"/></textAlign>
		<textBaseline public="1"><c path="String"/></textBaseline>
		<arc public="1" set="method" line="39"><f a="x:y:radius:startAngle:endAngle:anticlockwise">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></arc>
		<arcTo public="1" set="method" line="40"><f a="x1:y1:x2:y2:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></arcTo>
		<beginPath public="1" set="method" line="41"><f a=""><x path="Void"/></f></beginPath>
		<bezierCurveTo public="1" set="method" line="42"><f a="cp1x:cp1y:cp2x:cp2y:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bezierCurveTo>
		<clearRect public="1" set="method" line="43"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearRect>
		<clearShadow public="1" set="method" line="44"><f a=""><x path="Void"/></f></clearShadow>
		<clip public="1" set="method" line="45"><f a=""><x path="Void"/></f></clip>
		<closePath public="1" set="method" line="46"><f a=""><x path="Void"/></f></closePath>
		<createDynamicImageData public="1" set="method" line="48">
			<f a="sw:sh">
				<x path="Float"/>
				<x path="Float"/>
				<d/>
			</f>
			<overloads><createDynamicImageData public="1" set="method"><f a="dynamicImageData">
	<d/>
	<d/>
</f></createDynamicImageData></overloads>
		</createDynamicImageData>
		<createLinearGradient public="1" set="method" line="49"><f a="x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
</f></createLinearGradient>
		<createPattern public="1" set="method" line="51">
			<f a="image:repetitionType">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<overloads><createPattern public="1" set="method"><f a="canvas:repetitionType">
	<d/>
	<c path="String"/>
	<d/>
</f></createPattern></overloads>
		</createPattern>
		<createRadialGradient public="1" set="method" line="52"><f a="x0:y0:r0:x1:y1:r1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
</f></createRadialGradient>
		<drawImage public="1" set="method" line="61"><f a="element:sx:sy:?sw:?sh:?dx:?dy:?dw:?dh" v=":::null:null:null:null:null:null">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawImage>
		<drawImageFromRect public="1" set="method" line="62"><f a="image:?sx:?sy:?sw:?sh:?dx:?dy:?dw:?dh:?compositeOperation" v=":null:null:null:null:null:null:null:null:null">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></drawImageFromRect>
		<fill public="1" set="method" line="63"><f a=""><x path="Void"/></f></fill>
		<fillRect public="1" set="method" line="64"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<fillText public="1" set="method" line="65"><f a="text:x:y:?maxWidth" v=":::null">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillText>
		<getDynamicImageData public="1" set="method" line="66"><f a="sx:sy:sw:sh">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
</f></getDynamicImageData>
		<getDynamicImageDataHD public="1" set="method" line="67"><f a="sx:sy:sw:sh">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
</f></getDynamicImageDataHD>
		<getLineDash public="1" set="method" line="68"><f a=""><c path="Array"><x path="Float"/></c></f></getLineDash>
		<isPointInPath public="1" set="method" line="69"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isPointInPath>
		<lineTo public="1" set="method" line="70"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<measureText public="1" set="method" line="71"><f a="text">
	<c path="String"/>
	<d/>
</f></measureText>
		<moveTo public="1" set="method" line="72"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<putDynamicImageData public="1" set="method" line="74">
			<f a="dynamicImageData:dx:dy:dirtyX:dirtyY:dirtyWidth:dirtyHeight">
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads><putDynamicImageData public="1" set="method"><f a="dynamicImageData:dx:dy">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putDynamicImageData></overloads>
		</putDynamicImageData>
		<putDynamicImageDataHD public="1" set="method" line="76">
			<f a="dynamicImageData:dx:dy:dirtyX:dirtyY:dirtyWidth:dirtyHeight">
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads><putDynamicImageDataHD public="1" set="method"><f a="dynamicImageData:dx:dy">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putDynamicImageDataHD></overloads>
		</putDynamicImageDataHD>
		<quadraticCurveTo public="1" set="method" line="77"><f a="cpx:cpy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadraticCurveTo>
		<rect public="1" set="method" line="78"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rect>
		<restore public="1" set="method" line="79"><f a=""><x path="Void"/></f></restore>
		<rotate public="1" set="method" line="80"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<save public="1" set="method" line="81"><f a=""><x path="Void"/></f></save>
		<scale public="1" set="method" line="82"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setAlpha public="1" set="method" line="83"><f a="alpha">
	<x path="Float"/>
	<x path="Void"/>
</f></setAlpha>
		<setCompositeOperation public="1" set="method" line="84"><f a="compositeOperation">
	<c path="String"/>
	<x path="Void"/>
</f></setCompositeOperation>
		<setFillColor public="1" set="method" line="88">
			<f a="c:m:y:k:a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads>
				<setFillColor public="1" set="method"><f a="color:?alpha">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFillColor>
				<setFillColor public="1" set="method"><f a="grayLevel:?alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFillColor>
				<setFillColor public="1" set="method"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFillColor>
			</overloads>
		</setFillColor>
		<setLineCap public="1" set="method" line="89"><f a="cap">
	<c path="String"/>
	<x path="Void"/>
</f></setLineCap>
		<setLineDash public="1" set="method" line="90"><f a="dash">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setLineDash>
		<setLineJoin public="1" set="method" line="91"><f a="join">
	<c path="String"/>
	<x path="Void"/>
</f></setLineJoin>
		<setLineWidth public="1" set="method" line="92"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></setLineWidth>
		<setMiterLimit public="1" set="method" line="93"><f a="limit">
	<x path="Float"/>
	<x path="Void"/>
</f></setMiterLimit>
		<setShadow public="1" set="method" line="97">
			<f a="width:height:blur:c:m:y:k:a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads>
				<setShadow public="1" set="method"><f a="width:height:blur:?color:?alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setShadow>
				<setShadow public="1" set="method"><f a="width:height:blur:grayLevel:?alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setShadow>
				<setShadow public="1" set="method"><f a="width:height:blur:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setShadow>
			</overloads>
		</setShadow>
		<setStrokeColor public="1" set="method" line="101">
			<f a="c:m:y:k:a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads>
				<setStrokeColor public="1" set="method"><f a="color:?alpha">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setStrokeColor>
				<setStrokeColor public="1" set="method"><f a="grayLevel:?alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setStrokeColor>
				<setStrokeColor public="1" set="method"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setStrokeColor>
			</overloads>
		</setStrokeColor>
		<setTransform public="1" set="method" line="102"><f a="m11:m12:m21:m22:dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTransform>
		<stroke public="1" set="method" line="103"><f a=""><x path="Void"/></f></stroke>
		<strokeRect public="1" set="method" line="104"><f a="x:y:width:height:?lineWidth" v="::::null">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></strokeRect>
		<strokeText public="1" set="method" line="105"><f a="text:x:y:?maxWidth" v=":::null">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></strokeText>
		<transform public="1" set="method" line="106"><f a="m11:m12:m21:m22:dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></transform>
		<translate public="1" set="method" line="107"><f a="tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.graphics.DOMRenderContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/DOMRenderContext.hx">
		<accessKey public="1"><c path="String"/></accessKey>
		<align public="1"><c path="String"/></align>
		<attributes public="1" set="null"><d/></attributes>
		<baseURI public="1" set="null"><c path="String"/></baseURI>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<childNodes public="1" set="null"><d/></childNodes>
		<children public="1" set="null"><d/></children>
		<classList public="1" set="null"><d/></classList>
		<className public="1"><c path="String"/></className>
		<clientHeight public="1" set="null"><x path="Int"/></clientHeight>
		<clientLeft public="1" set="null"><x path="Int"/></clientLeft>
		<clientTop public="1" set="null"><x path="Int"/></clientTop>
		<clientWidth public="1" set="null"><x path="Int"/></clientWidth>
		<contentEditable public="1"><c path="String"/></contentEditable>
		<dataset public="1" set="null"><d><c path="String"/></d></dataset>
		<dir public="1"><c path="String"/></dir>
		<draggable public="1"><x path="Bool"/></draggable>
		<dropzone public="1"><c path="String"/></dropzone>
		<firstChild public="1" set="null"><d/></firstChild>
		<firstElementChild public="1" set="null"><d/></firstElementChild>
		<hidden public="1"><x path="Bool"/></hidden>
		<id public="1"><c path="String"/></id>
		<innerHTML public="1"><c path="String"/></innerHTML>
		<innerText public="1"><c path="String"/></innerText>
		<isContentEditable public="1" set="null"><x path="Bool"/></isContentEditable>
		<lang public="1"><c path="String"/></lang>
		<lastChild public="1" set="null"><d/></lastChild>
		<lastElementChild public="1" set="null"><d/></lastElementChild>
		<localName public="1" set="null"><c path="String"/></localName>
		<namespaceURI public="1" set="null"><c path="String"/></namespaceURI>
		<nextElementSibling public="1" set="null"><d/></nextElementSibling>
		<nextSibling public="1" set="null"><d/></nextSibling>
		<nodeName public="1" set="null"><c path="String"/></nodeName>
		<nodeType public="1" set="null"><x path="Int"/></nodeType>
		<nodeValue public="1"><c path="String"/></nodeValue>
		<offsetHeight public="1" set="null"><x path="Int"/></offsetHeight>
		<offsetLeft public="1" set="null"><x path="Int"/></offsetLeft>
		<offsetParent public="1" set="null"><d/></offsetParent>
		<offsetTop public="1" set="null"><x path="Int"/></offsetTop>
		<offsetWidth public="1" set="null"><x path="Int"/></offsetWidth>
		<onabort public="1"><d/></onabort>
		<onbeforecopy public="1"><d/></onbeforecopy>
		<onbeforecut public="1"><d/></onbeforecut>
		<onbeforepaste public="1"><d/></onbeforepaste>
		<onblur public="1"><d/></onblur>
		<onchange public="1"><d/></onchange>
		<onclick public="1"><d/></onclick>
		<oncontextmenu public="1"><d/></oncontextmenu>
		<oncopy public="1"><d/></oncopy>
		<oncut public="1"><d/></oncut>
		<ondblclick public="1"><d/></ondblclick>
		<ondrag public="1"><d/></ondrag>
		<ondragend public="1"><d/></ondragend>
		<ondragenter public="1"><d/></ondragenter>
		<ondragleave public="1"><d/></ondragleave>
		<ondragover public="1"><d/></ondragover>
		<ondragstart public="1"><d/></ondragstart>
		<ondrop public="1"><d/></ondrop>
		<onerror public="1"><d/></onerror>
		<onfocus public="1"><d/></onfocus>
		<onfullscreenchange public="1"><d/></onfullscreenchange>
		<onfullscreenerror public="1"><d/></onfullscreenerror>
		<oninput public="1"><d/></oninput>
		<oninvalid public="1"><d/></oninvalid>
		<onkeydown public="1"><d/></onkeydown>
		<onkeypress public="1"><d/></onkeypress>
		<onkeyup public="1"><d/></onkeyup>
		<onload public="1"><d/></onload>
		<onmousedown public="1"><d/></onmousedown>
		<onmousemove public="1"><d/></onmousemove>
		<onmouseout public="1"><d/></onmouseout>
		<onmouseover public="1"><d/></onmouseover>
		<onmouseup public="1"><d/></onmouseup>
		<onmousewheel public="1"><d/></onmousewheel>
		<onpaste public="1"><d/></onpaste>
		<onreset public="1"><d/></onreset>
		<onscroll public="1"><d/></onscroll>
		<onsearch public="1"><d/></onsearch>
		<onselect public="1"><d/></onselect>
		<onselectstart public="1"><d/></onselectstart>
		<onsubmit public="1"><d/></onsubmit>
		<ontouchcancel public="1"><d/></ontouchcancel>
		<ontouchend public="1"><d/></ontouchend>
		<ontouchmove public="1"><d/></ontouchmove>
		<ontouchstart public="1"><d/></ontouchstart>
		<outerHTML public="1"><c path="String"/></outerHTML>
		<outerText public="1"><c path="String"/></outerText>
		<ownerDocument public="1" set="null"><d/></ownerDocument>
		<parentElement public="1" set="null"><d/></parentElement>
		<parentNode public="1" set="null"><d/></parentNode>
		<prefix public="1"><c path="String"/></prefix>
		<previousElementSibling public="1" set="null"><d/></previousElementSibling>
		<previousSibling public="1" set="null"><d/></previousSibling>
		<pseudo public="1"><c path="String"/></pseudo>
		<scrollHeight public="1" set="null"><x path="Int"/></scrollHeight>
		<scrollLeft public="1"><x path="Int"/></scrollLeft>
		<scrollTop public="1"><x path="Int"/></scrollTop>
		<scrollWidth public="1" set="null"><x path="Int"/></scrollWidth>
		<spellcheck public="1"><x path="Bool"/></spellcheck>
		<style public="1" set="null"><d/></style>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<tagName public="1" set="null"><c path="String"/></tagName>
		<textContent public="1"><c path="String"/></textContent>
		<title public="1"><c path="String"/></title>
		<translate public="1"><x path="Bool"/></translate>
		<addEventListener public="1" set="method" line="124"><f a="type:listener:?useCapture" v="::null">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<appendChild public="1" set="method" line="125"><f a="newChild">
	<d/>
	<d/>
</f></appendChild>
		<blur public="1" set="method" line="126"><f a=""><x path="Void"/></f></blur>
		<click public="1" set="method" line="127"><f a=""><x path="Void"/></f></click>
		<cloneNode public="1" set="method" line="128"><f a="deep">
	<x path="Bool"/>
	<d/>
</f></cloneNode>
		<compareDocumentPosition public="1" set="method" line="129"><f a="other">
	<d/>
	<x path="Int"/>
</f></compareDocumentPosition>
		<contains public="1" set="method" line="130"><f a="other">
	<d/>
	<x path="Bool"/>
</f></contains>
		<dispatchEvent public="1" set="method" line="131"><f a="event">
	<d/>
	<x path="Bool"/>
</f></dispatchEvent>
		<focus public="1" set="method" line="132"><f a=""><x path="Void"/></f></focus>
		<getAttribute public="1" set="method" line="133"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
		<getAttributeNS public="1" set="method" line="134"><f a="?namespaceURI:localName" v="null:">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getAttributeNS>
		<getAttributeNode public="1" set="method" line="135"><f a="name">
	<c path="String"/>
	<d/>
</f></getAttributeNode>
		<getAttributeNodeNS public="1" set="method" line="136"><f a="?namespaceURI:localName" v="null:">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getAttributeNodeNS>
		<getBoundingClientRect public="1" set="method" line="137"><f a=""><d/></f></getBoundingClientRect>
		<getClientRects public="1" set="method" line="138"><f a=""><d/></f></getClientRects>
		<getElementsByClassName public="1" set="method" line="139"><f a="name">
	<c path="String"/>
	<d/>
</f></getElementsByClassName>
		<getElementsByTagName public="1" set="method" line="140"><f a="name">
	<c path="String"/>
	<d/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method" line="141"><f a="?namespaceURI:localName" v="null:">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getElementsByTagNameNS>
		<hasAttribute public="1" set="method" line="142"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttribute>
		<hasAttributeNS public="1" set="method" line="143"><f a="?namespaceURI:localName" v="null:">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttributeNS>
		<hasAttributes public="1" set="method" line="144"><f a=""><x path="Bool"/></f></hasAttributes>
		<hasChildNodes public="1" set="method" line="145"><f a=""><x path="Bool"/></f></hasChildNodes>
		<insertAdjacentElement public="1" set="method" line="146"><f a="where:element">
	<c path="String"/>
	<d/>
	<d/>
</f></insertAdjacentElement>
		<insertAdjacentHTML public="1" set="method" line="147"><f a="where:html">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></insertAdjacentHTML>
		<insertAdjacentText public="1" set="method" line="148"><f a="where:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></insertAdjacentText>
		<insertBefore public="1" set="method" line="149"><f a="newChild:refChild">
	<d/>
	<d/>
	<d/>
</f></insertBefore>
		<isDefaultNamespace public="1" set="method" line="150"><f a="?namespaceURI" v="null">
	<c path="String"/>
	<x path="Bool"/>
</f></isDefaultNamespace>
		<isEqualNode public="1" set="method" line="151"><f a="other">
	<d/>
	<x path="Bool"/>
</f></isEqualNode>
		<isSameNode public="1" set="method" line="152"><f a="other">
	<d/>
	<x path="Bool"/>
</f></isSameNode>
		<isSupported public="1" set="method" line="153"><f a="feature:?version" v=":null">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isSupported>
		<lookupNamespaceURI public="1" set="method" line="154"><f a="?prefix" v="null">
	<c path="String"/>
	<c path="String"/>
</f></lookupNamespaceURI>
		<lookupPrefix public="1" set="method" line="155"><f a="?namespaceURI" v="null">
	<c path="String"/>
	<c path="String"/>
</f></lookupPrefix>
		<matchesSelector public="1" set="method" line="156"><f a="selectors">
	<c path="String"/>
	<x path="Bool"/>
</f></matchesSelector>
		<normalize public="1" set="method" line="157"><f a=""><x path="Void"/></f></normalize>
		<querySelector public="1" set="method" line="158"><f a="selectors">
	<c path="String"/>
	<d/>
</f></querySelector>
		<querySelectorAll public="1" set="method" line="159"><f a="selectors">
	<c path="String"/>
	<d/>
</f></querySelectorAll>
		<remove public="1" set="method" line="160"><f a=""><x path="Void"/></f></remove>
		<removeAttribute public="1" set="method" line="161"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeAttribute>
		<removeAttributeNS public="1" set="method" line="162"><f a="namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></removeAttributeNS>
		<removeAttributeNode public="1" set="method" line="163"><f a="oldAttr">
	<d/>
	<d/>
</f></removeAttributeNode>
		<removeChild public="1" set="method" line="164"><f a="oldChild">
	<d/>
	<d/>
</f></removeChild>
		<removeEventListener public="1" set="method" line="165"><f a="type:listener:?useCapture" v="::null">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<replaceChild public="1" set="method" line="166"><f a="newChild:oldChild">
	<d/>
	<d/>
	<d/>
</f></replaceChild>
		<requestFullScreen public="1" set="method" line="167"><f a="flags">
	<x path="Int"/>
	<x path="Void"/>
</f></requestFullScreen>
		<requestFullscreen public="1" set="method" line="168"><f a=""><x path="Void"/></f></requestFullscreen>
		<requestPointerLock public="1" set="method" line="169"><f a=""><x path="Void"/></f></requestPointerLock>
		<scrollByLines public="1" set="method" line="170"><f a="lines">
	<x path="Int"/>
	<x path="Void"/>
</f></scrollByLines>
		<scrollByPages public="1" set="method" line="171"><f a="pages">
	<x path="Int"/>
	<x path="Void"/>
</f></scrollByPages>
		<scrollIntoView public="1" set="method" line="172"><f a="?alignWithTop" v="null">
	<x path="Bool"/>
	<x path="Void"/>
</f></scrollIntoView>
		<scrollIntoViewIfNeeded public="1" set="method" line="173"><f a="?centerIfNeeded" v="null">
	<x path="Bool"/>
	<x path="Void"/>
</f></scrollIntoViewIfNeeded>
		<setAttribute public="1" set="method" line="174"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setAttribute>
		<setAttributeNS public="1" set="method" line="175"><f a="?namespaceURI:qualifiedName:value" v="null::">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setAttributeNS>
		<setAttributeNode public="1" set="method" line="176"><f a="newAttr">
	<d/>
	<d/>
</f></setAttributeNode>
		<setAttributeNodeNS public="1" set="method" line="177"><f a="newAttr">
	<d/>
	<d/>
</f></setAttributeNodeNS>
		<new public="1" set="method" line="117"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.graphics.FlashRenderContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/FlashRenderContext.hx">
		<accessibilityImplementation public="1"><d/></accessibilityImplementation>
		<accessibilityProperties public="1"><d/></accessibilityProperties>
		<alpha public="1"><x path="Float"/></alpha>
		<blendMode public="1"><d/></blendMode>
		<blendShader public="1" get="null"><d/></blendShader>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<cacheAsBitmap public="1"><x path="Bool"/></cacheAsBitmap>
		<contextMenu public="1"><d/></contextMenu>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<dropTarget public="1" set="null"><d/></dropTarget>
		<filters public="1"><c path="Array"><d/></c></filters>
		<focusRect public="1"><d/></focusRect>
		<graphics public="1" set="null"><d/></graphics>
		<height public="1"><x path="Float"/></height>
		<hitArea public="1"><d/></hitArea>
		<loaderInfo public="1" set="null"><d/></loaderInfo>
		<mask public="1"><d/></mask>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<mouseX public="1" set="null"><x path="Float"/></mouseX>
		<mouseY public="1" set="null"><x path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<needsSoftKeyboard public="1"><x path="Bool"/></needsSoftKeyboard>
		<numChildren public="1" set="null"><x path="Int"/></numChildren>
		<opaqueBackground public="1"><t path="Null"><x path="UInt"/></t></opaqueBackground>
		<parent public="1" set="null"><d/></parent>
		<root public="1" set="null"><d/></root>
		<rotation public="1"><x path="Float"/></rotation>
		<rotationX public="1"><x path="Float"/></rotationX>
		<rotationY public="1"><x path="Float"/></rotationY>
		<rotationZ public="1"><x path="Float"/></rotationZ>
		<scale9Grid public="1"><d/></scale9Grid>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<scaleZ public="1"><x path="Float"/></scaleZ>
		<scrollRect public="1"><d/></scrollRect>
		<softKeyboardInputAreaOfInterest public="1"><d/></softKeyboardInputAreaOfInterest>
		<soundTransform public="1"><d/></soundTransform>
		<stage public="1" set="null"><d/></stage>
		<tabChildren public="1"><x path="Bool"/></tabChildren>
		<tabEnabled public="1"><x path="Bool"/></tabEnabled>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<textSnapshot public="1" set="null"><d/></textSnapshot>
		<transform public="1"><d/></transform>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<visible public="1"><x path="Bool"/></visible>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<addChild public="1" set="method" line="69"><f a="child">
	<d/>
	<d/>
</f></addChild>
		<addChildAt public="1" set="method" line="70"><f a="child:index">
	<d/>
	<x path="Int"/>
	<d/>
</f></addChildAt>
		<addEventListener public="1" set="method" line="71"><f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<areInaccessibleObjectsUnderPoint public="1" set="method" line="72"><f a="point">
	<d/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method" line="73"><f a="child">
	<d/>
	<x path="Bool"/>
</f></contains>
		<dispatchEvent public="1" set="method" line="74"><f a="event">
	<d/>
	<x path="Bool"/>
</f></dispatchEvent>
		<getBounds public="1" set="method" line="75"><f a="targetCoordinateSpace">
	<d/>
	<d/>
</f></getBounds>
		<getChildAt public="1" set="method" line="76"><f a="index">
	<x path="Int"/>
	<d/>
</f></getChildAt>
		<getChildByName public="1" set="method" line="77"><f a="name">
	<c path="String"/>
	<d/>
</f></getChildByName>
		<getChildIndex public="1" set="method" line="78"><f a="child">
	<d/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method" line="79"><f a="point">
	<d/>
	<c path="Array"><d/></c>
</f></getObjectsUnderPoint>
		<getRect public="1" set="method" line="80"><f a="targetCoordinateSpace">
	<d/>
	<d/>
</f></getRect>
		<globalToLocal public="1" set="method" line="81"><f a="point">
	<d/>
	<d/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method" line="82"><f a="point">
	<d/>
	<d/>
</f></globalToLocal3D>
		<hasEventListener public="1" set="method" line="83"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<hitTestObject public="1" set="method" line="84"><f a="obj">
	<d/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method" line="85"><f a="x:y:?shapeFlag" v="::false">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></hitTestPoint>
		<local3DToGlobal public="1" set="method" line="86"><f a="point3d">
	<d/>
	<d/>
</f></local3DToGlobal>
		<localToGlobal public="1" set="method" line="87"><f a="point">
	<d/>
	<d/>
</f></localToGlobal>
		<removeChild public="1" set="method" line="88"><f a="child">
	<d/>
	<d/>
</f></removeChild>
		<removeChildAt public="1" set="method" line="89"><f a="index">
	<x path="Int"/>
	<d/>
</f></removeChildAt>
		<removeChildren public="1" set="method" line="90"><f a="?beginIndex:?endIndex" v="0:2147483647">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></removeChildren>
		<removeEventListener public="1" set="method" line="91"><f a="type:listener:?useCapture" v="::false">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<requestSoftKeyboard public="1" set="method" line="92"><f a=""><x path="Bool"/></f></requestSoftKeyboard>
		<setChildIndex public="1" set="method" line="93"><f a="child:index">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<startDrag public="1" set="method" line="94"><f a="?lockCenter:?bounds" v="false:null">
	<x path="Bool"/>
	<d/>
	<x path="Void"/>
</f></startDrag>
		<startTouchDrag public="1" set="method" line="95"><f a="touchPointID:?lockCenter:?bounds" v=":false:null">
	<x path="Int"/>
	<x path="Bool"/>
	<d/>
	<x path="Void"/>
</f></startTouchDrag>
		<stopAllMovieClips public="1" set="method" line="96"><f a=""><x path="Void"/></f></stopAllMovieClips>
		<stopDrag public="1" set="method" line="97"><f a=""><x path="Void"/></f></stopDrag>
		<stopTouchDrag public="1" set="method" line="98"><f a="touchPointID">
	<x path="Int"/>
	<x path="Void"/>
</f></stopTouchDrag>
		<swapChildren public="1" set="method" line="99"><f a="child1:child2">
	<d/>
	<d/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method" line="100"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<toString public="1" set="method" line="101"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method" line="102"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method" line="62"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.graphics.Font" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Font.hx">
		<fromBytes public="1" set="method" line="227" static="1"><f a="bytes">
	<c path="lime.utils.ByteArray"/>
	<c path="lime.graphics.Font"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="236" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.graphics.Font"/>
</f></fromFile>
		<lime_font_get_family_name line="301" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></lime_font_get_family_name>
		<lime_font_load line="302" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></lime_font_load>
		<lime_font_load_glyphs line="303" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<c path="String"/>
	<unknown/>
</f></lime_font_load_glyphs>
		<lime_font_load_range line="304" static="1"><f a=":::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_font_load_range>
		<lime_font_create_image line="305" static="1"><f a="">
	<d/>
	<a>
		<image set="null"><a>
	<width set="null"><x path="Int"/></width>
	<height set="null"><x path="Int"/></height>
	<data set="null"><unknown/></data>
	<bpp set="null"><x path="Int"/></bpp>
</a></image>
		<glyphs set="null"><unknown/></glyphs>
	</a>
</f></lime_font_create_image>
		<lime_font_outline_decompose line="306" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<t path="lime.graphics.NativeFontData"/>
</f></lime_font_outline_decompose>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<image public="1"><c path="lime.graphics.Image"/></image>
		<glyphs public="1"><x path="Map">
	<x path="Int"/>
	<x path="Map">
		<x path="Int"/>
		<c path="lime.graphics.GlyphRect"/>
	</x>
</x></glyphs>
		<__fontPath>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fontPath>
		<__handle>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<createImage public="1" set="method" line="36"><f a=""><c path="lime.graphics.ImageBuffer"/></f></createImage>
		<decompose public="1" set="method" line="212"><f a=""><t path="lime.graphics.NativeFontData"/></f></decompose>
		<loadRange public="1" set="method" line="245"><f a="size:start:end">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></loadRange>
		<loadGlyphs public="1" set="method" line="260"><f a="size:?glyphs" v=":null">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></loadGlyphs>
		<__fromFile set="method" line="281">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromFile>
		<new public="1" set="method" line="28"><f a="?fontName" v="null">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":autoBuild"><e>'???'</e></m></meta>
	</class>
	<class path="lime.graphics.GlyphRect" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Font.hx" module="lime.graphics.Font">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<xOffset public="1"><x path="Int"/></xOffset>
		<yOffset public="1"><x path="Int"/></yOffset>
		<new public="1" set="method" line="324"><f a="x:y:width:height:?xOffset:?yOffset" v="::::0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.graphics.NativeFontData" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Font.hx" module="lime.graphics.Font"><a>
	<style_name><c path="String"/></style_name>
	<num_glyphs><x path="Int"/></num_glyphs>
	<kerning><c path="Array"><t path="lime.graphics.NativeKerningData"/></c></kerning>
	<is_italic><x path="Bool"/></is_italic>
	<is_fixed_width><x path="Bool"/></is_fixed_width>
	<is_bold><x path="Bool"/></is_bold>
	<height><x path="Int"/></height>
	<has_kerning><x path="Bool"/></has_kerning>
	<has_glyph_names><x path="Bool"/></has_glyph_names>
	<glyphs><c path="Array"><t path="lime.graphics.NativeGlyphData"/></c></glyphs>
	<family_name><c path="String"/></family_name>
	<em_size><x path="Int"/></em_size>
	<descend><x path="Int"/></descend>
	<ascend><x path="Int"/></ascend>
</a></typedef>
	<typedef path="lime.graphics.NativeGlyphData" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Font.hx" module="lime.graphics.Font"><a>
	<points><c path="Array"><x path="Int"/></c></points>
	<min_y><x path="Int"/></min_y>
	<min_x><x path="Int"/></min_x>
	<max_y><x path="Int"/></max_y>
	<max_x><x path="Int"/></max_x>
	<char_code><x path="Int"/></char_code>
	<advance><x path="Int"/></advance>
</a></typedef>
	<typedef path="lime.graphics.NativeKerningData" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Font.hx" module="lime.graphics.Font"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<right_glyph><x path="Int"/></right_glyph>
	<left_glyph><x path="Int"/></left_glyph>
</a></typedef>
	<class path="lime.graphics.GLRenderContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/GLRenderContext.hx">
		<DEPTH_BUFFER_BIT public="1"><x path="Int"/></DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1"><x path="Int"/></STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1"><x path="Int"/></COLOR_BUFFER_BIT>
		<POINTS public="1"><x path="Int"/></POINTS>
		<LINES public="1"><x path="Int"/></LINES>
		<LINE_LOOP public="1"><x path="Int"/></LINE_LOOP>
		<LINE_STRIP public="1"><x path="Int"/></LINE_STRIP>
		<TRIANGLES public="1"><x path="Int"/></TRIANGLES>
		<TRIANGLE_STRIP public="1"><x path="Int"/></TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1"><x path="Int"/></TRIANGLE_FAN>
		<ZERO public="1"><x path="Int"/></ZERO>
		<ONE public="1"><x path="Int"/></ONE>
		<SRC_COLOR public="1"><x path="Int"/></SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1"><x path="Int"/></ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1"><x path="Int"/></SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1"><x path="Int"/></ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1"><x path="Int"/></DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1"><x path="Int"/></ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1"><x path="Int"/></DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1"><x path="Int"/></ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1"><x path="Int"/></SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1"><x path="Int"/></FUNC_ADD>
		<BLEND_EQUATION public="1"><x path="Int"/></BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1"><x path="Int"/></BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1"><x path="Int"/></BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1"><x path="Int"/></FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1"><x path="Int"/></FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1"><x path="Int"/></BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1"><x path="Int"/></BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1"><x path="Int"/></BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1"><x path="Int"/></BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1"><x path="Int"/></CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1"><x path="Int"/></ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1"><x path="Int"/></CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1"><x path="Int"/></ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1"><x path="Int"/></BLEND_COLOR>
		<ARRAY_BUFFER public="1"><x path="Int"/></ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1"><x path="Int"/></ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1"><x path="Int"/></STREAM_DRAW>
		<STATIC_DRAW public="1"><x path="Int"/></STATIC_DRAW>
		<DYNAMIC_DRAW public="1"><x path="Int"/></DYNAMIC_DRAW>
		<BUFFER_SIZE public="1"><x path="Int"/></BUFFER_SIZE>
		<BUFFER_USAGE public="1"><x path="Int"/></BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1"><x path="Int"/></CURRENT_VERTEX_ATTRIB>
		<FRONT public="1"><x path="Int"/></FRONT>
		<BACK public="1"><x path="Int"/></BACK>
		<FRONT_AND_BACK public="1"><x path="Int"/></FRONT_AND_BACK>
		<CULL_FACE public="1"><x path="Int"/></CULL_FACE>
		<BLEND public="1"><x path="Int"/></BLEND>
		<DITHER public="1"><x path="Int"/></DITHER>
		<STENCIL_TEST public="1"><x path="Int"/></STENCIL_TEST>
		<DEPTH_TEST public="1"><x path="Int"/></DEPTH_TEST>
		<SCISSOR_TEST public="1"><x path="Int"/></SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1"><x path="Int"/></POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1"><x path="Int"/></SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1"><x path="Int"/></SAMPLE_COVERAGE>
		<NO_ERROR public="1"><x path="Int"/></NO_ERROR>
		<INVALID_ENUM public="1"><x path="Int"/></INVALID_ENUM>
		<INVALID_VALUE public="1"><x path="Int"/></INVALID_VALUE>
		<INVALID_OPERATION public="1"><x path="Int"/></INVALID_OPERATION>
		<OUT_OF_MEMORY public="1"><x path="Int"/></OUT_OF_MEMORY>
		<CW public="1"><x path="Int"/></CW>
		<CCW public="1"><x path="Int"/></CCW>
		<LINE_WIDTH public="1"><x path="Int"/></LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1"><x path="Int"/></ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1"><x path="Int"/></ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1"><x path="Int"/></CULL_FACE_MODE>
		<FRONT_FACE public="1"><x path="Int"/></FRONT_FACE>
		<DEPTH_RANGE public="1"><x path="Int"/></DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1"><x path="Int"/></DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1"><x path="Int"/></DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1"><x path="Int"/></DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1"><x path="Int"/></STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1"><x path="Int"/></STENCIL_FUNC>
		<STENCIL_FAIL public="1"><x path="Int"/></STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1"><x path="Int"/></STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1"><x path="Int"/></STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1"><x path="Int"/></STENCIL_REF>
		<STENCIL_VALUE_MASK public="1"><x path="Int"/></STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1"><x path="Int"/></STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1"><x path="Int"/></STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1"><x path="Int"/></STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1"><x path="Int"/></STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1"><x path="Int"/></STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1"><x path="Int"/></STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1"><x path="Int"/></VIEWPORT>
		<SCISSOR_BOX public="1"><x path="Int"/></SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1"><x path="Int"/></COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1"><x path="Int"/></COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1"><x path="Int"/></UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1"><x path="Int"/></PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1"><x path="Int"/></MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1"><x path="Int"/></MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1"><x path="Int"/></SUBPIXEL_BITS>
		<RED_BITS public="1"><x path="Int"/></RED_BITS>
		<GREEN_BITS public="1"><x path="Int"/></GREEN_BITS>
		<BLUE_BITS public="1"><x path="Int"/></BLUE_BITS>
		<ALPHA_BITS public="1"><x path="Int"/></ALPHA_BITS>
		<DEPTH_BITS public="1"><x path="Int"/></DEPTH_BITS>
		<STENCIL_BITS public="1"><x path="Int"/></STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1"><x path="Int"/></POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1"><x path="Int"/></POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1"><x path="Int"/></TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1"><x path="Int"/></SAMPLE_BUFFERS>
		<SAMPLES public="1"><x path="Int"/></SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1"><x path="Int"/></SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1"><x path="Int"/></SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1"><x path="Int"/></COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1"><x path="Int"/></DONT_CARE>
		<FASTEST public="1"><x path="Int"/></FASTEST>
		<NICEST public="1"><x path="Int"/></NICEST>
		<GENERATE_MIPMAP_HINT public="1"><x path="Int"/></GENERATE_MIPMAP_HINT>
		<BYTE public="1"><x path="Int"/></BYTE>
		<UNSIGNED_BYTE public="1"><x path="Int"/></UNSIGNED_BYTE>
		<SHORT public="1"><x path="Int"/></SHORT>
		<UNSIGNED_SHORT public="1"><x path="Int"/></UNSIGNED_SHORT>
		<INT public="1"><x path="Int"/></INT>
		<UNSIGNED_INT public="1"><x path="Int"/></UNSIGNED_INT>
		<FLOAT public="1"><x path="Int"/></FLOAT>
		<DEPTH_COMPONENT public="1"><x path="Int"/></DEPTH_COMPONENT>
		<ALPHA public="1"><x path="Int"/></ALPHA>
		<RGB public="1"><x path="Int"/></RGB>
		<RGBA public="1"><x path="Int"/></RGBA>
		<LUMINANCE public="1"><x path="Int"/></LUMINANCE>
		<LUMINANCE_ALPHA public="1"><x path="Int"/></LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1"><x path="Int"/></UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1"><x path="Int"/></UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1"><x path="Int"/></UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1"><x path="Int"/></FRAGMENT_SHADER>
		<VERTEX_SHADER public="1"><x path="Int"/></VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1"><x path="Int"/></MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1"><x path="Int"/></MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1"><x path="Int"/></MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1"><x path="Int"/></MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1"><x path="Int"/></MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1"><x path="Int"/></MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1"><x path="Int"/></MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1"><x path="Int"/></SHADER_TYPE>
		<DELETE_STATUS public="1"><x path="Int"/></DELETE_STATUS>
		<LINK_STATUS public="1"><x path="Int"/></LINK_STATUS>
		<VALIDATE_STATUS public="1"><x path="Int"/></VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1"><x path="Int"/></ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1"><x path="Int"/></ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1"><x path="Int"/></ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1"><x path="Int"/></SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1"><x path="Int"/></CURRENT_PROGRAM>
		<NEVER public="1"><x path="Int"/></NEVER>
		<LESS public="1"><x path="Int"/></LESS>
		<EQUAL public="1"><x path="Int"/></EQUAL>
		<LEQUAL public="1"><x path="Int"/></LEQUAL>
		<GREATER public="1"><x path="Int"/></GREATER>
		<NOTEQUAL public="1"><x path="Int"/></NOTEQUAL>
		<GEQUAL public="1"><x path="Int"/></GEQUAL>
		<ALWAYS public="1"><x path="Int"/></ALWAYS>
		<KEEP public="1"><x path="Int"/></KEEP>
		<REPLACE public="1"><x path="Int"/></REPLACE>
		<INCR public="1"><x path="Int"/></INCR>
		<DECR public="1"><x path="Int"/></DECR>
		<INVERT public="1"><x path="Int"/></INVERT>
		<INCR_WRAP public="1"><x path="Int"/></INCR_WRAP>
		<DECR_WRAP public="1"><x path="Int"/></DECR_WRAP>
		<VENDOR public="1"><x path="Int"/></VENDOR>
		<RENDERER public="1"><x path="Int"/></RENDERER>
		<VERSION public="1"><x path="Int"/></VERSION>
		<NEAREST public="1"><x path="Int"/></NEAREST>
		<LINEAR public="1"><x path="Int"/></LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1"><x path="Int"/></NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1"><x path="Int"/></LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1"><x path="Int"/></NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1"><x path="Int"/></LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1"><x path="Int"/></TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1"><x path="Int"/></TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1"><x path="Int"/></TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1"><x path="Int"/></TEXTURE_WRAP_T>
		<TEXTURE_2D public="1"><x path="Int"/></TEXTURE_2D>
		<TEXTURE public="1"><x path="Int"/></TEXTURE>
		<TEXTURE_CUBE_MAP public="1"><x path="Int"/></TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1"><x path="Int"/></TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1"><x path="Int"/></MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1"><x path="Int"/></TEXTURE0>
		<TEXTURE1 public="1"><x path="Int"/></TEXTURE1>
		<TEXTURE2 public="1"><x path="Int"/></TEXTURE2>
		<TEXTURE3 public="1"><x path="Int"/></TEXTURE3>
		<TEXTURE4 public="1"><x path="Int"/></TEXTURE4>
		<TEXTURE5 public="1"><x path="Int"/></TEXTURE5>
		<TEXTURE6 public="1"><x path="Int"/></TEXTURE6>
		<TEXTURE7 public="1"><x path="Int"/></TEXTURE7>
		<TEXTURE8 public="1"><x path="Int"/></TEXTURE8>
		<TEXTURE9 public="1"><x path="Int"/></TEXTURE9>
		<TEXTURE10 public="1"><x path="Int"/></TEXTURE10>
		<TEXTURE11 public="1"><x path="Int"/></TEXTURE11>
		<TEXTURE12 public="1"><x path="Int"/></TEXTURE12>
		<TEXTURE13 public="1"><x path="Int"/></TEXTURE13>
		<TEXTURE14 public="1"><x path="Int"/></TEXTURE14>
		<TEXTURE15 public="1"><x path="Int"/></TEXTURE15>
		<TEXTURE16 public="1"><x path="Int"/></TEXTURE16>
		<TEXTURE17 public="1"><x path="Int"/></TEXTURE17>
		<TEXTURE18 public="1"><x path="Int"/></TEXTURE18>
		<TEXTURE19 public="1"><x path="Int"/></TEXTURE19>
		<TEXTURE20 public="1"><x path="Int"/></TEXTURE20>
		<TEXTURE21 public="1"><x path="Int"/></TEXTURE21>
		<TEXTURE22 public="1"><x path="Int"/></TEXTURE22>
		<TEXTURE23 public="1"><x path="Int"/></TEXTURE23>
		<TEXTURE24 public="1"><x path="Int"/></TEXTURE24>
		<TEXTURE25 public="1"><x path="Int"/></TEXTURE25>
		<TEXTURE26 public="1"><x path="Int"/></TEXTURE26>
		<TEXTURE27 public="1"><x path="Int"/></TEXTURE27>
		<TEXTURE28 public="1"><x path="Int"/></TEXTURE28>
		<TEXTURE29 public="1"><x path="Int"/></TEXTURE29>
		<TEXTURE30 public="1"><x path="Int"/></TEXTURE30>
		<TEXTURE31 public="1"><x path="Int"/></TEXTURE31>
		<ACTIVE_TEXTURE public="1"><x path="Int"/></ACTIVE_TEXTURE>
		<REPEAT public="1"><x path="Int"/></REPEAT>
		<CLAMP_TO_EDGE public="1"><x path="Int"/></CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1"><x path="Int"/></MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1"><x path="Int"/></FLOAT_VEC2>
		<FLOAT_VEC3 public="1"><x path="Int"/></FLOAT_VEC3>
		<FLOAT_VEC4 public="1"><x path="Int"/></FLOAT_VEC4>
		<INT_VEC2 public="1"><x path="Int"/></INT_VEC2>
		<INT_VEC3 public="1"><x path="Int"/></INT_VEC3>
		<INT_VEC4 public="1"><x path="Int"/></INT_VEC4>
		<BOOL public="1"><x path="Int"/></BOOL>
		<BOOL_VEC2 public="1"><x path="Int"/></BOOL_VEC2>
		<BOOL_VEC3 public="1"><x path="Int"/></BOOL_VEC3>
		<BOOL_VEC4 public="1"><x path="Int"/></BOOL_VEC4>
		<FLOAT_MAT2 public="1"><x path="Int"/></FLOAT_MAT2>
		<FLOAT_MAT3 public="1"><x path="Int"/></FLOAT_MAT3>
		<FLOAT_MAT4 public="1"><x path="Int"/></FLOAT_MAT4>
		<SAMPLER_2D public="1"><x path="Int"/></SAMPLER_2D>
		<SAMPLER_CUBE public="1"><x path="Int"/></SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<VERTEX_PROGRAM_POINT_SIZE public="1"><x path="Int"/></VERTEX_PROGRAM_POINT_SIZE>
		<POINT_SPRITE public="1"><x path="Int"/></POINT_SPRITE>
		<COMPILE_STATUS public="1"><x path="Int"/></COMPILE_STATUS>
		<LOW_FLOAT public="1"><x path="Int"/></LOW_FLOAT>
		<MEDIUM_FLOAT public="1"><x path="Int"/></MEDIUM_FLOAT>
		<HIGH_FLOAT public="1"><x path="Int"/></HIGH_FLOAT>
		<LOW_INT public="1"><x path="Int"/></LOW_INT>
		<MEDIUM_INT public="1"><x path="Int"/></MEDIUM_INT>
		<HIGH_INT public="1"><x path="Int"/></HIGH_INT>
		<FRAMEBUFFER public="1"><x path="Int"/></FRAMEBUFFER>
		<RENDERBUFFER public="1"><x path="Int"/></RENDERBUFFER>
		<RGBA4 public="1"><x path="Int"/></RGBA4>
		<RGB5_A1 public="1"><x path="Int"/></RGB5_A1>
		<RGB565 public="1"><x path="Int"/></RGB565>
		<DEPTH_COMPONENT16 public="1"><x path="Int"/></DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1"><x path="Int"/></STENCIL_INDEX>
		<STENCIL_INDEX8 public="1"><x path="Int"/></STENCIL_INDEX8>
		<DEPTH_STENCIL public="1"><x path="Int"/></DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1"><x path="Int"/></RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1"><x path="Int"/></RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1"><x path="Int"/></RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1"><x path="Int"/></RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1"><x path="Int"/></RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1"><x path="Int"/></RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1"><x path="Int"/></RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1"><x path="Int"/></RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1"><x path="Int"/></RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1"><x path="Int"/></COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1"><x path="Int"/></DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1"><x path="Int"/></STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1"><x path="Int"/></DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1"><x path="Int"/></NONE>
		<FRAMEBUFFER_COMPLETE public="1"><x path="Int"/></FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1"><x path="Int"/></FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1"><x path="Int"/></FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1"><x path="Int"/></RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1"><x path="Int"/></MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1"><x path="Int"/></INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1"><x path="Int"/></UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1"><x path="Int"/></UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1"><x path="Int"/></CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1"><x path="Int"/></UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1"><x path="Int"/></BROWSER_DEFAULT_WEBGL>
		<version public="1" get="accessor" set="null"><x path="Int"/></version>
		<activeTexture public="1" get="inline" set="null" line="372"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" get="inline" set="null" line="379"><f a="program:shader">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" get="inline" set="null" line="386"><f a="program:index:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBuffer public="1" get="inline" set="null" line="393"><f a="target:buffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" get="inline" set="null" line="400"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" get="inline" set="null" line="407"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" get="inline" set="null" line="414"><f a="target:texture">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" get="inline" set="null" line="421"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" get="inline" set="null" line="428"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" get="inline" set="null" line="435"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" get="inline" set="null" line="442"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" get="inline" set="null" line="449"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" get="inline" set="null" line="456"><f a="target:data:usage">
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<bufferSubData public="1" get="inline" set="null" line="463"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></bufferSubData>
		<checkFramebufferStatus public="1" get="inline" set="null" line="470"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" get="inline" set="null" line="477"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" get="inline" set="null" line="484"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" get="inline" set="null" line="491"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" get="inline" set="null" line="498"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" get="inline" set="null" line="505"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" get="inline" set="null" line="512"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" get="inline" set="null" line="519"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" get="inline" set="null" line="526"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" get="inline" set="null" line="533"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" get="inline" set="null" line="540"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" get="inline" set="null" line="547"><f a=""><c path="lime.graphics.opengl.GLBuffer"/></f></createBuffer>
		<createFramebuffer public="1" get="inline" set="null" line="554"><f a=""><c path="lime.graphics.opengl.GLFramebuffer"/></f></createFramebuffer>
		<createProgram public="1" get="inline" set="null" line="561"><f a=""><c path="lime.graphics.opengl.GLProgram"/></f></createProgram>
		<createRenderbuffer public="1" get="inline" set="null" line="568"><f a=""><c path="lime.graphics.opengl.GLRenderbuffer"/></f></createRenderbuffer>
		<createShader public="1" get="inline" set="null" line="575"><f a="type">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLShader"/>
</f></createShader>
		<createTexture public="1" get="inline" set="null" line="582"><f a=""><c path="lime.graphics.opengl.GLTexture"/></f></createTexture>
		<cullFace public="1" get="inline" set="null" line="589"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" get="inline" set="null" line="596"><f a="buffer">
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" get="inline" set="null" line="603"><f a="framebuffer">
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" get="inline" set="null" line="610"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" get="inline" set="null" line="617"><f a="renderbuffer">
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" get="inline" set="null" line="624"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" get="inline" set="null" line="631"><f a="texture">
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" get="inline" set="null" line="638"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" get="inline" set="null" line="645"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" get="inline" set="null" line="652"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" get="inline" set="null" line="659"><f a="program:shader">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" get="inline" set="null" line="666"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" get="inline" set="null" line="673"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" get="inline" set="null" line="680"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" get="inline" set="null" line="687"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" get="inline" set="null" line="694"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" get="inline" set="null" line="701"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" get="inline" set="null" line="708"><f a=""><x path="Void"/></f></finish>
		<flush public="1" get="inline" set="null" line="715"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" get="inline" set="null" line="722"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" get="inline" set="null" line="729"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" get="inline" set="null" line="736"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" get="inline" set="null" line="743"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" get="inline" set="null" line="750"><f a="program:index">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" get="inline" set="null" line="757"><f a="program:index">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" get="inline" set="null" line="764"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="Array"><c path="lime.graphics.opengl.GLShader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" get="inline" set="null" line="771"><f a="program:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" get="inline" set="null" line="778"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferParameter>
		<getContextAttributes public="1" get="inline" set="null" line="785"><f a=""><t path="lime.graphics.opengl.GLContextAttributes"/></f></getContextAttributes>
		<getError public="1" get="inline" set="null" line="792"><f a=""><x path="Int"/></f></getError>
		<getExtension public="1" get="inline" set="null" line="799"><f a="name">
	<c path="String"/>
	<d/>
</f></getExtension>
		<getFramebufferAttachmentParameter public="1" get="inline" set="null" line="806"><f a="target:attachment:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getFramebufferAttachmentParameter>
		<getParameter public="1" get="inline" set="null" line="813"><f a="pname">
	<x path="Int"/>
	<d/>
</f></getParameter>
		<getProgramInfoLog public="1" get="inline" set="null" line="820"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getProgramParameter public="1" get="inline" set="null" line="827"><f a="program:pname">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getProgramParameter>
		<getRenderbufferParameter public="1" get="inline" set="null" line="834"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getRenderbufferParameter>
		<getShaderInfoLog public="1" get="inline" set="null" line="841"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderParameter public="1" get="inline" set="null" line="848"><f a="shader:pname">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" get="inline" set="null" line="855"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderSource public="1" get="inline" set="null" line="862"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
</f></getShaderSource>
		<getSupportedExtensions public="1" get="inline" set="null" line="869"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getTexParameter public="1" get="inline" set="null" line="876"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getTexParameter>
		<getUniform public="1" get="inline" set="null" line="883"><f a="program:location">
	<c path="lime.graphics.opengl.GLProgram"/>
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" get="inline" set="null" line="890"><f a="program:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
	<t path="lime.graphics.opengl.GLUniformLocation"/>
</f></getUniformLocation>
		<getVertexAttrib public="1" get="inline" set="null" line="897"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttrib>
		<getVertexAttribOffset public="1" get="inline" set="null" line="904"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" get="inline" set="null" line="911"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" get="inline" set="null" line="918"><f a="buffer">
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" get="inline" set="null" line="929"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" get="inline" set="null" line="936"><f a="framebuffer">
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" get="inline" set="null" line="943"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" get="inline" set="null" line="950"><f a="renderbuffer">
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" get="inline" set="null" line="957"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" get="inline" set="null" line="964"><f a="texture">
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" get="inline" set="null" line="971"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" get="inline" set="null" line="978"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></linkProgram>
		<pixelStorei public="1" get="inline" set="null" line="985"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" get="inline" set="null" line="992"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<readPixels public="1" get="inline" set="null" line="999"><f a="x:y:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></readPixels>
		<renderbufferStorage public="1" get="inline" set="null" line="1006"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" get="inline" set="null" line="1013"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" get="inline" set="null" line="1020"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" get="inline" set="null" line="1027"><f a="shader:source">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" get="inline" set="null" line="1034"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" get="inline" set="null" line="1041"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" get="inline" set="null" line="1048"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" get="inline" set="null" line="1055"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" get="inline" set="null" line="1062"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" get="inline" set="null" line="1069"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" get="inline" set="null" line="1076"><f a="target:level:internalformat:width:height:border:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texImage2D>
		<texParameterf public="1" get="inline" set="null" line="1083"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" get="inline" set="null" line="1090"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" get="inline" set="null" line="1097"><f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texSubImage2D>
		<uniform1f public="1" get="inline" set="null" line="1104"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" get="inline" set="null" line="1111"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform1fv>
		<uniform1i public="1" get="inline" set="null" line="1118"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" get="inline" set="null" line="1125"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform1iv>
		<uniform2f public="1" get="inline" set="null" line="1132"><f a="location:x:y">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" get="inline" set="null" line="1139"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform2fv>
		<uniform2i public="1" get="inline" set="null" line="1146"><f a="location:x:y">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" get="inline" set="null" line="1153"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform2iv>
		<uniform3f public="1" get="inline" set="null" line="1160"><f a="location:x:y:z">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" get="inline" set="null" line="1167"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform3fv>
		<uniform3i public="1" get="inline" set="null" line="1174"><f a="location:x:y:z">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" get="inline" set="null" line="1181"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform3iv>
		<uniform4f public="1" get="inline" set="null" line="1188"><f a="location:x:y:z:w">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" get="inline" set="null" line="1195"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform4fv>
		<uniform4i public="1" get="inline" set="null" line="1202"><f a="location:x:y:z:w">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" get="inline" set="null" line="1209"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform4iv>
		<uniformMatrix2fv public="1" get="inline" set="null" line="1216"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix2fv>
		<uniformMatrix3fv public="1" get="inline" set="null" line="1223"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix3fv>
		<uniformMatrix4fv public="1" get="inline" set="null" line="1230"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix4fv>
		<useProgram public="1" get="inline" set="null" line="1244"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" get="inline" set="null" line="1251"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" get="inline" set="null" line="1258"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" get="inline" set="null" line="1265"><f a="indx:values">
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib1fv>
		<vertexAttrib2f public="1" get="inline" set="null" line="1272"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" get="inline" set="null" line="1279"><f a="indx:values">
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib2fv>
		<vertexAttrib3f public="1" get="inline" set="null" line="1286"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" get="inline" set="null" line="1293"><f a="indx:values">
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib3fv>
		<vertexAttrib4f public="1" get="inline" set="null" line="1300"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" get="inline" set="null" line="1307"><f a="indx:values">
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib4fv>
		<vertexAttribPointer public="1" get="inline" set="null" line="1314"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" get="inline" set="null" line="1321"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<get_version set="method" line="1328"><f a=""><x path="Int"/></f></get_version>
		<new public="1" set="method" line="365"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.graphics.Image" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Image.hx">
		<__base64Chars line="50" static="1"><c path="String"/></__base64Chars>
		<__base64Encoder static="1"><c path="haxe.crypto.BaseCode"/></__base64Encoder>
		<fromBase64 public="1" set="method" line="410" static="1"><f a="base64:type:onload">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<c path="lime.graphics.Image"/>
</f></fromBase64>
		<fromBitmapData public="1" set="method" line="419" static="1"><f a="bitmapData">
	<d/>
	<c path="lime.graphics.Image"/>
</f></fromBitmapData>
		<fromBytes public="1" set="method" line="428" static="1"><f a="bytes:?onload" v=":null">
	<c path="lime.utils.ByteArray"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<c path="lime.graphics.Image"/>
</f></fromBytes>
		<fromCanvas public="1" set="method" line="437" static="1"><f a="canvas">
	<d/>
	<c path="lime.graphics.Image"/>
</f></fromCanvas>
		<fromFile public="1" set="method" line="446" static="1"><f a="path:?onload:?onerror" v=":null:null">
	<c path="String"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<c path="lime.graphics.Image"/>
</f></fromFile>
		<fromImageElement public="1" set="method" line="455" static="1"><f a="image">
	<d/>
	<c path="lime.graphics.Image"/>
</f></fromImageElement>
		<__base64Encode set="method" line="684" static="1"><f a="bytes">
	<c path="lime.utils.ByteArray"/>
	<c path="String"/>
</f></__base64Encode>
		<__isJPG set="method" line="966" static="1"><f a="bytes">
	<c path="lime.utils.ByteArray"/>
	<x path="Bool"/>
</f></__isJPG>
		<__isPNG set="method" line="974" static="1"><f a="bytes">
	<c path="lime.utils.ByteArray"/>
	<x path="Bool"/>
</f></__isPNG>
		<__isGIF set="method" line="981" static="1"><f a="bytes">
	<c path="lime.utils.ByteArray"/>
	<x path="Bool"/>
</f></__isGIF>
		<lime_image_encode line="1184" static="1"><f a="::">
	<c path="lime.graphics.ImageBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ByteArray"/>
</f></lime_image_encode>
		<lime_image_load line="1185" static="1"><d/></lime_image_load>
		<buffer public="1"><c path="lime.graphics.ImageBuffer"/></buffer>
		<data public="1" get="accessor" set="accessor"><c path="lime.utils.UInt8Array"/></data>
		<dirty public="1"><x path="Bool"/></dirty>
		<height public="1"><x path="Int"/></height>
		<offsetX public="1"><x path="Int"/></offsetX>
		<offsetY public="1"><x path="Int"/></offsetY>
		<powerOfTwo public="1" get="accessor" set="accessor"><x path="Bool"/></powerOfTwo>
		<premultiplied public="1" get="accessor" set="accessor"><x path="Bool"/></premultiplied>
		<rect public="1" get="accessor" set="null"><c path="lime.math.Rectangle"/></rect>
		<src public="1" get="accessor" set="accessor"><d/></src>
		<transparent public="1" get="accessor" set="accessor"><x path="Bool"/></transparent>
		<type public="1"><e path="lime.graphics.ImageType"/></type>
		<width public="1"><x path="Int"/></width>
		<clone public="1" set="method" line="148"><f a=""><c path="lime.graphics.Image"/></f></clone>
		<colorTransform public="1" set="method" line="160"><f a="rect:colorMatrix">
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<copyChannel public="1" set="method" line="191"><f a="sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="243"><f a="sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v=":::null:null:false">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Vector2"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyPixels>
		<encode public="1" set="method" line="286"><f a="?format:?quality" v="'png':90">
	<c path="String"/>
	<x path="Int"/>
	<c path="lime.utils.ByteArray"/>
</f></encode>
		<fillRect public="1" set="method" line="350"><f a="rect:color">
	<c path="lime.math.Rectangle"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="381"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></floodFill>
		<getPixel public="1" set="method" line="464"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="495"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="526"><f a="rect">
	<c path="lime.math.Rectangle"/>
	<c path="lime.utils.ByteArray"/>
</f></getPixels>
		<resize public="1" set="method" line="558"><f a="newWidth:newHeight">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setPixel public="1" set="method" line="595"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="624"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="653"><f a="rect:byteArray">
	<c path="lime.math.Rectangle"/>
	<c path="lime.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<__clipRect set="method" line="709"><f a="r">
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Rectangle"/>
</f></__clipRect>
		<__fromBase64 set="method" line="752"><f a="base64:type:?onload" v="::null">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></__fromBase64>
		<__fromBytes set="method" line="782"><f a="bytes:onload">
	<c path="lime.utils.ByteArray"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></__fromBytes>
		<__fromFile set="method" line="833"><f a="path:onload:onerror">
	<c path="String"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></__fromFile>
		<__fromImageBuffer set="method" line="943"><f a="buffer">
	<c path="lime.graphics.ImageBuffer"/>
	<x path="Void"/>
</f></__fromImageBuffer>
		<get_data set="method" line="1004"><f a=""><c path="lime.utils.UInt8Array"/></f></get_data>
		<set_data set="method" line="1023"><f a="value">
	<c path="lime.utils.UInt8Array"/>
	<c path="lime.utils.UInt8Array"/>
</f></set_data>
		<get_powerOfTwo set="method" line="1030"><f a=""><x path="Bool"/></f></get_powerOfTwo>
		<set_powerOfTwo set="method" line="1037"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_powerOfTwo>
		<get_premultiplied set="method" line="1087"><f a=""><x path="Bool"/></f></get_premultiplied>
		<set_premultiplied set="method" line="1094"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_premultiplied>
		<get_rect public="1" set="method" line="1139"><f a=""><c path="lime.math.Rectangle"/></f></get_rect>
		<get_src public="1" set="method" line="1146"><f a=""><d/></f></get_src>
		<set_src set="method" line="1153"><f a="value">
	<d/>
	<d/>
</f></set_src>
		<get_transparent set="method" line="1160"><f a=""><x path="Bool"/></f></get_transparent>
		<set_transparent set="method" line="1167"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_transparent>
		<new public="1" set="method" line="68"><f a="?buffer:?offsetX:?offsetY:?width:?height:?color:?type" v="null:0:0:0:0:null:null">
	<c path="lime.graphics.ImageBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="lime.graphics.ImageType"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":allow"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="lime.graphics.ImageChannel" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Image.hx" module="lime.graphics.Image">
		<RED/>
		<GREEN/>
		<BLUE/>
		<ALPHA/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.graphics.ImageBuffer" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/ImageBuffer.hx">
		<bitsPerPixel public="1"><x path="Int"/></bitsPerPixel>
		<data public="1"><c path="lime.utils.UInt8Array"/></data>
		<height public="1"><x path="Int"/></height>
		<premultiplied public="1"><x path="Bool"/></premultiplied>
		<src public="1" get="accessor" set="accessor"><d/></src>
		<transparent public="1"><x path="Bool"/></transparent>
		<width public="1"><x path="Int"/></width>
		<__srcBitmapData>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcBitmapData>
		<__srcCanvas>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCanvas>
		<__srcContext>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcContext>
		<__srcCustom>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCustom>
		<__srcImage>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcImage>
		<__srcImageData>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcImageData>
		<clone public="1" set="method" line="48"><f a=""><c path="lime.graphics.ImageBuffer"/></f></clone>
		<get_src set="method" line="66"><f a=""><d/></f></get_src>
		<set_src set="method" line="80"><f a="value">
	<d/>
	<d/>
</f></set_src>
		<new public="1" set="method" line="37"><f a="?data:?width:?height:?bitsPerPixel" v="null:0:0:4">
	<c path="lime.utils.UInt8Array"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<enum path="lime.graphics.ImageType" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/ImageType.hx">
		<CANVAS/>
		<DATA/>
		<FLASH/>
		<CUSTOM/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="lime.graphics.RenderContext" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/RenderContext.hx">
		<OPENGL a="gl"><c path="lime.graphics.GLRenderContext"/></OPENGL>
		<CANVAS a="context"><c path="lime.graphics.CanvasRenderContext"/></CANVAS>
		<DOM a="element"><c path="lime.graphics.DOMRenderContext"/></DOM>
		<FLASH a="stage"><c path="lime.graphics.FlashRenderContext"/></FLASH>
		<CUSTOM a="data"><d/></CUSTOM>
	</enum>
	<class path="lime.graphics._Renderer.RenderEventInfo" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Renderer.hx" private="1" module="lime.graphics.Renderer">
		<context public="1"><e path="lime.graphics.RenderContext"/></context>
		<type public="1"><x path="lime.graphics._Renderer.RenderEventType"/></type>
		<clone public="1" set="method" line="184"><f a=""><c path="lime.graphics._Renderer.RenderEventInfo"/></f></clone>
		<new public="1" set="method" line="176"><f a="?type:?context" v="null:null">
	<x path="lime.graphics._Renderer.RenderEventType"/>
	<e path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.graphics.Renderer" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Renderer.hx">
		<onRender public="1" line="26" static="1"><c path="lime.app.Event"><f a="">
	<e path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></c></onRender>
		<eventInfo line="28" static="1"><c path="lime.graphics._Renderer.RenderEventInfo"/></eventInfo>
		<registered static="1"><x path="Bool"/></registered>
		<dispatch set="method" line="119" static="1"><f a=""><x path="Void"/></f></dispatch>
		<lime_render_event_manager_register line="160" static="1"><f a=":">
	<f a=""><x path="Void"/></f>
	<c path="lime.graphics._Renderer.RenderEventInfo"/>
	<unknown/>
</f></lime_render_event_manager_register>
		<lime_renderer_create line="161" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_renderer_create>
		<lime_renderer_flip line="162" static="1"><f a="">
	<d/>
	<unknown/>
</f></lime_renderer_flip>
		<context public="1"><e path="lime.graphics.RenderContext"/></context>
		<handle public="1"><d/></handle>
		<window><c path="lime.ui.Window"/></window>
		<create public="1" set="method" line="45"><f a=""><x path="Void"/></f></create>
		<flip public="1" set="method" line="150"><f a=""><x path="Void"/></f></flip>
		<new public="1" set="method" line="37"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":allow"><e>'???'</e></m>
		</meta>
	</class>
	<abstract path="lime.graphics._Renderer.RenderEventType" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Renderer.hx" private="1" module="lime.graphics.Renderer">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics._Renderer.RenderEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Renderer.hx" private="1" module="lime.graphics.Renderer">
	<RENDER public="1" get="inline" set="null" line="196" static="1">
		<x path="lime.graphics._Renderer.RenderEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RENDER>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.graphics._Renderer.RenderEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/Renderer.hx" private="1" module="lime.graphics.Renderer">
		<RENDER public="1" get="inline" set="null" line="196" static="1">
			<x path="lime.graphics._Renderer.RenderEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RENDER>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.graphics.opengl.GL" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GL.hx">
		<DEPTH_BUFFER_BIT public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></COLOR_BUFFER_BIT>
		<POINTS public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></POINTS>
		<LINES public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></LINES>
		<LINE_LOOP public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></LINE_LOOP>
		<LINE_STRIP public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></LINE_STRIP>
		<TRIANGLES public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></TRIANGLES>
		<TRIANGLE_STRIP public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></TRIANGLE_FAN>
		<ZERO public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></ZERO>
		<ONE public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></ONE>
		<SRC_COLOR public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></FUNC_ADD>
		<BLEND_EQUATION public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1" get="inline" set="null" line="54" static="1"><x path="Int"/></BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1" get="inline" set="null" line="55" static="1"><x path="Int"/></BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1" get="inline" set="null" line="56" static="1"><x path="Int"/></BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1" get="inline" set="null" line="57" static="1"><x path="Int"/></CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" line="58" static="1"><x path="Int"/></ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1" get="inline" set="null" line="59" static="1"><x path="Int"/></CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" line="60" static="1"><x path="Int"/></ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1" get="inline" set="null" line="61" static="1"><x path="Int"/></BLEND_COLOR>
		<ARRAY_BUFFER public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1" get="inline" set="null" line="64" static="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="65" static="1"><x path="Int"/></ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="66" static="1"><x path="Int"/></ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1" get="inline" set="null" line="68" static="1"><x path="Int"/></STREAM_DRAW>
		<STATIC_DRAW public="1" get="inline" set="null" line="69" static="1"><x path="Int"/></STATIC_DRAW>
		<DYNAMIC_DRAW public="1" get="inline" set="null" line="70" static="1"><x path="Int"/></DYNAMIC_DRAW>
		<BUFFER_SIZE public="1" get="inline" set="null" line="72" static="1"><x path="Int"/></BUFFER_SIZE>
		<BUFFER_USAGE public="1" get="inline" set="null" line="73" static="1"><x path="Int"/></BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1" get="inline" set="null" line="75" static="1"><x path="Int"/></CURRENT_VERTEX_ATTRIB>
		<FRONT public="1" get="inline" set="null" line="77" static="1"><x path="Int"/></FRONT>
		<BACK public="1" get="inline" set="null" line="78" static="1"><x path="Int"/></BACK>
		<FRONT_AND_BACK public="1" get="inline" set="null" line="79" static="1"><x path="Int"/></FRONT_AND_BACK>
		<CULL_FACE public="1" get="inline" set="null" line="81" static="1"><x path="Int"/></CULL_FACE>
		<BLEND public="1" get="inline" set="null" line="82" static="1"><x path="Int"/></BLEND>
		<DITHER public="1" get="inline" set="null" line="83" static="1"><x path="Int"/></DITHER>
		<STENCIL_TEST public="1" get="inline" set="null" line="84" static="1"><x path="Int"/></STENCIL_TEST>
		<DEPTH_TEST public="1" get="inline" set="null" line="85" static="1"><x path="Int"/></DEPTH_TEST>
		<SCISSOR_TEST public="1" get="inline" set="null" line="86" static="1"><x path="Int"/></SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1" get="inline" set="null" line="87" static="1"><x path="Int"/></POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1" get="inline" set="null" line="88" static="1"><x path="Int"/></SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1" get="inline" set="null" line="89" static="1"><x path="Int"/></SAMPLE_COVERAGE>
		<NO_ERROR public="1" get="inline" set="null" line="91" static="1"><x path="Int"/></NO_ERROR>
		<INVALID_ENUM public="1" get="inline" set="null" line="92" static="1"><x path="Int"/></INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" line="93" static="1"><x path="Int"/></INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" line="94" static="1"><x path="Int"/></INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" line="95" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<CW public="1" get="inline" set="null" line="97" static="1"><x path="Int"/></CW>
		<CCW public="1" get="inline" set="null" line="98" static="1"><x path="Int"/></CCW>
		<LINE_WIDTH public="1" get="inline" set="null" line="100" static="1"><x path="Int"/></LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1" get="inline" set="null" line="101" static="1"><x path="Int"/></ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1" get="inline" set="null" line="102" static="1"><x path="Int"/></ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1" get="inline" set="null" line="103" static="1"><x path="Int"/></CULL_FACE_MODE>
		<FRONT_FACE public="1" get="inline" set="null" line="104" static="1"><x path="Int"/></FRONT_FACE>
		<DEPTH_RANGE public="1" get="inline" set="null" line="105" static="1"><x path="Int"/></DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" get="inline" set="null" line="106" static="1"><x path="Int"/></DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1" get="inline" set="null" line="107" static="1"><x path="Int"/></DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" get="inline" set="null" line="108" static="1"><x path="Int"/></DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1" get="inline" set="null" line="109" static="1"><x path="Int"/></STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1" get="inline" set="null" line="110" static="1"><x path="Int"/></STENCIL_FUNC>
		<STENCIL_FAIL public="1" get="inline" set="null" line="111" static="1"><x path="Int"/></STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1" get="inline" set="null" line="112" static="1"><x path="Int"/></STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" get="inline" set="null" line="113" static="1"><x path="Int"/></STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1" get="inline" set="null" line="114" static="1"><x path="Int"/></STENCIL_REF>
		<STENCIL_VALUE_MASK public="1" get="inline" set="null" line="115" static="1"><x path="Int"/></STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1" get="inline" set="null" line="116" static="1"><x path="Int"/></STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1" get="inline" set="null" line="117" static="1"><x path="Int"/></STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1" get="inline" set="null" line="118" static="1"><x path="Int"/></STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1" get="inline" set="null" line="119" static="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1" get="inline" set="null" line="120" static="1"><x path="Int"/></STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1" get="inline" set="null" line="121" static="1"><x path="Int"/></STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1" get="inline" set="null" line="122" static="1"><x path="Int"/></STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1" get="inline" set="null" line="123" static="1"><x path="Int"/></STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1" get="inline" set="null" line="124" static="1"><x path="Int"/></VIEWPORT>
		<SCISSOR_BOX public="1" get="inline" set="null" line="125" static="1"><x path="Int"/></SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1" get="inline" set="null" line="127" static="1"><x path="Int"/></COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" get="inline" set="null" line="128" static="1"><x path="Int"/></COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1" get="inline" set="null" line="129" static="1"><x path="Int"/></UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1" get="inline" set="null" line="130" static="1"><x path="Int"/></PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1" get="inline" set="null" line="131" static="1"><x path="Int"/></MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1" get="inline" set="null" line="132" static="1"><x path="Int"/></MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1" get="inline" set="null" line="133" static="1"><x path="Int"/></SUBPIXEL_BITS>
		<RED_BITS public="1" get="inline" set="null" line="134" static="1"><x path="Int"/></RED_BITS>
		<GREEN_BITS public="1" get="inline" set="null" line="135" static="1"><x path="Int"/></GREEN_BITS>
		<BLUE_BITS public="1" get="inline" set="null" line="136" static="1"><x path="Int"/></BLUE_BITS>
		<ALPHA_BITS public="1" get="inline" set="null" line="137" static="1"><x path="Int"/></ALPHA_BITS>
		<DEPTH_BITS public="1" get="inline" set="null" line="138" static="1"><x path="Int"/></DEPTH_BITS>
		<STENCIL_BITS public="1" get="inline" set="null" line="139" static="1"><x path="Int"/></STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1" get="inline" set="null" line="140" static="1"><x path="Int"/></POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1" get="inline" set="null" line="142" static="1"><x path="Int"/></POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1" get="inline" set="null" line="143" static="1"><x path="Int"/></TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1" get="inline" set="null" line="144" static="1"><x path="Int"/></SAMPLE_BUFFERS>
		<SAMPLES public="1" get="inline" set="null" line="145" static="1"><x path="Int"/></SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1" get="inline" set="null" line="146" static="1"><x path="Int"/></SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1" get="inline" set="null" line="147" static="1"><x path="Int"/></SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1" get="inline" set="null" line="149" static="1"><x path="Int"/></COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1" get="inline" set="null" line="151" static="1"><x path="Int"/></DONT_CARE>
		<FASTEST public="1" get="inline" set="null" line="152" static="1"><x path="Int"/></FASTEST>
		<NICEST public="1" get="inline" set="null" line="153" static="1"><x path="Int"/></NICEST>
		<GENERATE_MIPMAP_HINT public="1" get="inline" set="null" line="155" static="1"><x path="Int"/></GENERATE_MIPMAP_HINT>
		<BYTE public="1" get="inline" set="null" line="157" static="1"><x path="Int"/></BYTE>
		<UNSIGNED_BYTE public="1" get="inline" set="null" line="158" static="1"><x path="Int"/></UNSIGNED_BYTE>
		<SHORT public="1" get="inline" set="null" line="159" static="1"><x path="Int"/></SHORT>
		<UNSIGNED_SHORT public="1" get="inline" set="null" line="160" static="1"><x path="Int"/></UNSIGNED_SHORT>
		<INT public="1" get="inline" set="null" line="161" static="1"><x path="Int"/></INT>
		<UNSIGNED_INT public="1" get="inline" set="null" line="162" static="1"><x path="Int"/></UNSIGNED_INT>
		<FLOAT public="1" get="inline" set="null" line="163" static="1"><x path="Int"/></FLOAT>
		<DEPTH_COMPONENT public="1" get="inline" set="null" line="165" static="1"><x path="Int"/></DEPTH_COMPONENT>
		<ALPHA public="1" get="inline" set="null" line="166" static="1"><x path="Int"/></ALPHA>
		<RGB public="1" get="inline" set="null" line="167" static="1"><x path="Int"/></RGB>
		<RGBA public="1" get="inline" set="null" line="168" static="1"><x path="Int"/></RGBA>
		<LUMINANCE public="1" get="inline" set="null" line="169" static="1"><x path="Int"/></LUMINANCE>
		<LUMINANCE_ALPHA public="1" get="inline" set="null" line="170" static="1"><x path="Int"/></LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1" get="inline" set="null" line="172" static="1"><x path="Int"/></UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1" get="inline" set="null" line="173" static="1"><x path="Int"/></UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1" get="inline" set="null" line="174" static="1"><x path="Int"/></UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1" get="inline" set="null" line="176" static="1"><x path="Int"/></FRAGMENT_SHADER>
		<VERTEX_SHADER public="1" get="inline" set="null" line="177" static="1"><x path="Int"/></VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1" get="inline" set="null" line="178" static="1"><x path="Int"/></MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1" get="inline" set="null" line="179" static="1"><x path="Int"/></MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1" get="inline" set="null" line="180" static="1"><x path="Int"/></MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="181" static="1"><x path="Int"/></MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="182" static="1"><x path="Int"/></MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" line="183" static="1"><x path="Int"/></MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1" get="inline" set="null" line="184" static="1"><x path="Int"/></MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1" get="inline" set="null" line="185" static="1"><x path="Int"/></SHADER_TYPE>
		<DELETE_STATUS public="1" get="inline" set="null" line="186" static="1"><x path="Int"/></DELETE_STATUS>
		<LINK_STATUS public="1" get="inline" set="null" line="187" static="1"><x path="Int"/></LINK_STATUS>
		<VALIDATE_STATUS public="1" get="inline" set="null" line="188" static="1"><x path="Int"/></VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1" get="inline" set="null" line="189" static="1"><x path="Int"/></ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1" get="inline" set="null" line="190" static="1"><x path="Int"/></ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1" get="inline" set="null" line="191" static="1"><x path="Int"/></ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1" get="inline" set="null" line="192" static="1"><x path="Int"/></SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1" get="inline" set="null" line="193" static="1"><x path="Int"/></CURRENT_PROGRAM>
		<NEVER public="1" get="inline" set="null" line="195" static="1"><x path="Int"/></NEVER>
		<LESS public="1" get="inline" set="null" line="196" static="1"><x path="Int"/></LESS>
		<EQUAL public="1" get="inline" set="null" line="197" static="1"><x path="Int"/></EQUAL>
		<LEQUAL public="1" get="inline" set="null" line="198" static="1"><x path="Int"/></LEQUAL>
		<GREATER public="1" get="inline" set="null" line="199" static="1"><x path="Int"/></GREATER>
		<NOTEQUAL public="1" get="inline" set="null" line="200" static="1"><x path="Int"/></NOTEQUAL>
		<GEQUAL public="1" get="inline" set="null" line="201" static="1"><x path="Int"/></GEQUAL>
		<ALWAYS public="1" get="inline" set="null" line="202" static="1"><x path="Int"/></ALWAYS>
		<KEEP public="1" get="inline" set="null" line="204" static="1"><x path="Int"/></KEEP>
		<REPLACE public="1" get="inline" set="null" line="205" static="1"><x path="Int"/></REPLACE>
		<INCR public="1" get="inline" set="null" line="206" static="1"><x path="Int"/></INCR>
		<DECR public="1" get="inline" set="null" line="207" static="1"><x path="Int"/></DECR>
		<INVERT public="1" get="inline" set="null" line="208" static="1"><x path="Int"/></INVERT>
		<INCR_WRAP public="1" get="inline" set="null" line="209" static="1"><x path="Int"/></INCR_WRAP>
		<DECR_WRAP public="1" get="inline" set="null" line="210" static="1"><x path="Int"/></DECR_WRAP>
		<VENDOR public="1" get="inline" set="null" line="212" static="1"><x path="Int"/></VENDOR>
		<RENDERER public="1" get="inline" set="null" line="213" static="1"><x path="Int"/></RENDERER>
		<VERSION public="1" get="inline" set="null" line="214" static="1"><x path="Int"/></VERSION>
		<NEAREST public="1" get="inline" set="null" line="216" static="1"><x path="Int"/></NEAREST>
		<LINEAR public="1" get="inline" set="null" line="217" static="1"><x path="Int"/></LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1" get="inline" set="null" line="219" static="1"><x path="Int"/></NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1" get="inline" set="null" line="220" static="1"><x path="Int"/></LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" get="inline" set="null" line="221" static="1"><x path="Int"/></NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1" get="inline" set="null" line="222" static="1"><x path="Int"/></LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1" get="inline" set="null" line="224" static="1"><x path="Int"/></TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" get="inline" set="null" line="225" static="1"><x path="Int"/></TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1" get="inline" set="null" line="226" static="1"><x path="Int"/></TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" get="inline" set="null" line="227" static="1"><x path="Int"/></TEXTURE_WRAP_T>
		<TEXTURE_2D public="1" get="inline" set="null" line="229" static="1"><x path="Int"/></TEXTURE_2D>
		<TEXTURE public="1" get="inline" set="null" line="230" static="1"><x path="Int"/></TEXTURE>
		<TEXTURE_CUBE_MAP public="1" get="inline" set="null" line="232" static="1"><x path="Int"/></TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1" get="inline" set="null" line="233" static="1"><x path="Int"/></TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1" get="inline" set="null" line="234" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1" get="inline" set="null" line="235" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1" get="inline" set="null" line="236" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1" get="inline" set="null" line="237" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1" get="inline" set="null" line="238" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1" get="inline" set="null" line="239" static="1"><x path="Int"/></TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1" get="inline" set="null" line="240" static="1"><x path="Int"/></MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1" get="inline" set="null" line="242" static="1"><x path="Int"/></TEXTURE0>
		<TEXTURE1 public="1" get="inline" set="null" line="243" static="1"><x path="Int"/></TEXTURE1>
		<TEXTURE2 public="1" get="inline" set="null" line="244" static="1"><x path="Int"/></TEXTURE2>
		<TEXTURE3 public="1" get="inline" set="null" line="245" static="1"><x path="Int"/></TEXTURE3>
		<TEXTURE4 public="1" get="inline" set="null" line="246" static="1"><x path="Int"/></TEXTURE4>
		<TEXTURE5 public="1" get="inline" set="null" line="247" static="1"><x path="Int"/></TEXTURE5>
		<TEXTURE6 public="1" get="inline" set="null" line="248" static="1"><x path="Int"/></TEXTURE6>
		<TEXTURE7 public="1" get="inline" set="null" line="249" static="1"><x path="Int"/></TEXTURE7>
		<TEXTURE8 public="1" get="inline" set="null" line="250" static="1"><x path="Int"/></TEXTURE8>
		<TEXTURE9 public="1" get="inline" set="null" line="251" static="1"><x path="Int"/></TEXTURE9>
		<TEXTURE10 public="1" get="inline" set="null" line="252" static="1"><x path="Int"/></TEXTURE10>
		<TEXTURE11 public="1" get="inline" set="null" line="253" static="1"><x path="Int"/></TEXTURE11>
		<TEXTURE12 public="1" get="inline" set="null" line="254" static="1"><x path="Int"/></TEXTURE12>
		<TEXTURE13 public="1" get="inline" set="null" line="255" static="1"><x path="Int"/></TEXTURE13>
		<TEXTURE14 public="1" get="inline" set="null" line="256" static="1"><x path="Int"/></TEXTURE14>
		<TEXTURE15 public="1" get="inline" set="null" line="257" static="1"><x path="Int"/></TEXTURE15>
		<TEXTURE16 public="1" get="inline" set="null" line="258" static="1"><x path="Int"/></TEXTURE16>
		<TEXTURE17 public="1" get="inline" set="null" line="259" static="1"><x path="Int"/></TEXTURE17>
		<TEXTURE18 public="1" get="inline" set="null" line="260" static="1"><x path="Int"/></TEXTURE18>
		<TEXTURE19 public="1" get="inline" set="null" line="261" static="1"><x path="Int"/></TEXTURE19>
		<TEXTURE20 public="1" get="inline" set="null" line="262" static="1"><x path="Int"/></TEXTURE20>
		<TEXTURE21 public="1" get="inline" set="null" line="263" static="1"><x path="Int"/></TEXTURE21>
		<TEXTURE22 public="1" get="inline" set="null" line="264" static="1"><x path="Int"/></TEXTURE22>
		<TEXTURE23 public="1" get="inline" set="null" line="265" static="1"><x path="Int"/></TEXTURE23>
		<TEXTURE24 public="1" get="inline" set="null" line="266" static="1"><x path="Int"/></TEXTURE24>
		<TEXTURE25 public="1" get="inline" set="null" line="267" static="1"><x path="Int"/></TEXTURE25>
		<TEXTURE26 public="1" get="inline" set="null" line="268" static="1"><x path="Int"/></TEXTURE26>
		<TEXTURE27 public="1" get="inline" set="null" line="269" static="1"><x path="Int"/></TEXTURE27>
		<TEXTURE28 public="1" get="inline" set="null" line="270" static="1"><x path="Int"/></TEXTURE28>
		<TEXTURE29 public="1" get="inline" set="null" line="271" static="1"><x path="Int"/></TEXTURE29>
		<TEXTURE30 public="1" get="inline" set="null" line="272" static="1"><x path="Int"/></TEXTURE30>
		<TEXTURE31 public="1" get="inline" set="null" line="273" static="1"><x path="Int"/></TEXTURE31>
		<ACTIVE_TEXTURE public="1" get="inline" set="null" line="274" static="1"><x path="Int"/></ACTIVE_TEXTURE>
		<REPEAT public="1" get="inline" set="null" line="276" static="1"><x path="Int"/></REPEAT>
		<CLAMP_TO_EDGE public="1" get="inline" set="null" line="277" static="1"><x path="Int"/></CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1" get="inline" set="null" line="278" static="1"><x path="Int"/></MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1" get="inline" set="null" line="280" static="1"><x path="Int"/></FLOAT_VEC2>
		<FLOAT_VEC3 public="1" get="inline" set="null" line="281" static="1"><x path="Int"/></FLOAT_VEC3>
		<FLOAT_VEC4 public="1" get="inline" set="null" line="282" static="1"><x path="Int"/></FLOAT_VEC4>
		<INT_VEC2 public="1" get="inline" set="null" line="283" static="1"><x path="Int"/></INT_VEC2>
		<INT_VEC3 public="1" get="inline" set="null" line="284" static="1"><x path="Int"/></INT_VEC3>
		<INT_VEC4 public="1" get="inline" set="null" line="285" static="1"><x path="Int"/></INT_VEC4>
		<BOOL public="1" get="inline" set="null" line="286" static="1"><x path="Int"/></BOOL>
		<BOOL_VEC2 public="1" get="inline" set="null" line="287" static="1"><x path="Int"/></BOOL_VEC2>
		<BOOL_VEC3 public="1" get="inline" set="null" line="288" static="1"><x path="Int"/></BOOL_VEC3>
		<BOOL_VEC4 public="1" get="inline" set="null" line="289" static="1"><x path="Int"/></BOOL_VEC4>
		<FLOAT_MAT2 public="1" get="inline" set="null" line="290" static="1"><x path="Int"/></FLOAT_MAT2>
		<FLOAT_MAT3 public="1" get="inline" set="null" line="291" static="1"><x path="Int"/></FLOAT_MAT3>
		<FLOAT_MAT4 public="1" get="inline" set="null" line="292" static="1"><x path="Int"/></FLOAT_MAT4>
		<SAMPLER_2D public="1" get="inline" set="null" line="293" static="1"><x path="Int"/></SAMPLER_2D>
		<SAMPLER_CUBE public="1" get="inline" set="null" line="294" static="1"><x path="Int"/></SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1" get="inline" set="null" line="296" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1" get="inline" set="null" line="297" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1" get="inline" set="null" line="298" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1" get="inline" set="null" line="299" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1" get="inline" set="null" line="300" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1" get="inline" set="null" line="301" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" line="302" static="1"><x path="Int"/></VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<VERTEX_PROGRAM_POINT_SIZE public="1" get="inline" set="null" line="304" static="1"><x path="Int"/></VERTEX_PROGRAM_POINT_SIZE>
		<POINT_SPRITE public="1" get="inline" set="null" line="305" static="1"><x path="Int"/></POINT_SPRITE>
		<COMPILE_STATUS public="1" get="inline" set="null" line="307" static="1"><x path="Int"/></COMPILE_STATUS>
		<LOW_FLOAT public="1" get="inline" set="null" line="309" static="1"><x path="Int"/></LOW_FLOAT>
		<MEDIUM_FLOAT public="1" get="inline" set="null" line="310" static="1"><x path="Int"/></MEDIUM_FLOAT>
		<HIGH_FLOAT public="1" get="inline" set="null" line="311" static="1"><x path="Int"/></HIGH_FLOAT>
		<LOW_INT public="1" get="inline" set="null" line="312" static="1"><x path="Int"/></LOW_INT>
		<MEDIUM_INT public="1" get="inline" set="null" line="313" static="1"><x path="Int"/></MEDIUM_INT>
		<HIGH_INT public="1" get="inline" set="null" line="314" static="1"><x path="Int"/></HIGH_INT>
		<FRAMEBUFFER public="1" get="inline" set="null" line="316" static="1"><x path="Int"/></FRAMEBUFFER>
		<RENDERBUFFER public="1" get="inline" set="null" line="317" static="1"><x path="Int"/></RENDERBUFFER>
		<RGBA4 public="1" get="inline" set="null" line="319" static="1"><x path="Int"/></RGBA4>
		<RGB5_A1 public="1" get="inline" set="null" line="320" static="1"><x path="Int"/></RGB5_A1>
		<RGB565 public="1" get="inline" set="null" line="321" static="1"><x path="Int"/></RGB565>
		<DEPTH_COMPONENT16 public="1" get="inline" set="null" line="322" static="1"><x path="Int"/></DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1" get="inline" set="null" line="323" static="1"><x path="Int"/></STENCIL_INDEX>
		<STENCIL_INDEX8 public="1" get="inline" set="null" line="324" static="1"><x path="Int"/></STENCIL_INDEX8>
		<DEPTH_STENCIL public="1" get="inline" set="null" line="325" static="1"><x path="Int"/></DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1" get="inline" set="null" line="327" static="1"><x path="Int"/></RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1" get="inline" set="null" line="328" static="1"><x path="Int"/></RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1" get="inline" set="null" line="329" static="1"><x path="Int"/></RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1" get="inline" set="null" line="330" static="1"><x path="Int"/></RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1" get="inline" set="null" line="331" static="1"><x path="Int"/></RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1" get="inline" set="null" line="332" static="1"><x path="Int"/></RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1" get="inline" set="null" line="333" static="1"><x path="Int"/></RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1" get="inline" set="null" line="334" static="1"><x path="Int"/></RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1" get="inline" set="null" line="335" static="1"><x path="Int"/></RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1" get="inline" set="null" line="337" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1" get="inline" set="null" line="338" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1" get="inline" set="null" line="339" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1" get="inline" set="null" line="340" static="1"><x path="Int"/></FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" line="342" static="1"><x path="Int"/></COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1" get="inline" set="null" line="343" static="1"><x path="Int"/></DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1" get="inline" set="null" line="344" static="1"><x path="Int"/></STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1" get="inline" set="null" line="345" static="1"><x path="Int"/></DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1" get="inline" set="null" line="347" static="1"><x path="Int"/></NONE>
		<FRAMEBUFFER_COMPLETE public="1" get="inline" set="null" line="349" static="1"><x path="Int"/></FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1" get="inline" set="null" line="350" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1" get="inline" set="null" line="351" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1" get="inline" set="null" line="352" static="1"><x path="Int"/></FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1" get="inline" set="null" line="353" static="1"><x path="Int"/></FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1" get="inline" set="null" line="355" static="1"><x path="Int"/></FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1" get="inline" set="null" line="356" static="1"><x path="Int"/></RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1" get="inline" set="null" line="357" static="1"><x path="Int"/></MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1" get="inline" set="null" line="359" static="1"><x path="Int"/></INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1" get="inline" set="null" line="361" static="1"><x path="Int"/></UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1" get="inline" set="null" line="362" static="1"><x path="Int"/></UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1" get="inline" set="null" line="363" static="1"><x path="Int"/></CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1" get="inline" set="null" line="364" static="1"><x path="Int"/></UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1" get="inline" set="null" line="365" static="1"><x path="Int"/></BROWSER_DEFAULT_WEBGL>
		<version public="1" get="accessor" set="null" static="1"><x path="Int"/></version>
		<activeTexture public="1" get="inline" set="null" line="374" static="1"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" get="inline" set="null" line="385" static="1"><f a="program:shader">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" get="inline" set="null" line="397" static="1"><f a="program:index:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBuffer public="1" get="inline" set="null" line="408" static="1"><f a="target:buffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" get="inline" set="null" line="419" static="1"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" get="inline" set="null" line="430" static="1"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" get="inline" set="null" line="441" static="1"><f a="target:texture">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" get="inline" set="null" line="452" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" get="inline" set="null" line="463" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" get="inline" set="null" line="474" static="1"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" get="inline" set="null" line="485" static="1"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" get="inline" set="null" line="496" static="1"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" get="inline" set="null" line="507" static="1"><f a="target:data:usage">
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<bufferSubData public="1" get="inline" set="null" line="520" static="1"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></bufferSubData>
		<checkFramebufferStatus public="1" get="inline" set="null" line="533" static="1"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" get="inline" set="null" line="546" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" get="inline" set="null" line="557" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" get="inline" set="null" line="568" static="1"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" get="inline" set="null" line="579" static="1"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" get="inline" set="null" line="590" static="1"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" get="inline" set="null" line="601" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" get="inline" set="null" line="612" static="1"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" get="inline" set="null" line="625" static="1"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" get="inline" set="null" line="638" static="1"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" get="inline" set="null" line="649" static="1"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" get="inline" set="null" line="660" static="1"><f a=""><c path="lime.graphics.opengl.GLBuffer"/></f></createBuffer>
		<createFramebuffer public="1" get="inline" set="null" line="673" static="1"><f a=""><c path="lime.graphics.opengl.GLFramebuffer"/></f></createFramebuffer>
		<createProgram public="1" get="inline" set="null" line="686" static="1"><f a=""><c path="lime.graphics.opengl.GLProgram"/></f></createProgram>
		<createRenderbuffer public="1" get="inline" set="null" line="699" static="1"><f a=""><c path="lime.graphics.opengl.GLRenderbuffer"/></f></createRenderbuffer>
		<createShader public="1" get="inline" set="null" line="712" static="1"><f a="type">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLShader"/>
</f></createShader>
		<createTexture public="1" get="inline" set="null" line="725" static="1"><f a=""><c path="lime.graphics.opengl.GLTexture"/></f></createTexture>
		<cullFace public="1" get="inline" set="null" line="738" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" get="inline" set="null" line="749" static="1"><f a="buffer">
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" get="inline" set="null" line="761" static="1"><f a="framebuffer">
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" get="inline" set="null" line="773" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" get="inline" set="null" line="785" static="1"><f a="renderbuffer">
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" get="inline" set="null" line="797" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" get="inline" set="null" line="809" static="1"><f a="texture">
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" get="inline" set="null" line="821" static="1"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" get="inline" set="null" line="832" static="1"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" get="inline" set="null" line="843" static="1"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" get="inline" set="null" line="854" static="1"><f a="program:shader">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" get="inline" set="null" line="865" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" get="inline" set="null" line="876" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" get="inline" set="null" line="887" static="1"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" get="inline" set="null" line="898" static="1"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" get="inline" set="null" line="909" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" get="inline" set="null" line="920" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" get="inline" set="null" line="931" static="1"><f a=""><x path="Void"/></f></finish>
		<flush public="1" get="inline" set="null" line="942" static="1"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" get="inline" set="null" line="953" static="1"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" get="inline" set="null" line="964" static="1"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" get="inline" set="null" line="975" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" get="inline" set="null" line="986" static="1"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" get="inline" set="null" line="997" static="1"><f a="program:index">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" get="inline" set="null" line="1010" static="1"><f a="program:index">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" get="inline" set="null" line="1023" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="Array"><c path="lime.graphics.opengl.GLShader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" get="inline" set="null" line="1036" static="1"><f a="program:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" get="inline" set="null" line="1049" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferParameter>
		<getContextAttributes public="1" get="inline" set="null" line="1062" static="1"><f a=""><t path="lime.graphics.opengl.GLContextAttributes"/></f></getContextAttributes>
		<getError public="1" get="inline" set="null" line="1078" static="1"><f a=""><x path="Int"/></f></getError>
		<getExtension public="1" get="inline" set="null" line="1091" static="1"><f a="name">
	<c path="String"/>
	<d/>
</f></getExtension>
		<getFramebufferAttachmentParameter public="1" get="inline" set="null" line="1106" static="1"><f a="target:attachment:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getFramebufferAttachmentParameter>
		<getParameter public="1" get="inline" set="null" line="1119" static="1"><f a="pname">
	<x path="Int"/>
	<d/>
</f></getParameter>
		<getProgramInfoLog public="1" get="inline" set="null" line="1132" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getProgramParameter public="1" get="inline" set="null" line="1145" static="1"><f a="program:pname">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getProgramParameter>
		<getRenderbufferParameter public="1" get="inline" set="null" line="1158" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getRenderbufferParameter>
		<getShaderInfoLog public="1" get="inline" set="null" line="1171" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderParameter public="1" get="inline" set="null" line="1184" static="1"><f a="shader:pname">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" get="inline" set="null" line="1197" static="1"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderSource public="1" get="inline" set="null" line="1210" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
</f></getShaderSource>
		<getSupportedExtensions public="1" get="inline" set="null" line="1223" static="1"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getTexParameter public="1" get="inline" set="null" line="1238" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getTexParameter>
		<getUniform public="1" get="inline" set="null" line="1251" static="1"><f a="program:location">
	<c path="lime.graphics.opengl.GLProgram"/>
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" get="inline" set="null" line="1264" static="1"><f a="program:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
	<t path="lime.graphics.opengl.GLUniformLocation"/>
</f></getUniformLocation>
		<getVertexAttrib public="1" get="inline" set="null" line="1277" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttrib>
		<getVertexAttribOffset public="1" get="inline" set="null" line="1290" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" get="inline" set="null" line="1303" static="1"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" get="inline" set="null" line="1314" static="1"><f a="buffer">
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" get="inline" set="null" line="1331" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" get="inline" set="null" line="1344" static="1"><f a="framebuffer">
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" get="inline" set="null" line="1357" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" get="inline" set="null" line="1370" static="1"><f a="renderbuffer">
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" get="inline" set="null" line="1383" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" get="inline" set="null" line="1396" static="1"><f a="texture">
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" get="inline" set="null" line="1409" static="1"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" get="inline" set="null" line="1420" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></linkProgram>
		<pixelStorei public="1" get="inline" set="null" line="1431" static="1"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" get="inline" set="null" line="1442" static="1"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<readPixels public="1" get="inline" set="null" line="1453" static="1"><f a="x:y:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></readPixels>
		<renderbufferStorage public="1" get="inline" set="null" line="1466" static="1"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" get="inline" set="null" line="1477" static="1"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" get="inline" set="null" line="1488" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" get="inline" set="null" line="1499" static="1"><f a="shader:source">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" get="inline" set="null" line="1510" static="1"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" get="inline" set="null" line="1521" static="1"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" get="inline" set="null" line="1532" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" get="inline" set="null" line="1543" static="1"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" get="inline" set="null" line="1554" static="1"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" get="inline" set="null" line="1565" static="1"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" get="inline" set="null" line="1576" static="1"><f a="target:level:internalformat:width:height:border:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texImage2D>
		<texParameterf public="1" get="inline" set="null" line="1589" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" get="inline" set="null" line="1600" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" get="inline" set="null" line="1611" static="1"><f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texSubImage2D>
		<uniform1f public="1" get="inline" set="null" line="1624" static="1"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" get="inline" set="null" line="1635" static="1"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform1fv>
		<uniform1i public="1" get="inline" set="null" line="1648" static="1"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" get="inline" set="null" line="1659" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform1iv>
		<uniform2f public="1" get="inline" set="null" line="1672" static="1"><f a="location:x:y">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" get="inline" set="null" line="1683" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform2fv>
		<uniform2i public="1" get="inline" set="null" line="1696" static="1"><f a="location:x:y">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" get="inline" set="null" line="1707" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform2iv>
		<uniform3f public="1" get="inline" set="null" line="1720" static="1"><f a="location:x:y:z">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" get="inline" set="null" line="1731" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform3fv>
		<uniform3i public="1" get="inline" set="null" line="1744" static="1"><f a="location:x:y:z">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" get="inline" set="null" line="1755" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform3iv>
		<uniform4f public="1" get="inline" set="null" line="1768" static="1"><f a="location:x:y:z:w">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" get="inline" set="null" line="1779" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform4fv>
		<uniform4i public="1" get="inline" set="null" line="1792" static="1"><f a="location:x:y:z:w">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" get="inline" set="null" line="1803" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<c path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform4iv>
		<uniformMatrix2fv public="1" get="inline" set="null" line="1816" static="1"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix2fv>
		<uniformMatrix3fv public="1" get="inline" set="null" line="1829" static="1"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix3fv>
		<uniformMatrix4fv public="1" get="inline" set="null" line="1842" static="1"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix4fv>
		<useProgram public="1" get="inline" set="null" line="1862" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" get="inline" set="null" line="1873" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" get="inline" set="null" line="1884" static="1"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" get="inline" set="null" line="1895" static="1"><f a="indx:values">
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib1fv>
		<vertexAttrib2f public="1" get="inline" set="null" line="1908" static="1"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" get="inline" set="null" line="1919" static="1"><f a="indx:values">
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib2fv>
		<vertexAttrib3f public="1" get="inline" set="null" line="1932" static="1"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" get="inline" set="null" line="1943" static="1"><f a="indx:values">
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib3fv>
		<vertexAttrib4f public="1" get="inline" set="null" line="1956" static="1"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" get="inline" set="null" line="1967" static="1"><f a="indx:values">
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib4fv>
		<vertexAttribPointer public="1" get="inline" set="null" line="1980" static="1"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" get="inline" set="null" line="1991" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<get_version set="method" line="2002" static="1"><f a=""><x path="Int"/></f></get_version>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<typedef path="lime.graphics.opengl.GLActiveInfo" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLActiveInfo.hx"><a>
	<type><x path="Int"/></type>
	<size><x path="Int"/></size>
	<name><c path="String"/></name>
</a></typedef>
	<class path="lime.graphics.opengl.GLObject" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLObject.hx">
		<id public="1" set="null">
			<d/>
			<haxe_doc>The native GL handle/id. read only</haxe_doc>
		</id>
		<invalidated public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>The invalidated state. read only</haxe_doc>
		</invalidated>
		<valid public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>The valid state. read only</haxe_doc>
		</valid>
		<version><x path="Int"/></version>
		<getType set="method" line="22"><f a=""><c path="String"/></f></getType>
		<invalidate public="1" set="method" line="26"><f a=""><x path="Void"/></f></invalidate>
		<isValid public="1" set="method" line="30"><f a=""><x path="Bool"/></f></isValid>
		<isInvalid public="1" set="method" line="34"><f a=""><x path="Bool"/></f></isInvalid>
		<toString public="1" set="method" line="38"><f a=""><c path="String"/></f></toString>
		<get_invalidated set="method" line="44"><f a=""><x path="Bool"/></f></get_invalidated>
		<get_valid set="method" line="48"><f a=""><x path="Bool"/></f></get_valid>
		<new public="1" set="method" line="15"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.graphics.opengl.GLBuffer" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLBuffer.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.graphics.opengl.GLContextAttributes" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLContextAttributes.hx"><a>
	<stencil><x path="Bool"/></stencil>
	<preserveDrawingBuffer><x path="Bool"/></preserveDrawingBuffer>
	<premultipliedAlpha><x path="Bool"/></premultipliedAlpha>
	<depth><x path="Bool"/></depth>
	<antialias><x path="Bool"/></antialias>
	<alpha><x path="Bool"/></alpha>
</a></typedef>
	<class path="lime.graphics.opengl.GLFramebuffer" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLFramebuffer.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.graphics.opengl.GLProgram" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLProgram.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<shaders public="1"><c path="Array"><c path="lime.graphics.opengl.GLShader"/></c></shaders>
		<attach public="1" set="method" line="18"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></attach>
		<getShaders public="1" set="method" line="25"><f a=""><c path="Array"><c path="lime.graphics.opengl.GLShader"/></c></f></getShaders>
		<getType set="method" line="32" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="10"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.graphics.opengl.GLRenderbuffer" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLRenderbuffer.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.graphics.opengl.GLShader" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLShader.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.graphics.opengl.GLShaderPrecisionFormat" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLShaderPrecisionFormat.hx"><a>
	<rangeMin><x path="Int"/></rangeMin>
	<rangeMax><x path="Int"/></rangeMax>
	<precision><x path="Int"/></precision>
</a></typedef>
	<class path="lime.graphics.opengl.GLTexture" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLTexture.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.graphics.opengl.GLUniformLocation" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/opengl/GLUniformLocation.hx"><x path="Int"/></typedef>
	<class path="lime.graphics.utils.ImageCanvasUtil" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/utils/ImageCanvasUtil.hx">
		<colorTransform public="1" set="method" line="23" static="1"><f a="image:rect:colorMatrix">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<convertToCanvas public="1" set="method" line="33" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></convertToCanvas>
		<convertToData public="1" set="method" line="53" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></convertToData>
		<copyChannel public="1" set="method" line="70" static="1"><f a="image:sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="82" static="1"><f a="image:sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v="::::null:null:false">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Vector2"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyPixels>
		<createCanvas public="1" set="method" line="119" static="1"><f a="image:width:height">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createCanvas>
		<createImageData public="1" set="method" line="151" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></createImageData>
		<fillRect public="1" set="method" line="176" static="1"><f a="image:rect:color">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="203" static="1"><f a="image:x:y:color">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></floodFill>
		<getPixel public="1" set="method" line="213" static="1"><f a="image:x:y">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="223" static="1"><f a="image:x:y">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="233" static="1"><f a="image:rect">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.utils.ByteArray"/>
</f></getPixels>
		<resize public="1" set="method" line="243" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setPixel public="1" set="method" line="264" static="1"><f a="image:x:y:color">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="274" static="1"><f a="image:x:y:color">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="284" static="1"><f a="image:rect:byteArray">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<sync public="1" set="method" line="294" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></sync>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="lime.graphics.utils.ImageDataUtil" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/graphics/utils/ImageDataUtil.hx">
		<__alpha16 static="1"><x path="haxe.ds.Vector"><x path="Int"/></x></__alpha16>
		<__clamp static="1"><x path="haxe.ds.Vector"><x path="Int"/></x></__clamp>
		<colorTransform public="1" set="method" line="48" static="1"><f a="image:rect:colorMatrix">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<copyChannel public="1" set="method" line="89" static="1"><f a="image:sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="149" static="1"><f a="image:sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v="::::null:null:false">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Vector2"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyPixels>
		<fillRect public="1" set="method" line="223" static="1"><f a="image:rect:color">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="286" static="1"><f a="image:x:y:color">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></floodFill>
		<getPixel public="1" set="method" line="353" static="1"><f a="image:x:y">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="373" static="1"><f a="image:x:y">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="393" static="1"><f a="image:rect">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.utils.ByteArray"/>
</f></getPixels>
		<multiplyAlpha public="1" set="method" line="436" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></multiplyAlpha>
		<resize public="1" set="method" line="461" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<resizeBuffer public="1" set="method" line="524" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resizeBuffer>
		<setPixel public="1" set="method" line="554" static="1"><f a="image:x:y:color">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="569" static="1"><f a="image:x:y:color">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="597" static="1"><f a="image:rect:byteArray">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<unmultiplyAlpha public="1" set="method" line="627" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></unmultiplyAlpha>
	</class>
	<abstract path="lime.math.ColorMatrix" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/ColorMatrix.hx">
		<from><icast><c path="lime.utils.Float32Array"/></icast></from>
		<this><c path="lime.utils.Float32Array"/></this>
		<to><icast><c path="lime.utils.Float32Array"/></icast></to>
		<impl><class path="lime.math._ColorMatrix.ColorMatrix_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/ColorMatrix.hx" private="1" module="lime.math.ColorMatrix">
	<__identity line="14" static="1"><c path="Array"><x path="Float"/></c></__identity>
	<alphaMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaMultiplier>
	<alphaOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaOffset>
	<blueMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueMultiplier>
	<blueOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueOffset>
	<color public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</color>
	<greenMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenMultiplier>
	<greenOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenOffset>
	<redMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redMultiplier>
	<redOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redOffset>
	<_new public="1" set="method" line="27" static="1">
		<f a="?data" v="null">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.utils.Float32Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<clone public="1" set="method" line="42" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
		</f>
		<meta><m n=":impl"/></meta>
	</clone>
	<concat public="1" set="method" line="49" static="1">
		<f a="this:second">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</concat>
	<copyFrom public="1" set="method" line="59" static="1">
		<f a="this:other">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyFrom>
	<identity public="1" set="method" line="66" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</identity>
	<__toFlashColorTransform set="method" line="92" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<d/>
		</f>
		<meta><m n=":impl"/></meta>
	</__toFlashColorTransform>
	<get_alphaMultiplier get="inline" set="null" line="110" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaMultiplier>
	<set_alphaMultiplier get="inline" set="null" line="117" static="1">
		<f a="this:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaMultiplier>
	<get_alphaOffset get="inline" set="null" line="125" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaOffset>
	<set_alphaOffset get="inline" set="null" line="132" static="1">
		<f a="this:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaOffset>
	<get_blueMultiplier get="inline" set="null" line="140" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueMultiplier>
	<set_blueMultiplier get="inline" set="null" line="147" static="1">
		<f a="this:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueMultiplier>
	<get_blueOffset get="inline" set="null" line="155" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueOffset>
	<set_blueOffset get="inline" set="null" line="162" static="1">
		<f a="this:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueOffset>
	<get_color set="method" line="170" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_color>
	<set_color set="method" line="177" static="1">
		<f a="this:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_color>
	<get_greenMultiplier get="inline" set="null" line="192" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenMultiplier>
	<set_greenMultiplier get="inline" set="null" line="199" static="1">
		<f a="this:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenMultiplier>
	<get_greenOffset get="inline" set="null" line="207" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenOffset>
	<set_greenOffset get="inline" set="null" line="214" static="1">
		<f a="this:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenOffset>
	<get_redMultiplier get="inline" set="null" line="222" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redMultiplier>
	<set_redMultiplier get="inline" set="null" line="229" static="1">
		<f a="this:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redMultiplier>
	<get_redOffset get="inline" set="null" line="237" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redOffset>
	<set_redOffset get="inline" set="null" line="244" static="1">
		<f a="this:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redOffset>
	<get public="1" set="method" line="252" static="1">
		<f a="this:index">
			<c path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" set="method" line="259" static="1">
		<f a="this:index:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
</class></impl>
	</abstract>
	<class path="lime.math._ColorMatrix.ColorMatrix_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/ColorMatrix.hx" private="1" module="lime.math.ColorMatrix">
		<__identity line="14" static="1"><c path="Array"><x path="Float"/></c></__identity>
		<alphaMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaMultiplier>
		<alphaOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaOffset>
		<blueMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueMultiplier>
		<blueOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueOffset>
		<color public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</color>
		<greenMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenMultiplier>
		<greenOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenOffset>
		<redMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redMultiplier>
		<redOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redOffset>
		<_new public="1" set="method" line="27" static="1">
			<f a="?data" v="null">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.utils.Float32Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<clone public="1" set="method" line="42" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
			</f>
			<meta><m n=":impl"/></meta>
		</clone>
		<concat public="1" set="method" line="49" static="1">
			<f a="this:second">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</concat>
		<copyFrom public="1" set="method" line="59" static="1">
			<f a="this:other">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyFrom>
		<identity public="1" set="method" line="66" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</identity>
		<__toFlashColorTransform set="method" line="92" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<d/>
			</f>
			<meta><m n=":impl"/></meta>
		</__toFlashColorTransform>
		<get_alphaMultiplier get="inline" set="null" line="110" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaMultiplier>
		<set_alphaMultiplier get="inline" set="null" line="117" static="1">
			<f a="this:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaMultiplier>
		<get_alphaOffset get="inline" set="null" line="125" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaOffset>
		<set_alphaOffset get="inline" set="null" line="132" static="1">
			<f a="this:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaOffset>
		<get_blueMultiplier get="inline" set="null" line="140" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueMultiplier>
		<set_blueMultiplier get="inline" set="null" line="147" static="1">
			<f a="this:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueMultiplier>
		<get_blueOffset get="inline" set="null" line="155" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueOffset>
		<set_blueOffset get="inline" set="null" line="162" static="1">
			<f a="this:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueOffset>
		<get_color set="method" line="170" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_color>
		<set_color set="method" line="177" static="1">
			<f a="this:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_color>
		<get_greenMultiplier get="inline" set="null" line="192" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenMultiplier>
		<set_greenMultiplier get="inline" set="null" line="199" static="1">
			<f a="this:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenMultiplier>
		<get_greenOffset get="inline" set="null" line="207" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenOffset>
		<set_greenOffset get="inline" set="null" line="214" static="1">
			<f a="this:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenOffset>
		<get_redMultiplier get="inline" set="null" line="222" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redMultiplier>
		<set_redMultiplier get="inline" set="null" line="229" static="1">
			<f a="this:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redMultiplier>
		<get_redOffset get="inline" set="null" line="237" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redOffset>
		<set_redOffset get="inline" set="null" line="244" static="1">
			<f a="this:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redOffset>
		<get public="1" set="method" line="252" static="1">
			<f a="this:index">
				<c path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" set="method" line="259" static="1">
			<f a="this:index:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
	</class>
	<class path="lime.math.Matrix3" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/Matrix3.hx">
		<__identity line="14" static="1"><c path="lime.math.Matrix3"/></__identity>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<clone public="1" get="inline" set="null" line="29"><f a=""><c path="lime.math.Matrix3"/></f></clone>
		<concat public="1" set="method" line="36"><f a="m">
	<c path="lime.math.Matrix3"/>
	<x path="Void"/>
</f></concat>
		<copyColumnFrom public="1" set="method" line="55"><f a="column:vector4">
	<x path="Int"/>
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1" set="method" line="81"><f a="column:vector4">
	<x path="Int"/>
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1" set="method" line="110"><f a="sourceMatrix3">
	<c path="lime.math.Matrix3"/>
	<x path="Void"/>
</f></copyFrom>
		<copyRowFrom public="1" set="method" line="122"><f a="row:vector4">
	<x path="Int"/>
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1" set="method" line="148"><f a="row:vector4">
	<x path="Int"/>
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyRowTo>
		<createBox public="1" set="method" line="175"><f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createBox>
		<createGradientBox public="1" set="method" line="186"><f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createGradientBox>
		<equals public="1" set="method" line="215"><f a="Matrix3">
	<a>
		<ty set="null"><x path="Float"/></ty>
		<tx set="null"><x path="Float"/></tx>
		<d set="null"><x path="Float"/></d>
		<c set="null"><x path="Float"/></c>
		<b set="null"><x path="Float"/></b>
		<a set="null"><x path="Float"/></a>
	</a>
	<x path="Bool"/>
</f></equals>
		<deltaTransformVector2 public="1" set="method" line="222"><f a="Vector2">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></deltaTransformVector2>
		<identity public="1" set="method" line="229"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method" line="241"><f a=""><c path="lime.math.Matrix3"/></f></invert>
		<mult public="1" get="inline" set="null" line="273"><f a="m">
	<c path="lime.math.Matrix3"/>
	<c path="lime.math.Matrix3"/>
</f></mult>
		<rotate public="1" set="method" line="282"><f a="theta">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method" line="318"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setRotation get="inline" set="null" line="341"><f a="theta:?scale" v=":1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRotation>
		<setTo public="1" set="method" line="353"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<to3DString public="1" get="inline" set="null" line="365"><f a="?roundPixels" v="false">
	<x path="Bool"/>
	<c path="String"/>
</f></to3DString>
		<toMozString public="1" get="inline" set="null" line="388"><f a=""><c path="String"/></f></toMozString>
		<toString public="1" get="inline" set="null" line="395"><f a=""><c path="String"/></f></toString>
		<transformVector2 public="1" set="method" line="402"><f a="pos">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></transformVector2>
		<translate public="1" set="method" line="409"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<__cleanValues get="inline" set="null" line="419"><f a=""><x path="Void"/></f></__cleanValues>
		<__transformX public="1" get="inline" set="null" line="431"><f a="pos">
	<c path="lime.math.Vector2"/>
	<x path="Float"/>
</f></__transformX>
		<__transformY public="1" get="inline" set="null" line="438"><f a="pos">
	<c path="lime.math.Vector2"/>
	<x path="Float"/>
</f></__transformY>
		<__translateTransformed public="1" get="inline" set="null" line="445"><f a="pos">
	<c path="lime.math.Vector2"/>
	<x path="Void"/>
</f></__translateTransformed>
		<new public="1" set="method" line="17"><f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.math.Matrix4" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/Matrix4.hx">
		<from><icast><c path="lime.utils.Float32Array"/></icast></from>
		<this><c path="lime.utils.Float32Array"/></this>
		<to><icast><c path="lime.utils.Float32Array"/></icast></to>
		<impl><class path="lime.math._Matrix4.Matrix4_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/Matrix4.hx" private="1" module="lime.math.Matrix4">
	<__identity line="10" static="1"><c path="Array"><x path="Float"/></c></__identity>
	<determinant public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</determinant>
	<position public="1" get="accessor" set="accessor" static="1">
		<c path="lime.math.Vector4"/>
		<meta><m n=":impl"/></meta>
	</position>
	<_new public="1" set="method" line="16" static="1">
		<f a="?data" v="null">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.utils.Float32Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<append public="1" set="method" line="31" static="1">
		<f a="this:lhs">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</append>
	<appendRotation public="1" set="method" line="65" static="1">
		<f a="this:degrees:axis:?pivotPoint" v=":::null">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</appendRotation>
	<appendScale public="1" set="method" line="81" static="1">
		<f a="this:xScale:yScale:zScale">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</appendScale>
	<appendTranslation public="1" set="method" line="88" static="1">
		<f a="this:x:y:z">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</appendTranslation>
	<clone public="1" set="method" line="97" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta><m n=":impl"/></meta>
	</clone>
	<copyColumnFrom public="1" set="method" line="104" static="1">
		<f a="this:column:vector">
			<c path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyColumnFrom>
	<copyColumnTo public="1" set="method" line="136" static="1">
		<f a="this:column:vector">
			<c path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyColumnTo>
	<copyFrom public="1" set="method" line="168" static="1">
		<f a="this:other">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyFrom>
	<copythisFrom public="1" set="method" line="174" static="1">
		<f a="this:array:?index:?transposeValues" v="::0:false">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.utils.Float32Array"/>
			<x path="UInt"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copythisFrom>
	<copythisTo public="1" set="method" line="189" static="1">
		<f a="this:array:?index:?transposeValues" v="::0:false">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.utils.Float32Array"/>
			<x path="UInt"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copythisTo>
	<copyRowFrom public="1" set="method" line="204" static="1">
		<f a="this:row:vector">
			<c path="lime.utils.Float32Array"/>
			<x path="UInt"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyRowFrom>
	<create2D public="1" set="method" line="240" static="1"><f a="x:y:?scale:?rotation" v="::1:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></create2D>
	<createABCD public="1" set="method" line="256" static="1"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></createABCD>
	<createOrtho public="1" set="method" line="268" static="1"><f a="x0:x1:y0:y1:zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></createOrtho>
	<copyRowTo public="1" set="method" line="284" static="1">
		<f a="this:row:vector">
			<c path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyRowTo>
	<copyToMatrix4 public="1" set="method" line="320" static="1">
		<f a="this:other">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyToMatrix4>
	<deltaTransformVector public="1" set="method" line="426" static="1">
		<f a="this:v">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector4 objects.</haxe_doc>
	</deltaTransformVector>
	<identity public="1" set="method" line="439" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</identity>
	<interpolate public="1" set="method" line="461" static="1"><f a="thisMat:toMat:percent">
	<x path="lime.math.Matrix4"/>
	<x path="lime.math.Matrix4"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></interpolate>
	<interpolateTo public="1" set="method" line="476" static="1">
		<f a="this:toMat:percent">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</interpolateTo>
	<invert public="1" set="method" line="487" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</invert>
	<pointAt public="1" set="method" line="525" static="1">
		<f a="this:pos:?at:?up" v="::null:null">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</pointAt>
	<prepend public="1" set="method" line="592" static="1">
		<f a="this:rhs">
			<c path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prepend>
	<prependRotation public="1" set="method" line="626" static="1">
		<f a="this:degrees:axis:?pivotPoint" v=":::null">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prependRotation>
	<prependScale public="1" set="method" line="642" static="1">
		<f a="this:xScale:yScale:zScale">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prependScale>
	<prependTranslation public="1" set="method" line="649" static="1">
		<f a="this:x:y:z">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prependTranslation>
	<transformVector public="1" set="method" line="742" static="1">
		<f a="this:v">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformVector>
	<transformVectors public="1" set="method" line="755" static="1">
		<f a="this:ain:aout">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.utils.Float32Array"/>
			<c path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformVectors>
	<transpose public="1" set="method" line="774" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transpose>
	<getAxisRotation set="method" line="792" static="1"><f a="x:y:z:degrees">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></getAxisRotation>
	<get_determinant public="1" set="method" line="831" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_determinant>
	<get_position public="1" set="method" line="843" static="1">
		<f a="this">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_position>
	<set_position public="1" set="method" line="850" static="1">
		<f a="this:val">
			<c path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_position>
	<get public="1" set="method" line="860" static="1">
		<f a="this:index">
			<c path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" set="method" line="867" static="1">
		<f a="this:index:value">
			<c path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
</class></impl>
	</abstract>
	<class path="lime.math._Matrix4.Matrix4_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/Matrix4.hx" private="1" module="lime.math.Matrix4">
		<__identity line="10" static="1"><c path="Array"><x path="Float"/></c></__identity>
		<determinant public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</determinant>
		<position public="1" get="accessor" set="accessor" static="1">
			<c path="lime.math.Vector4"/>
			<meta><m n=":impl"/></meta>
		</position>
		<_new public="1" set="method" line="16" static="1">
			<f a="?data" v="null">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.utils.Float32Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<append public="1" set="method" line="31" static="1">
			<f a="this:lhs">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</append>
		<appendRotation public="1" set="method" line="65" static="1">
			<f a="this:degrees:axis:?pivotPoint" v=":::null">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</appendRotation>
		<appendScale public="1" set="method" line="81" static="1">
			<f a="this:xScale:yScale:zScale">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</appendScale>
		<appendTranslation public="1" set="method" line="88" static="1">
			<f a="this:x:y:z">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</appendTranslation>
		<clone public="1" set="method" line="97" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta><m n=":impl"/></meta>
		</clone>
		<copyColumnFrom public="1" set="method" line="104" static="1">
			<f a="this:column:vector">
				<c path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method" line="136" static="1">
			<f a="this:column:vector">
				<c path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyColumnTo>
		<copyFrom public="1" set="method" line="168" static="1">
			<f a="this:other">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyFrom>
		<copythisFrom public="1" set="method" line="174" static="1">
			<f a="this:array:?index:?transposeValues" v="::0:false">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.utils.Float32Array"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copythisFrom>
		<copythisTo public="1" set="method" line="189" static="1">
			<f a="this:array:?index:?transposeValues" v="::0:false">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.utils.Float32Array"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copythisTo>
		<copyRowFrom public="1" set="method" line="204" static="1">
			<f a="this:row:vector">
				<c path="lime.utils.Float32Array"/>
				<x path="UInt"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyRowFrom>
		<create2D public="1" set="method" line="240" static="1"><f a="x:y:?scale:?rotation" v="::1:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></create2D>
		<createABCD public="1" set="method" line="256" static="1"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></createABCD>
		<createOrtho public="1" set="method" line="268" static="1"><f a="x0:x1:y0:y1:zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></createOrtho>
		<copyRowTo public="1" set="method" line="284" static="1">
			<f a="this:row:vector">
				<c path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyRowTo>
		<copyToMatrix4 public="1" set="method" line="320" static="1">
			<f a="this:other">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyToMatrix4>
		<deltaTransformVector public="1" set="method" line="426" static="1">
			<f a="this:v">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector4 objects.</haxe_doc>
		</deltaTransformVector>
		<identity public="1" set="method" line="439" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</identity>
		<interpolate public="1" set="method" line="461" static="1"><f a="thisMat:toMat:percent">
	<x path="lime.math.Matrix4"/>
	<x path="lime.math.Matrix4"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></interpolate>
		<interpolateTo public="1" set="method" line="476" static="1">
			<f a="this:toMat:percent">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</interpolateTo>
		<invert public="1" set="method" line="487" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</invert>
		<pointAt public="1" set="method" line="525" static="1">
			<f a="this:pos:?at:?up" v="::null:null">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</pointAt>
		<prepend public="1" set="method" line="592" static="1">
			<f a="this:rhs">
				<c path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prepend>
		<prependRotation public="1" set="method" line="626" static="1">
			<f a="this:degrees:axis:?pivotPoint" v=":::null">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prependRotation>
		<prependScale public="1" set="method" line="642" static="1">
			<f a="this:xScale:yScale:zScale">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prependScale>
		<prependTranslation public="1" set="method" line="649" static="1">
			<f a="this:x:y:z">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prependTranslation>
		<transformVector public="1" set="method" line="742" static="1">
			<f a="this:v">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformVector>
		<transformVectors public="1" set="method" line="755" static="1">
			<f a="this:ain:aout">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.utils.Float32Array"/>
				<c path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformVectors>
		<transpose public="1" set="method" line="774" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transpose>
		<getAxisRotation set="method" line="792" static="1"><f a="x:y:z:degrees">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></getAxisRotation>
		<get_determinant public="1" set="method" line="831" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_determinant>
		<get_position public="1" set="method" line="843" static="1">
			<f a="this">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_position>
		<set_position public="1" set="method" line="850" static="1">
			<f a="this:val">
				<c path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_position>
		<get public="1" set="method" line="860" static="1">
			<f a="this:index">
				<c path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" set="method" line="867" static="1">
			<f a="this:index:value">
				<c path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
	</class>
	<class path="lime.math.Rectangle" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/Rectangle.hx">
		<bottom public="1" get="accessor" set="accessor"><x path="Float"/></bottom>
		<bottomRight public="1" get="accessor" set="accessor"><c path="lime.math.Vector2"/></bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor"><x path="Float"/></left>
		<right public="1" get="accessor" set="accessor"><x path="Float"/></right>
		<size public="1" get="accessor" set="accessor"><c path="lime.math.Vector2"/></size>
		<top public="1" get="accessor" set="accessor"><x path="Float"/></top>
		<topLeft public="1" get="accessor" set="accessor"><c path="lime.math.Vector2"/></topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="35"><f a=""><c path="lime.math.Rectangle"/></f></clone>
		<contains public="1" set="method" line="42"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method" line="49"><f a="point">
	<c path="lime.math.Vector2"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method" line="56"><f a="rect">
	<c path="lime.math.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<copyFrom public="1" set="method" line="71"><f a="sourceRect">
	<c path="lime.math.Rectangle"/>
	<x path="Void"/>
</f></copyFrom>
		<equals public="1" set="method" line="81"><f a="toCompare">
	<c path="lime.math.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<inflate public="1" set="method" line="88"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method" line="96"><f a="point">
	<c path="lime.math.Vector2"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method" line="103"><f a="toIntersect">
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method" line="128"><f a="toIntersect">
	<c path="lime.math.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method" line="147"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method" line="154"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method" line="162"><f a="point">
	<c path="lime.math.Vector2"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method" line="170"><f a=""><x path="Void"/></f></setEmpty>
		<setTo public="1" set="method" line="177"><f a="xa:ya:widtha:heighta">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<transform public="1" set="method" line="187"><f a="m">
	<c path="lime.math.Matrix3"/>
	<c path="lime.math.Rectangle"/>
</f></transform>
		<union public="1" set="method" line="223"><f a="toUnion">
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Rectangle"/>
</f></union>
		<__contract public="1" set="method" line="245"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__contract>
		<__expand public="1" set="method" line="264"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__expand>
		<__toFlashRectangle set="method" line="287"><f a=""><d/></f></__toFlashRectangle>
		<get_bottom set="method" line="305"><f a=""><x path="Float"/></f></get_bottom>
		<set_bottom set="method" line="306"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bottom>
		<get_bottomRight set="method" line="307"><f a=""><c path="lime.math.Vector2"/></f></get_bottomRight>
		<set_bottomRight set="method" line="308"><f a="p">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></set_bottomRight>
		<get_left set="method" line="309"><f a=""><x path="Float"/></f></get_left>
		<set_left set="method" line="310"><f a="l">
	<x path="Float"/>
	<x path="Float"/>
</f></set_left>
		<get_right set="method" line="311"><f a=""><x path="Float"/></f></get_right>
		<set_right set="method" line="312"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_right>
		<get_size set="method" line="313"><f a=""><c path="lime.math.Vector2"/></f></get_size>
		<set_size set="method" line="314"><f a="p">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></set_size>
		<get_top set="method" line="315"><f a=""><x path="Float"/></f></get_top>
		<set_top set="method" line="316"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></set_top>
		<get_topLeft set="method" line="317"><f a=""><c path="lime.math.Vector2"/></f></get_topLeft>
		<set_topLeft set="method" line="318"><f a="p">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></set_topLeft>
		<new public="1" set="method" line="25"><f a="?x:?y:?width:?height" v="0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.math.Vector2" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/Vector2.hx">
		<distance public="1" set="method" line="39" static="1"><f a="pt1:pt2">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" line="55" static="1"><f a="pt1:pt2:f">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
	<x path="Float"/>
	<c path="lime.math.Vector2"/>
</f></interpolate>
		<polar public="1" set="method" line="87" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.math.Vector2"/>
</f></polar>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method" line="25"><f a="v">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></add>
		<clone public="1" set="method" line="32"><f a=""><c path="lime.math.Vector2"/></f></clone>
		<equals public="1" set="method" line="48"><f a="toCompare">
	<c path="lime.math.Vector2"/>
	<x path="Bool"/>
</f></equals>
		<normalize public="1" set="method" line="62"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method" line="79"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setTo public="1" get="inline" set="null" line="94"><f a="xa:ya">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<subtract public="1" set="method" line="101"><f a="v">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></subtract>
		<__toFlashPoint set="method" line="108"><f a=""><d/></f></__toFlashPoint>
		<get_length set="method" line="126"><f a=""><x path="Float"/></f></get_length>
		<new public="1" set="method" line="17"><f a="?x:?y" v="0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.math.Vector4" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/math/Vector4.hx">
		<X_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.math.Vector4"/></X_AXIS>
		<Y_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.math.Vector4"/></Y_AXIS>
		<Z_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.math.Vector4"/></Z_AXIS>
		<angleBetween public="1" get="inline" set="null" line="36" static="1"><f a="a:b">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" get="inline" set="null" line="80" static="1"><f a="pt1:pt2">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
	<x path="Float"/>
</f></distance>
		<get_X_AXIS public="1" get="inline" set="null" line="209" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_X_AXIS>
		<get_Y_AXIS public="1" get="inline" set="null" line="216" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_Y_AXIS>
		<get_Z_AXIS public="1" get="inline" set="null" line="223" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_Z_AXIS>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<lengthSquared public="1" get="accessor" set="null"><x path="Float"/></lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" get="inline" set="null" line="29"><f a="a">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
</f></add>
		<clone public="1" get="inline" set="null" line="48"><f a=""><c path="lime.math.Vector4"/></f></clone>
		<copyFrom public="1" get="inline" set="null" line="55"><f a="sourceVector4">
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyFrom>
		<crossProduct public="1" get="inline" set="null" line="64"><f a="a">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
</f></crossProduct>
		<decrementBy public="1" get="inline" set="null" line="71"><f a="a">
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" get="inline" set="null" line="91"><f a="a">
	<c path="lime.math.Vector4"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" get="inline" set="null" line="98"><f a="toCompare:?allFour" v=":false">
	<c path="lime.math.Vector4"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<incrementBy public="1" get="inline" set="null" line="105"><f a="a">
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" get="inline" set="null" line="114"><f a="toCompare:tolerance:?allFour" v="::false">
	<c path="lime.math.Vector4"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<negate public="1" get="inline" set="null" line="121"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" get="inline" set="null" line="130"><f a=""><x path="Float"/></f></normalize>
		<project public="1" get="inline" set="null" line="147"><f a=""><x path="Void"/></f></project>
		<scaleBy public="1" get="inline" set="null" line="156"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<setTo public="1" get="inline" set="null" line="165"><f a="xa:ya:za">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<subtract public="1" get="inline" set="null" line="174"><f a="a">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
</f></subtract>
		<toString public="1" get="inline" set="null" line="181"><f a=""><c path="String"/></f></toString>
		<get_length public="1" get="inline" set="null" line="195"><f a=""><x path="Float"/></f></get_length>
		<get_lengthSquared public="1" get="inline" set="null" line="202"><f a=""><x path="Float"/></f></get_lengthSquared>
		<new public="1" set="method" line="19"><f a="?x:?y:?z:?w" v="0.f:0.f:0.f:0.f">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.ui.KeyCode" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/KeyCode.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._KeyCode.KeyCode_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/KeyCode.hx" private="1" module="lime.ui.KeyCode">
	<UNKNOWN public="1" get="inline" set="null" line="7" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNKNOWN>
	<BACKSPACE public="1" get="inline" set="null" line="8" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" line="9" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAB>
	<RETURN public="1" get="inline" set="null" line="10" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN>
	<ESCAPE public="1" get="inline" set="null" line="11" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ESCAPE>
	<SPACE public="1" get="inline" set="null" line="12" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPACE>
	<EXCLAMATION public="1" get="inline" set="null" line="13" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXCLAMATION>
	<QUOTE public="1" get="inline" set="null" line="14" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUOTE>
	<HASH public="1" get="inline" set="null" line="15" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HASH>
	<DOLLAR public="1" get="inline" set="null" line="16" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOLLAR>
	<PERCENT public="1" get="inline" set="null" line="17" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERCENT>
	<AMPERSAND public="1" get="inline" set="null" line="18" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AMPERSAND>
	<SINGLE_QUOTE public="1" get="inline" set="null" line="19" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SINGLE_QUOTE>
	<LEFT_PARENTHESIS public="1" get="inline" set="null" line="20" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_PARENTHESIS>
	<RIGHT_PARENTHESIS public="1" get="inline" set="null" line="21" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_PARENTHESIS>
	<ASTERISK public="1" get="inline" set="null" line="22" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ASTERISK>
	<PLUS public="1" get="inline" set="null" line="23" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLUS>
	<COMMA public="1" get="inline" set="null" line="24" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMMA>
	<MINUS public="1" get="inline" set="null" line="25" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MINUS>
	<PERIOD public="1" get="inline" set="null" line="26" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" line="27" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLASH>
	<NUMBER_0 public="1" get="inline" set="null" line="28" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_0>
	<NUMBER_1 public="1" get="inline" set="null" line="29" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_1>
	<NUMBER_2 public="1" get="inline" set="null" line="30" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_2>
	<NUMBER_3 public="1" get="inline" set="null" line="31" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_3>
	<NUMBER_4 public="1" get="inline" set="null" line="32" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_4>
	<NUMBER_5 public="1" get="inline" set="null" line="33" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_5>
	<NUMBER_6 public="1" get="inline" set="null" line="34" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_6>
	<NUMBER_7 public="1" get="inline" set="null" line="35" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_7>
	<NUMBER_8 public="1" get="inline" set="null" line="36" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_8>
	<NUMBER_9 public="1" get="inline" set="null" line="37" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_9>
	<COLON public="1" get="inline" set="null" line="38" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COLON>
	<SEMICOLON public="1" get="inline" set="null" line="39" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEMICOLON>
	<LESS_THAN public="1" get="inline" set="null" line="40" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN>
	<EQUALS public="1" get="inline" set="null" line="41" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUALS>
	<GREATER_THAN public="1" get="inline" set="null" line="42" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN>
	<QUESTION public="1" get="inline" set="null" line="43" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUESTION>
	<AT public="1" get="inline" set="null" line="44" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AT>
	<LEFT_BRACKET public="1" get="inline" set="null" line="45" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_BRACKET>
	<BACKSLASH public="1" get="inline" set="null" line="46" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSLASH>
	<RIGHT_BRACKET public="1" get="inline" set="null" line="47" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_BRACKET>
	<CARET public="1" get="inline" set="null" line="48" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CARET>
	<UNDERSCORE public="1" get="inline" set="null" line="49" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDERSCORE>
	<GRAVE public="1" get="inline" set="null" line="50" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE>
	<A public="1" get="inline" set="null" line="51" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" line="52" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<C public="1" get="inline" set="null" line="53" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</C>
	<D public="1" get="inline" set="null" line="54" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</D>
	<E public="1" get="inline" set="null" line="55" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</E>
	<F public="1" get="inline" set="null" line="56" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F>
	<G public="1" get="inline" set="null" line="57" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<H public="1" get="inline" set="null" line="58" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</H>
	<I public="1" get="inline" set="null" line="59" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</I>
	<J public="1" get="inline" set="null" line="60" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</J>
	<K public="1" get="inline" set="null" line="61" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</K>
	<L public="1" get="inline" set="null" line="62" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</L>
	<M public="1" get="inline" set="null" line="63" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</M>
	<N public="1" get="inline" set="null" line="64" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</N>
	<O public="1" get="inline" set="null" line="65" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</O>
	<P public="1" get="inline" set="null" line="66" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</P>
	<Q public="1" get="inline" set="null" line="67" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Q>
	<R public="1" get="inline" set="null" line="68" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<S public="1" get="inline" set="null" line="69" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</S>
	<T public="1" get="inline" set="null" line="70" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</T>
	<U public="1" get="inline" set="null" line="71" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</U>
	<V public="1" get="inline" set="null" line="72" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V>
	<W public="1" get="inline" set="null" line="73" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</W>
	<X public="1" get="inline" set="null" line="74" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" line="75" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<Z public="1" get="inline" set="null" line="76" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Z>
	<DELETE public="1" get="inline" set="null" line="77" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<CAPS_LOCK public="1" get="inline" set="null" line="78" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAPS_LOCK>
	<F1 public="1" get="inline" set="null" line="79" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" line="80" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" line="81" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" line="82" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" line="83" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" line="84" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" line="85" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" line="86" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" line="87" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" line="88" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" line="89" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" line="90" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F12>
	<PRINT_SCREEN public="1" get="inline" set="null" line="91" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRINT_SCREEN>
	<SCROLL_LOCK public="1" get="inline" set="null" line="92" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SCROLL_LOCK>
	<PAUSE public="1" get="inline" set="null" line="93" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" line="94" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" line="95" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HOME>
	<PAGE_UP public="1" get="inline" set="null" line="96" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_UP>
	<END public="1" get="inline" set="null" line="97" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</END>
	<PAGE_DOWN public="1" get="inline" set="null" line="98" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_DOWN>
	<RIGHT public="1" get="inline" set="null" line="99" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" line="100" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" line="101" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" line="102" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UP>
	<NUM_LOCK public="1" get="inline" set="null" line="103" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUM_LOCK>
	<NUMPAD_DIVIDE public="1" get="inline" set="null" line="104" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DIVIDE>
	<NUMPAD_MULTIPLY public="1" get="inline" set="null" line="105" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MULTIPLY>
	<NUMPAD_MINUS public="1" get="inline" set="null" line="106" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MINUS>
	<NUMPAD_PLUS public="1" get="inline" set="null" line="107" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS>
	<NUMPAD_ENTER public="1" get="inline" set="null" line="108" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_ENTER>
	<NUMPAD_1 public="1" get="inline" set="null" line="109" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_1>
	<NUMPAD_2 public="1" get="inline" set="null" line="110" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_2>
	<NUMPAD_3 public="1" get="inline" set="null" line="111" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_3>
	<NUMPAD_4 public="1" get="inline" set="null" line="112" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_4>
	<NUMPAD_5 public="1" get="inline" set="null" line="113" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_5>
	<NUMPAD_6 public="1" get="inline" set="null" line="114" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_6>
	<NUMPAD_7 public="1" get="inline" set="null" line="115" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_7>
	<NUMPAD_8 public="1" get="inline" set="null" line="116" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_8>
	<NUMPAD_9 public="1" get="inline" set="null" line="117" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_9>
	<NUMPAD_0 public="1" get="inline" set="null" line="118" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_0>
	<NUMPAD_PERIOD public="1" get="inline" set="null" line="119" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERIOD>
	<APPLICATION public="1" get="inline" set="null" line="120" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" line="121" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POWER>
	<NUMPAD_EQUALS public="1" get="inline" set="null" line="122" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EQUALS>
	<F13 public="1" get="inline" set="null" line="123" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" line="124" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" line="125" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" line="126" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" line="127" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" line="128" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" line="129" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" line="130" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" line="131" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" line="132" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" line="133" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" line="134" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" line="135" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" line="136" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" line="137" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" line="138" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" line="139" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" line="140" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" line="141" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" line="142" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" line="143" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" line="144" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" line="145" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" line="146" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUTE>
	<VOLUME_UP public="1" get="inline" set="null" line="147" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_UP>
	<VOLUME_DOWN public="1" get="inline" set="null" line="148" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_DOWN>
	<NUMPAD_COMMA public="1" get="inline" set="null" line="149" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COMMA>
	<ALT_ERASE public="1" get="inline" set="null" line="151" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALT_ERASE>
	<SYSTEM_REQUEST public="1" get="inline" set="null" line="152" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SYSTEM_REQUEST>
	<CANCEL public="1" get="inline" set="null" line="153" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" line="154" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" line="155" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" line="156" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" line="157" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" line="158" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" line="159" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPER>
	<CLEAR_AGAIN public="1" get="inline" set="null" line="160" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR_AGAIN>
	<CRSEL public="1" get="inline" set="null" line="161" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" line="162" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXSEL>
	<NUMPAD_00 public="1" get="inline" set="null" line="163" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_00>
	<NUMPAD_000 public="1" get="inline" set="null" line="164" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_000>
	<THOUSAND_SEPARATOR public="1" get="inline" set="null" line="165" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</THOUSAND_SEPARATOR>
	<DECIMAL_SEPARATOR public="1" get="inline" set="null" line="166" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DECIMAL_SEPARATOR>
	<CURRENCY_UNIT public="1" get="inline" set="null" line="167" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_UNIT>
	<CURRENCY_SUBUNIT public="1" get="inline" set="null" line="168" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_SUBUNIT>
	<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" line="169" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_PARENTHESIS>
	<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" line="170" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_PARENTHESIS>
	<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" line="171" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_BRACE>
	<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" line="172" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_BRACE>
	<NUMPAD_TAB public="1" get="inline" set="null" line="173" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_TAB>
	<NUMPAD_BACKSPACE public="1" get="inline" set="null" line="174" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BACKSPACE>
	<NUMPAD_A public="1" get="inline" set="null" line="175" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_A>
	<NUMPAD_B public="1" get="inline" set="null" line="176" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_B>
	<NUMPAD_C public="1" get="inline" set="null" line="177" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_C>
	<NUMPAD_D public="1" get="inline" set="null" line="178" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_D>
	<NUMPAD_E public="1" get="inline" set="null" line="179" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_E>
	<NUMPAD_F public="1" get="inline" set="null" line="180" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_F>
	<NUMPAD_XOR public="1" get="inline" set="null" line="181" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_XOR>
	<NUMPAD_POWER public="1" get="inline" set="null" line="182" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_POWER>
	<NUMPAD_PERCENT public="1" get="inline" set="null" line="183" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERCENT>
	<NUMPAD_LESS_THAN public="1" get="inline" set="null" line="184" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LESS_THAN>
	<NUMPAD_GREATER_THAN public="1" get="inline" set="null" line="185" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_GREATER_THAN>
	<NUMPAD_AMPERSAND public="1" get="inline" set="null" line="186" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AMPERSAND>
	<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" line="187" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_AMPERSAND>
	<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" line="188" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_VERTICAL_BAR>
	<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" line="189" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_VERTICAL_BAR>
	<NUMPAD_COLON public="1" get="inline" set="null" line="190" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COLON>
	<NUMPAD_HASH public="1" get="inline" set="null" line="191" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HASH>
	<NUMPAD_SPACE public="1" get="inline" set="null" line="192" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_SPACE>
	<NUMPAD_AT public="1" get="inline" set="null" line="193" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AT>
	<NUMPAD_EXCLAMATION public="1" get="inline" set="null" line="194" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EXCLAMATION>
	<NUMPAD_MEM_STORE public="1" get="inline" set="null" line="195" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_STORE>
	<NUMPAD_MEM_RECALL public="1" get="inline" set="null" line="196" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_RECALL>
	<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" line="197" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_CLEAR>
	<NUMPAD_MEM_ADD public="1" get="inline" set="null" line="198" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_ADD>
	<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" line="199" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_SUBTRACT>
	<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" line="200" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_MULTIPLY>
	<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" line="201" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_DIVIDE>
	<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" line="202" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS_MINUS>
	<NUMPAD_CLEAR public="1" get="inline" set="null" line="203" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR>
	<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" line="204" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR_ENTRY>
	<NUMPAD_BINARY public="1" get="inline" set="null" line="205" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BINARY>
	<NUMPAD_OCTAL public="1" get="inline" set="null" line="206" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_OCTAL>
	<NUMPAD_DECIMAL public="1" get="inline" set="null" line="207" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DECIMAL>
	<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" line="208" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HEXADECIMAL>
	<LEFT_CTRL public="1" get="inline" set="null" line="209" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_CTRL>
	<LEFT_SHIFT public="1" get="inline" set="null" line="210" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_SHIFT>
	<LEFT_ALT public="1" get="inline" set="null" line="211" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_ALT>
	<LEFT_META public="1" get="inline" set="null" line="212" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_META>
	<RIGHT_CTRL public="1" get="inline" set="null" line="213" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_CTRL>
	<RIGHT_SHIFT public="1" get="inline" set="null" line="214" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_SHIFT>
	<RIGHT_ALT public="1" get="inline" set="null" line="215" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_ALT>
	<RIGHT_META public="1" get="inline" set="null" line="216" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_META>
	<MODE public="1" get="inline" set="null" line="217" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MODE>
	<AUDIO_NEXT public="1" get="inline" set="null" line="218" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_NEXT>
	<AUDIO_PREVIOUS public="1" get="inline" set="null" line="219" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PREVIOUS>
	<AUDIO_STOP public="1" get="inline" set="null" line="220" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_STOP>
	<AUDIO_PLAY public="1" get="inline" set="null" line="221" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PLAY>
	<AUDIO_MUTE public="1" get="inline" set="null" line="222" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_MUTE>
	<MEDIA_SELECT public="1" get="inline" set="null" line="223" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIA_SELECT>
	<WWW public="1" get="inline" set="null" line="224" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" line="225" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" line="226" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" line="227" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMPUTER>
	<APP_CONTROL_SEARCH public="1" get="inline" set="null" line="228" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_SEARCH>
	<APP_CONTROL_HOME public="1" get="inline" set="null" line="229" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_HOME>
	<APP_CONTROL_BACK public="1" get="inline" set="null" line="230" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BACK>
	<APP_CONTROL_FORWARD public="1" get="inline" set="null" line="231" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_FORWARD>
	<APP_CONTROL_STOP public="1" get="inline" set="null" line="232" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_STOP>
	<APP_CONTROL_REFRESH public="1" get="inline" set="null" line="233" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_REFRESH>
	<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" line="234" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BOOKMARKS>
	<BRIGHTNESS_DOWN public="1" get="inline" set="null" line="235" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_DOWN>
	<BRIGHTNESS_UP public="1" get="inline" set="null" line="236" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_UP>
	<DISPLAY_SWITCH public="1" get="inline" set="null" line="237" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DISPLAY_SWITCH>
	<BACKLIGHT_TOGGLE public="1" get="inline" set="null" line="238" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_TOGGLE>
	<BACKLIGHT_DOWN public="1" get="inline" set="null" line="239" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_DOWN>
	<BACKLIGHT_UP public="1" get="inline" set="null" line="240" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_UP>
	<EJECT public="1" get="inline" set="null" line="241" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" line="242" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLEEP>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._KeyCode.KeyCode_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/KeyCode.hx" private="1" module="lime.ui.KeyCode">
		<UNKNOWN public="1" get="inline" set="null" line="7" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNKNOWN>
		<BACKSPACE public="1" get="inline" set="null" line="8" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" line="9" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAB>
		<RETURN public="1" get="inline" set="null" line="10" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN>
		<ESCAPE public="1" get="inline" set="null" line="11" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ESCAPE>
		<SPACE public="1" get="inline" set="null" line="12" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPACE>
		<EXCLAMATION public="1" get="inline" set="null" line="13" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXCLAMATION>
		<QUOTE public="1" get="inline" set="null" line="14" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUOTE>
		<HASH public="1" get="inline" set="null" line="15" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HASH>
		<DOLLAR public="1" get="inline" set="null" line="16" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOLLAR>
		<PERCENT public="1" get="inline" set="null" line="17" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERCENT>
		<AMPERSAND public="1" get="inline" set="null" line="18" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AMPERSAND>
		<SINGLE_QUOTE public="1" get="inline" set="null" line="19" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SINGLE_QUOTE>
		<LEFT_PARENTHESIS public="1" get="inline" set="null" line="20" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_PARENTHESIS>
		<RIGHT_PARENTHESIS public="1" get="inline" set="null" line="21" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_PARENTHESIS>
		<ASTERISK public="1" get="inline" set="null" line="22" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ASTERISK>
		<PLUS public="1" get="inline" set="null" line="23" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLUS>
		<COMMA public="1" get="inline" set="null" line="24" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMMA>
		<MINUS public="1" get="inline" set="null" line="25" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MINUS>
		<PERIOD public="1" get="inline" set="null" line="26" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" line="27" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLASH>
		<NUMBER_0 public="1" get="inline" set="null" line="28" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" line="29" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" line="30" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" line="31" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" line="32" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" line="33" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" line="34" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" line="35" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" line="36" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" line="37" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_9>
		<COLON public="1" get="inline" set="null" line="38" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COLON>
		<SEMICOLON public="1" get="inline" set="null" line="39" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEMICOLON>
		<LESS_THAN public="1" get="inline" set="null" line="40" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN>
		<EQUALS public="1" get="inline" set="null" line="41" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUALS>
		<GREATER_THAN public="1" get="inline" set="null" line="42" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN>
		<QUESTION public="1" get="inline" set="null" line="43" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUESTION>
		<AT public="1" get="inline" set="null" line="44" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AT>
		<LEFT_BRACKET public="1" get="inline" set="null" line="45" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_BRACKET>
		<BACKSLASH public="1" get="inline" set="null" line="46" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSLASH>
		<RIGHT_BRACKET public="1" get="inline" set="null" line="47" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_BRACKET>
		<CARET public="1" get="inline" set="null" line="48" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CARET>
		<UNDERSCORE public="1" get="inline" set="null" line="49" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDERSCORE>
		<GRAVE public="1" get="inline" set="null" line="50" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE>
		<A public="1" get="inline" set="null" line="51" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" line="52" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<C public="1" get="inline" set="null" line="53" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</C>
		<D public="1" get="inline" set="null" line="54" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</D>
		<E public="1" get="inline" set="null" line="55" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</E>
		<F public="1" get="inline" set="null" line="56" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F>
		<G public="1" get="inline" set="null" line="57" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<H public="1" get="inline" set="null" line="58" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</H>
		<I public="1" get="inline" set="null" line="59" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</I>
		<J public="1" get="inline" set="null" line="60" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</J>
		<K public="1" get="inline" set="null" line="61" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</K>
		<L public="1" get="inline" set="null" line="62" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</L>
		<M public="1" get="inline" set="null" line="63" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</M>
		<N public="1" get="inline" set="null" line="64" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</N>
		<O public="1" get="inline" set="null" line="65" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</O>
		<P public="1" get="inline" set="null" line="66" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</P>
		<Q public="1" get="inline" set="null" line="67" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Q>
		<R public="1" get="inline" set="null" line="68" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<S public="1" get="inline" set="null" line="69" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</S>
		<T public="1" get="inline" set="null" line="70" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</T>
		<U public="1" get="inline" set="null" line="71" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</U>
		<V public="1" get="inline" set="null" line="72" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V>
		<W public="1" get="inline" set="null" line="73" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</W>
		<X public="1" get="inline" set="null" line="74" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" line="75" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<Z public="1" get="inline" set="null" line="76" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Z>
		<DELETE public="1" get="inline" set="null" line="77" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<CAPS_LOCK public="1" get="inline" set="null" line="78" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAPS_LOCK>
		<F1 public="1" get="inline" set="null" line="79" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" line="80" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" line="81" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" line="82" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" line="83" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" line="84" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" line="85" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" line="86" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" line="87" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" line="88" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" line="89" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" line="90" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F12>
		<PRINT_SCREEN public="1" get="inline" set="null" line="91" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRINT_SCREEN>
		<SCROLL_LOCK public="1" get="inline" set="null" line="92" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SCROLL_LOCK>
		<PAUSE public="1" get="inline" set="null" line="93" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" line="94" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" line="95" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HOME>
		<PAGE_UP public="1" get="inline" set="null" line="96" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_UP>
		<END public="1" get="inline" set="null" line="97" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</END>
		<PAGE_DOWN public="1" get="inline" set="null" line="98" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_DOWN>
		<RIGHT public="1" get="inline" set="null" line="99" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" line="100" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" line="101" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" line="102" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UP>
		<NUM_LOCK public="1" get="inline" set="null" line="103" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUM_LOCK>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" line="104" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DIVIDE>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" line="105" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MULTIPLY>
		<NUMPAD_MINUS public="1" get="inline" set="null" line="106" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MINUS>
		<NUMPAD_PLUS public="1" get="inline" set="null" line="107" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS>
		<NUMPAD_ENTER public="1" get="inline" set="null" line="108" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_ENTER>
		<NUMPAD_1 public="1" get="inline" set="null" line="109" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" line="110" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" line="111" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" line="112" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" line="113" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" line="114" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" line="115" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" line="116" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" line="117" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_9>
		<NUMPAD_0 public="1" get="inline" set="null" line="118" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_0>
		<NUMPAD_PERIOD public="1" get="inline" set="null" line="119" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERIOD>
		<APPLICATION public="1" get="inline" set="null" line="120" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" line="121" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POWER>
		<NUMPAD_EQUALS public="1" get="inline" set="null" line="122" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EQUALS>
		<F13 public="1" get="inline" set="null" line="123" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" line="124" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" line="125" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" line="126" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" line="127" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" line="128" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" line="129" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" line="130" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" line="131" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" line="132" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" line="133" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" line="134" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" line="135" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" line="136" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" line="137" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" line="138" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" line="139" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" line="140" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" line="141" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" line="142" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" line="143" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" line="144" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" line="145" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" line="146" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUTE>
		<VOLUME_UP public="1" get="inline" set="null" line="147" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_UP>
		<VOLUME_DOWN public="1" get="inline" set="null" line="148" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_DOWN>
		<NUMPAD_COMMA public="1" get="inline" set="null" line="149" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COMMA>
		<ALT_ERASE public="1" get="inline" set="null" line="151" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALT_ERASE>
		<SYSTEM_REQUEST public="1" get="inline" set="null" line="152" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SYSTEM_REQUEST>
		<CANCEL public="1" get="inline" set="null" line="153" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" line="154" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" line="155" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" line="156" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" line="157" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" line="158" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" line="159" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPER>
		<CLEAR_AGAIN public="1" get="inline" set="null" line="160" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR_AGAIN>
		<CRSEL public="1" get="inline" set="null" line="161" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" line="162" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXSEL>
		<NUMPAD_00 public="1" get="inline" set="null" line="163" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_00>
		<NUMPAD_000 public="1" get="inline" set="null" line="164" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_000>
		<THOUSAND_SEPARATOR public="1" get="inline" set="null" line="165" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</THOUSAND_SEPARATOR>
		<DECIMAL_SEPARATOR public="1" get="inline" set="null" line="166" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DECIMAL_SEPARATOR>
		<CURRENCY_UNIT public="1" get="inline" set="null" line="167" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_UNIT>
		<CURRENCY_SUBUNIT public="1" get="inline" set="null" line="168" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_SUBUNIT>
		<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" line="169" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_PARENTHESIS>
		<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" line="170" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_PARENTHESIS>
		<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" line="171" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_BRACE>
		<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" line="172" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_BRACE>
		<NUMPAD_TAB public="1" get="inline" set="null" line="173" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_TAB>
		<NUMPAD_BACKSPACE public="1" get="inline" set="null" line="174" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BACKSPACE>
		<NUMPAD_A public="1" get="inline" set="null" line="175" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_A>
		<NUMPAD_B public="1" get="inline" set="null" line="176" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_B>
		<NUMPAD_C public="1" get="inline" set="null" line="177" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_C>
		<NUMPAD_D public="1" get="inline" set="null" line="178" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_D>
		<NUMPAD_E public="1" get="inline" set="null" line="179" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_E>
		<NUMPAD_F public="1" get="inline" set="null" line="180" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_F>
		<NUMPAD_XOR public="1" get="inline" set="null" line="181" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_XOR>
		<NUMPAD_POWER public="1" get="inline" set="null" line="182" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_POWER>
		<NUMPAD_PERCENT public="1" get="inline" set="null" line="183" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERCENT>
		<NUMPAD_LESS_THAN public="1" get="inline" set="null" line="184" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LESS_THAN>
		<NUMPAD_GREATER_THAN public="1" get="inline" set="null" line="185" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_GREATER_THAN>
		<NUMPAD_AMPERSAND public="1" get="inline" set="null" line="186" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AMPERSAND>
		<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" line="187" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_AMPERSAND>
		<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" line="188" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_VERTICAL_BAR>
		<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" line="189" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_VERTICAL_BAR>
		<NUMPAD_COLON public="1" get="inline" set="null" line="190" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COLON>
		<NUMPAD_HASH public="1" get="inline" set="null" line="191" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HASH>
		<NUMPAD_SPACE public="1" get="inline" set="null" line="192" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_SPACE>
		<NUMPAD_AT public="1" get="inline" set="null" line="193" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AT>
		<NUMPAD_EXCLAMATION public="1" get="inline" set="null" line="194" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EXCLAMATION>
		<NUMPAD_MEM_STORE public="1" get="inline" set="null" line="195" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_STORE>
		<NUMPAD_MEM_RECALL public="1" get="inline" set="null" line="196" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_RECALL>
		<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" line="197" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_CLEAR>
		<NUMPAD_MEM_ADD public="1" get="inline" set="null" line="198" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_ADD>
		<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" line="199" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_SUBTRACT>
		<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" line="200" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_MULTIPLY>
		<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" line="201" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_DIVIDE>
		<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" line="202" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS_MINUS>
		<NUMPAD_CLEAR public="1" get="inline" set="null" line="203" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR>
		<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" line="204" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR_ENTRY>
		<NUMPAD_BINARY public="1" get="inline" set="null" line="205" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BINARY>
		<NUMPAD_OCTAL public="1" get="inline" set="null" line="206" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_OCTAL>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" line="207" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DECIMAL>
		<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" line="208" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HEXADECIMAL>
		<LEFT_CTRL public="1" get="inline" set="null" line="209" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_CTRL>
		<LEFT_SHIFT public="1" get="inline" set="null" line="210" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_SHIFT>
		<LEFT_ALT public="1" get="inline" set="null" line="211" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_ALT>
		<LEFT_META public="1" get="inline" set="null" line="212" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_META>
		<RIGHT_CTRL public="1" get="inline" set="null" line="213" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_CTRL>
		<RIGHT_SHIFT public="1" get="inline" set="null" line="214" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_SHIFT>
		<RIGHT_ALT public="1" get="inline" set="null" line="215" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_ALT>
		<RIGHT_META public="1" get="inline" set="null" line="216" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_META>
		<MODE public="1" get="inline" set="null" line="217" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MODE>
		<AUDIO_NEXT public="1" get="inline" set="null" line="218" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_NEXT>
		<AUDIO_PREVIOUS public="1" get="inline" set="null" line="219" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PREVIOUS>
		<AUDIO_STOP public="1" get="inline" set="null" line="220" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_STOP>
		<AUDIO_PLAY public="1" get="inline" set="null" line="221" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PLAY>
		<AUDIO_MUTE public="1" get="inline" set="null" line="222" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_MUTE>
		<MEDIA_SELECT public="1" get="inline" set="null" line="223" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIA_SELECT>
		<WWW public="1" get="inline" set="null" line="224" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" line="225" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" line="226" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" line="227" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMPUTER>
		<APP_CONTROL_SEARCH public="1" get="inline" set="null" line="228" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_SEARCH>
		<APP_CONTROL_HOME public="1" get="inline" set="null" line="229" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_HOME>
		<APP_CONTROL_BACK public="1" get="inline" set="null" line="230" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BACK>
		<APP_CONTROL_FORWARD public="1" get="inline" set="null" line="231" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_FORWARD>
		<APP_CONTROL_STOP public="1" get="inline" set="null" line="232" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_STOP>
		<APP_CONTROL_REFRESH public="1" get="inline" set="null" line="233" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_REFRESH>
		<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" line="234" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BOOKMARKS>
		<BRIGHTNESS_DOWN public="1" get="inline" set="null" line="235" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_DOWN>
		<BRIGHTNESS_UP public="1" get="inline" set="null" line="236" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_UP>
		<DISPLAY_SWITCH public="1" get="inline" set="null" line="237" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DISPLAY_SWITCH>
		<BACKLIGHT_TOGGLE public="1" get="inline" set="null" line="238" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_TOGGLE>
		<BACKLIGHT_DOWN public="1" get="inline" set="null" line="239" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_DOWN>
		<BACKLIGHT_UP public="1" get="inline" set="null" line="240" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_UP>
		<EJECT public="1" get="inline" set="null" line="241" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" line="242" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLEEP>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.ui.KeyEventManager" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/KeyEventManager.hx">
		<onKeyDown public="1" line="17" static="1"><c path="lime.app.Event"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></onKeyDown>
		<onKeyUp public="1" line="18" static="1"><c path="lime.app.Event"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></onKeyUp>
		<eventInfo static="1"><c path="lime.ui._KeyEventManager.KeyEventInfo"/></eventInfo>
		<create public="1" set="method" line="23" static="1"><f a=""><x path="Void"/></f></create>
		<convertKeyCode set="method" line="46" static="1"><f a="keyCode">
	<x path="Int"/>
	<x path="lime.ui.KeyCode"/>
</f></convertKeyCode>
		<handleEvent set="method" line="148" static="1"><f a=""><x path="Void"/></f></handleEvent>
		<lime_key_event_manager_register line="203" static="1"><f a=":">
	<f a=""><x path="Void"/></f>
	<c path="lime.ui._KeyEventManager.KeyEventInfo"/>
	<unknown/>
</f></lime_key_event_manager_register>
	</class>
	<class path="lime.ui._KeyEventManager.KeyEventInfo" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/KeyEventManager.hx" private="1" module="lime.ui.KeyEventManager">
		<keyCode public="1"><x path="Int"/></keyCode>
		<modifier public="1"><x path="Int"/></modifier>
		<type public="1"><x path="lime.ui._KeyEventManager.KeyEventType"/></type>
		<clone public="1" set="method" line="227"><f a=""><c path="lime.ui._KeyEventManager.KeyEventInfo"/></f></clone>
		<new public="1" set="method" line="218"><f a="?type:?keyCode:?modifier" v="null:0:0">
	<x path="lime.ui._KeyEventManager.KeyEventType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.ui._KeyEventManager.KeyEventType" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/KeyEventManager.hx" private="1" module="lime.ui.KeyEventManager">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._KeyEventManager.KeyEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/KeyEventManager.hx" private="1" module="lime.ui.KeyEventManager">
	<KEY_DOWN public="1" get="inline" set="null" line="239" static="1">
		<x path="lime.ui._KeyEventManager.KeyEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KEY_DOWN>
	<KEY_UP public="1" get="inline" set="null" line="240" static="1">
		<x path="lime.ui._KeyEventManager.KeyEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KEY_UP>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._KeyEventManager.KeyEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/KeyEventManager.hx" private="1" module="lime.ui.KeyEventManager">
		<KEY_DOWN public="1" get="inline" set="null" line="239" static="1">
			<x path="lime.ui._KeyEventManager.KeyEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KEY_DOWN>
		<KEY_UP public="1" get="inline" set="null" line="240" static="1">
			<x path="lime.ui._KeyEventManager.KeyEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KEY_UP>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.ui.MouseEventManager" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/MouseEventManager.hx">
		<onMouseDown public="1" line="18" static="1"><c path="lime.app.Event"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></onMouseDown>
		<onMouseMove public="1" line="19" static="1"><c path="lime.app.Event"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></onMouseMove>
		<onMouseUp public="1" line="20" static="1"><c path="lime.app.Event"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></onMouseUp>
		<onMouseWheel public="1" line="21" static="1"><c path="lime.app.Event"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></onMouseWheel>
		<created static="1"><x path="Bool"/></created>
		<eventInfo static="1"><c path="lime.ui._MouseEventManager.MouseEventInfo"/></eventInfo>
		<create public="1" set="method" line="31" static="1"><f a=""><x path="Void"/></f></create>
		<handleEvent set="method" line="42" static="1"><f a=""><x path="Void"/></f></handleEvent>
		<registerWindow set="method" line="158" static="1"><f a="_window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></registerWindow>
		<lime_mouse_event_manager_register line="197" static="1"><f a=":">
	<f a=""><x path="Void"/></f>
	<c path="lime.ui._MouseEventManager.MouseEventInfo"/>
	<unknown/>
</f></lime_mouse_event_manager_register>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="lime.ui._MouseEventManager.MouseEventInfo" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/MouseEventManager.hx" private="1" module="lime.ui.MouseEventManager">
		<button public="1"><x path="Int"/></button>
		<type public="1"><x path="lime.ui._MouseEventManager.MouseEventType"/></type>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="224"><f a=""><c path="lime.ui._MouseEventManager.MouseEventInfo"/></f></clone>
		<new public="1" set="method" line="214"><f a="?type:?x:?y:?button" v="null:0:0:0">
	<x path="lime.ui._MouseEventManager.MouseEventType"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.ui._MouseEventManager.MouseEventType" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/MouseEventManager.hx" private="1" module="lime.ui.MouseEventManager">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._MouseEventManager.MouseEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/MouseEventManager.hx" private="1" module="lime.ui.MouseEventManager">
	<MOUSE_DOWN public="1" get="inline" set="null" line="236" static="1">
		<x path="lime.ui._MouseEventManager.MouseEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOUSE_DOWN>
	<MOUSE_UP public="1" get="inline" set="null" line="237" static="1">
		<x path="lime.ui._MouseEventManager.MouseEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOUSE_UP>
	<MOUSE_MOVE public="1" get="inline" set="null" line="238" static="1">
		<x path="lime.ui._MouseEventManager.MouseEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOUSE_MOVE>
	<MOUSE_WHEEL public="1" get="inline" set="null" line="239" static="1">
		<x path="lime.ui._MouseEventManager.MouseEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOUSE_WHEEL>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._MouseEventManager.MouseEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/MouseEventManager.hx" private="1" module="lime.ui.MouseEventManager">
		<MOUSE_DOWN public="1" get="inline" set="null" line="236" static="1">
			<x path="lime.ui._MouseEventManager.MouseEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOUSE_DOWN>
		<MOUSE_UP public="1" get="inline" set="null" line="237" static="1">
			<x path="lime.ui._MouseEventManager.MouseEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOUSE_UP>
		<MOUSE_MOVE public="1" get="inline" set="null" line="238" static="1">
			<x path="lime.ui._MouseEventManager.MouseEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOUSE_MOVE>
		<MOUSE_WHEEL public="1" get="inline" set="null" line="239" static="1">
			<x path="lime.ui._MouseEventManager.MouseEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOUSE_WHEEL>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.ui.TouchEventManager" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/TouchEventManager.hx">
		<onTouchEnd public="1" line="17" static="1"><c path="lime.app.Event"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></onTouchEnd>
		<onTouchMove public="1" line="18" static="1"><c path="lime.app.Event"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></onTouchMove>
		<onTouchStart public="1" line="19" static="1"><c path="lime.app.Event"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></onTouchStart>
		<eventInfo static="1"><c path="lime.ui._TouchEventManager.TouchEventInfo"/></eventInfo>
		<create public="1" set="method" line="28" static="1"><f a=""><x path="Void"/></f></create>
		<handleEvent set="method" line="39" static="1"><f a=""><x path="Void"/></f></handleEvent>
		<registerWindow set="method" line="112" static="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></registerWindow>
		<lime_touch_event_manager_register line="135" static="1"><f a=":">
	<f a=""><x path="Void"/></f>
	<c path="lime.ui._TouchEventManager.TouchEventInfo"/>
	<unknown/>
</f></lime_touch_event_manager_register>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<class path="lime.ui._TouchEventManager.TouchEventInfo" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/TouchEventManager.hx" private="1" module="lime.ui.TouchEventManager">
		<id public="1"><x path="Int"/></id>
		<type public="1"><x path="lime.ui._TouchEventManager.TouchEventType"/></type>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="161"><f a=""><c path="lime.ui._TouchEventManager.TouchEventInfo"/></f></clone>
		<new public="1" set="method" line="151"><f a="?type:?x:?y:?id" v="null:0:0:0">
	<x path="lime.ui._TouchEventManager.TouchEventType"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="lime.ui._TouchEventManager.TouchEventType" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/TouchEventManager.hx" private="1" module="lime.ui.TouchEventManager">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._TouchEventManager.TouchEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/TouchEventManager.hx" private="1" module="lime.ui.TouchEventManager">
	<TOUCH_START public="1" get="inline" set="null" line="173" static="1">
		<x path="lime.ui._TouchEventManager.TouchEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOUCH_START>
	<TOUCH_END public="1" get="inline" set="null" line="174" static="1">
		<x path="lime.ui._TouchEventManager.TouchEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOUCH_END>
	<TOUCH_MOVE public="1" get="inline" set="null" line="175" static="1">
		<x path="lime.ui._TouchEventManager.TouchEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOUCH_MOVE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._TouchEventManager.TouchEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/TouchEventManager.hx" private="1" module="lime.ui.TouchEventManager">
		<TOUCH_START public="1" get="inline" set="null" line="173" static="1">
			<x path="lime.ui._TouchEventManager.TouchEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOUCH_START>
		<TOUCH_END public="1" get="inline" set="null" line="174" static="1">
			<x path="lime.ui._TouchEventManager.TouchEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOUCH_END>
		<TOUCH_MOVE public="1" get="inline" set="null" line="175" static="1">
			<x path="lime.ui._TouchEventManager.TouchEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOUCH_MOVE>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="lime.ui._Window.WindowEventInfo" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/Window.hx" private="1" module="lime.ui.Window">
		<height public="1"><x path="Int"/></height>
		<type public="1"><x path="lime.ui._Window.WindowEventType"/></type>
		<width public="1"><x path="Int"/></width>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<clone public="1" set="method" line="463"><f a=""><c path="lime.ui._Window.WindowEventInfo"/></f></clone>
		<new public="1" set="method" line="452"><f a="?type:?width:?height:?x:?y" v="null:0:0:0:0">
	<x path="lime.ui._Window.WindowEventType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.ui.Window" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/Window.hx">
		<onWindowActivate public="1" line="26" static="1"><c path="lime.app.Event"><f a=""><x path="Void"/></f></c></onWindowActivate>
		<onWindowClose public="1" line="27" static="1"><c path="lime.app.Event"><f a=""><x path="Void"/></f></c></onWindowClose>
		<onWindowDeactivate public="1" line="28" static="1"><c path="lime.app.Event"><f a=""><x path="Void"/></f></c></onWindowDeactivate>
		<onWindowFocusIn public="1" line="29" static="1"><c path="lime.app.Event"><f a=""><x path="Void"/></f></c></onWindowFocusIn>
		<onWindowFocusOut public="1" line="30" static="1"><c path="lime.app.Event"><f a=""><x path="Void"/></f></c></onWindowFocusOut>
		<onWindowMove public="1" line="31" static="1"><c path="lime.app.Event"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></onWindowMove>
		<onWindowResize public="1" line="32" static="1"><c path="lime.app.Event"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></onWindowResize>
		<eventInfo line="34" static="1"><c path="lime.ui._Window.WindowEventInfo"/></eventInfo>
		<registered static="1"><x path="Bool"/></registered>
		<lime_window_create line="432" static="1"><f a="::::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<unknown/>
</f></lime_window_create>
		<lime_window_event_manager_register line="433" static="1"><f a=":">
	<f a=""><x path="Void"/></f>
	<c path="lime.ui._Window.WindowEventInfo"/>
	<unknown/>
</f></lime_window_event_manager_register>
		<lime_window_move line="434" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_window_move>
		<lime_window_resize line="435" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></lime_window_resize>
		<currentRenderer public="1"><c path="lime.graphics.Renderer"/></currentRenderer>
		<config public="1"><t path="lime.app.Config"/></config>
		<fullscreen public="1"><x path="Bool"/></fullscreen>
		<height public="1"><x path="Int"/></height>
		<width public="1"><x path="Int"/></width>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<handle public="1"><d/></handle>
		<setHeight><x path="Int"/></setHeight>
		<setWidth><x path="Int"/></setWidth>
		<create public="1" set="method" line="77"><f a="application">
	<c path="lime.app.Application"/>
	<x path="Void"/>
</f></create>
		<dispatch set="method" line="227"><f a=""><x path="Void"/></f></dispatch>
		<move public="1" set="method" line="410"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></move>
		<resize public="1" set="method" line="419"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method" line="60"><f a="config">
	<t path="lime.app.Config"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<abstract path="lime.ui._Window.WindowFlags" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/Window.hx" private="1" module="lime.ui.Window">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._Window.WindowFlags_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/Window.hx" private="1" module="lime.ui.Window">
	<WINDOW_FLAG_FULLSCREEN public="1" get="inline" set="null" line="475" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_FULLSCREEN>
	<WINDOW_FLAG_BORDERLESS public="1" get="inline" set="null" line="476" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_BORDERLESS>
	<WINDOW_FLAG_RESIZABLE public="1" get="inline" set="null" line="477" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_RESIZABLE>
	<WINDOW_FLAG_HARDWARE public="1" get="inline" set="null" line="478" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_HARDWARE>
	<WINDOW_FLAG_VSYNC public="1" get="inline" set="null" line="479" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_VSYNC>
	<WINDOW_FLAG_HW_AA public="1" get="inline" set="null" line="480" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_HW_AA>
	<WINDOW_FLAG_HW_AA_HIRES public="1" get="inline" set="null" line="481" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_HW_AA_HIRES>
	<WINDOW_FLAG_ALLOW_SHADERS public="1" get="inline" set="null" line="482" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_ALLOW_SHADERS>
	<WINDOW_FLAG_REQUIRE_SHADERS public="1" get="inline" set="null" line="483" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_REQUIRE_SHADERS>
	<WINDOW_FLAG_DEPTH_BUFFER public="1" get="inline" set="null" line="484" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_DEPTH_BUFFER>
	<WINDOW_FLAG_STENCIL_BUFFER public="1" get="inline" set="null" line="485" static="1">
		<x path="lime.ui._Window.WindowFlags"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_STENCIL_BUFFER>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._Window.WindowFlags_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/Window.hx" private="1" module="lime.ui.Window">
		<WINDOW_FLAG_FULLSCREEN public="1" get="inline" set="null" line="475" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_FULLSCREEN>
		<WINDOW_FLAG_BORDERLESS public="1" get="inline" set="null" line="476" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_BORDERLESS>
		<WINDOW_FLAG_RESIZABLE public="1" get="inline" set="null" line="477" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_RESIZABLE>
		<WINDOW_FLAG_HARDWARE public="1" get="inline" set="null" line="478" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_HARDWARE>
		<WINDOW_FLAG_VSYNC public="1" get="inline" set="null" line="479" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_VSYNC>
		<WINDOW_FLAG_HW_AA public="1" get="inline" set="null" line="480" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_HW_AA>
		<WINDOW_FLAG_HW_AA_HIRES public="1" get="inline" set="null" line="481" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_HW_AA_HIRES>
		<WINDOW_FLAG_ALLOW_SHADERS public="1" get="inline" set="null" line="482" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_ALLOW_SHADERS>
		<WINDOW_FLAG_REQUIRE_SHADERS public="1" get="inline" set="null" line="483" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_REQUIRE_SHADERS>
		<WINDOW_FLAG_DEPTH_BUFFER public="1" get="inline" set="null" line="484" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_DEPTH_BUFFER>
		<WINDOW_FLAG_STENCIL_BUFFER public="1" get="inline" set="null" line="485" static="1">
			<x path="lime.ui._Window.WindowFlags"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_STENCIL_BUFFER>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="lime.ui._Window.WindowEventType" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/Window.hx" private="1" module="lime.ui.Window">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._Window.WindowEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/Window.hx" private="1" module="lime.ui.Window">
	<WINDOW_ACTIVATE public="1" get="inline" set="null" line="492" static="1">
		<x path="lime.ui._Window.WindowEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_ACTIVATE>
	<WINDOW_CLOSE public="1" get="inline" set="null" line="493" static="1">
		<x path="lime.ui._Window.WindowEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_CLOSE>
	<WINDOW_DEACTIVATE public="1" get="inline" set="null" line="494" static="1">
		<x path="lime.ui._Window.WindowEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_DEACTIVATE>
	<WINDOW_FOCUS_IN public="1" get="inline" set="null" line="495" static="1">
		<x path="lime.ui._Window.WindowEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FOCUS_IN>
	<WINDOW_FOCUS_OUT public="1" get="inline" set="null" line="496" static="1">
		<x path="lime.ui._Window.WindowEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FOCUS_OUT>
	<WINDOW_MOVE public="1" get="inline" set="null" line="497" static="1">
		<x path="lime.ui._Window.WindowEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_MOVE>
	<WINDOW_RESIZE public="1" get="inline" set="null" line="498" static="1">
		<x path="lime.ui._Window.WindowEventType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_RESIZE>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._Window.WindowEventType_Impl_" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/ui/Window.hx" private="1" module="lime.ui.Window">
		<WINDOW_ACTIVATE public="1" get="inline" set="null" line="492" static="1">
			<x path="lime.ui._Window.WindowEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_ACTIVATE>
		<WINDOW_CLOSE public="1" get="inline" set="null" line="493" static="1">
			<x path="lime.ui._Window.WindowEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_CLOSE>
		<WINDOW_DEACTIVATE public="1" get="inline" set="null" line="494" static="1">
			<x path="lime.ui._Window.WindowEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_DEACTIVATE>
		<WINDOW_FOCUS_IN public="1" get="inline" set="null" line="495" static="1">
			<x path="lime.ui._Window.WindowEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FOCUS_IN>
		<WINDOW_FOCUS_OUT public="1" get="inline" set="null" line="496" static="1">
			<x path="lime.ui._Window.WindowEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FOCUS_OUT>
		<WINDOW_MOVE public="1" get="inline" set="null" line="497" static="1">
			<x path="lime.ui._Window.WindowEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_MOVE>
		<WINDOW_RESIZE public="1" get="inline" set="null" line="498" static="1">
			<x path="lime.ui._Window.WindowEventType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_RESIZE>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="lime.utils.ArrayBuffer" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/ArrayBuffer.hx"><c path="lime.utils.ByteArray"/></typedef>
	<class path="lime.utils.IMemoryRange" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/IMemoryRange.hx" interface="1">
		<getByteBuffer public="1" set="method"><f a=""><c path="lime.utils.ByteArray"/></f></getByteBuffer>
		<getStart public="1" set="method"><f a=""><x path="Int"/></f></getStart>
		<getLength public="1" set="method"><f a=""><x path="Int"/></f></getLength>
	</class>
	<class path="lime.utils.ArrayBufferView" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/ArrayBufferView.hx">
		<implements path="lime.utils.IMemoryRange"/>
		<buffer public="1" set="null"><c path="lime.utils.ByteArray"/></buffer>
		<byteOffset public="1" set="null"><x path="Int"/></byteOffset>
		<byteLength public="1" set="null"><x path="Int"/></byteLength>
		<bytes><t path="haxe.io.BytesData"/></bytes>
		<getByteBuffer public="1" set="method" line="90"><f a=""><c path="lime.utils.ByteArray"/></f></getByteBuffer>
		<getFloat32 public="1" get="inline" set="null" line="97"><f a="position">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat32>
		<getInt8 public="1" get="inline" set="null" line="109"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt8>
		<getInt16 public="1" get="inline" set="null" line="121"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt16>
		<getInt32 public="1" get="inline" set="null" line="133"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt32>
		<getLength public="1" set="method" line="145"><f a=""><x path="Int"/></f></getLength>
		<getStart public="1" set="method" line="152"><f a=""><x path="Int"/></f></getStart>
		<getUInt8 public="1" get="inline" set="null" line="159"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getUInt8>
		<getUInt16 public="1" get="inline" set="null" line="171"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getUInt16>
		<getUInt32 public="1" get="inline" set="null" line="183"><f a="position">
	<x path="Int"/>
	<x path="Int"/>
</f></getUInt32>
		<setFloat32 public="1" get="inline" set="null" line="195"><f a="position:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat32>
		<setInt8 public="1" get="inline" set="null" line="207"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt8>
		<setInt16 public="1" get="inline" set="null" line="219"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt16>
		<setInt32 public="1" get="inline" set="null" line="231"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt32>
		<setUInt8 public="1" get="inline" set="null" line="243"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUInt8>
		<setUInt16 public="1" get="inline" set="null" line="256"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUInt16>
		<setUInt32 public="1" get="inline" set="null" line="269"><f a="position:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUInt32>
		<new public="1" params="T" set="method" line="27"><f a="lengthOrBuffer:?byteOffset:?length" v=":0:null">
	<c path="new.T"/>
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="lime.utils.IDataInput" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/IDataInput.hx" interface="1">
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="outData:?inOffset:?inLen">
	<c path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="inLen">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<get_bytesAvailable set="method"><f a=""><x path="Int"/></f></get_bytesAvailable>
		<get_endian set="method"><f a=""><c path="String"/></f></get_endian>
		<set_endian set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
	</class>
	<class path="lime.utils.ByteArray" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/ByteArray.hx">
		<extends path="haxe.io.Bytes"/>
		<implements path="lime.utils.IMemoryRange"/>
		<implements path="lime.utils.IDataInput"/>
		<fromBytes public="1" set="method" line="277" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.utils.ByteArray"/>
</f></fromBytes>
		<readFile public="1" set="method" line="386" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.utils.ByteArray"/>
</f></readFile>
		<lime_byte_array_overwrite_file line="1135" static="1"><f a=":">
	<c path="String"/>
	<c path="lime.utils.ByteArray"/>
	<unknown/>
</f></lime_byte_array_overwrite_file>
		<lime_byte_array_read_file line="1136" static="1"><f a="">
	<c path="String"/>
	<c path="lime.utils.ByteArray"/>
</f></lime_byte_array_read_file>
		<lime_lzma_decode line="1137" static="1"><f a="">
	<t path="haxe.io.BytesData"/>
	<t path="haxe.io.BytesData"/>
</f></lime_lzma_decode>
		<lime_lzma_encode line="1138" static="1"><f a="">
	<t path="haxe.io.BytesData"/>
	<t path="haxe.io.BytesData"/>
</f></lime_lzma_encode>
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><c path="String"/></endian>
		<objectEncoding public="1"><x path="Int"/></objectEncoding>
		<position public="1"><x path="Int"/></position>
		<allocated><x path="Int"/></allocated>
		<littleEndian><x path="Bool"/></littleEndian>
		<bigEndian public="1" get="accessor" set="accessor"><x path="Bool"/></bigEndian>
		<byteLength public="1" get="accessor" set="null"><x path="Int"/></byteLength>
		<asString public="1" set="method" line="146"><f a=""><c path="String"/></f></asString>
		<checkData public="1" set="method" line="155"><f a="length">
	<x path="Int"/>
	<x path="Void"/>
</f></checkData>
		<clear public="1" set="method" line="167"><f a=""><x path="Void"/></f></clear>
		<compress public="1" set="method" line="175"><f a="?algorithm" v="null">
	<e path="lime.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<deflate public="1" set="method" line="225"><f a=""><x path="Void"/></f></deflate>
		<ensureElem set="method" line="233"><f a="size:updateLength">
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></ensureElem>
		<getLength public="1" set="method" line="287"><f a=""><x path="Int"/></f></getLength>
		<getByteBuffer public="1" set="method" line="288"><f a=""><c path="lime.utils.ByteArray"/></f></getByteBuffer>
		<getStart public="1" set="method" line="289"><f a=""><x path="Int"/></f></getStart>
		<inflate public="1" set="method" line="293"><f a=""><x path="Void"/></f></inflate>
		<readBoolean public="1" get="inline" set="null" line="300"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" get="inline" set="null" line="311"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="324"><f a="bytes:?offset:?length" v=":0:0">
	<c path="lime.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method" line="371"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="399"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method" line="414"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" get="inline" set="null" line="431"><f a="length:charSet">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readShort public="1" set="method" line="438"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" get="inline" set="null" line="454"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method" line="466"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method" line="483"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method" line="498"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method" line="506"><f a="len">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<setLength public="1" set="method" line="572"><f a="length">
	<x path="Int"/>
	<x path="Void"/>
</f></setLength>
		<slice public="1" set="method" line="583"><f a="begin:?inEnd" v=":null">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ByteArray"/>
</f></slice>
		<ThrowEOFi set="method" line="619"><f a=""><x path="Int"/></f></ThrowEOFi>
		<toString public="1" set="method" line="628"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method" line="639"><f a="?algorithm" v="null">
	<e path="lime.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<write_uncheck get="inline" set="null" line="697"><f a="byte">
	<x path="Int"/>
	<x path="Void"/>
</f></write_uncheck>
		<writeBoolean public="1" get="inline" set="null" line="708"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method" line="715"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="734"><f a="bytes:?offset:?length" v=":0:0">
	<c path="haxe.io.Bytes"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method" line="754"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFile public="1" set="method" line="769"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></writeFile>
		<writeFloat public="1" set="method" line="782"><f a="x">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method" line="797"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeShort public="1" set="method" line="826"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUnsignedInt public="1" set="method" line="852"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUnsignedShort public="1" set="method" line="865"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedShort>
		<writeUTF public="1" set="method" line="878"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method" line="896"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<__fromBytes get="inline" set="null" line="941"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></__fromBytes>
		<__get public="1" get="inline" set="null" line="958">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":keep"/></meta>
		</__get>
		<__set public="1" get="inline" set="null" line="1053">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":keep"/></meta>
		</__set>
		<get_bigEndian get="inline" set="null" line="1077"><f a=""><x path="Bool"/></f></get_bigEndian>
		<set_bigEndian get="inline" set="null" line="1078"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<get_bytesAvailable get="inline" set="null" line="1082"><f a=""><x path="Int"/></f></get_bytesAvailable>
		<get_byteLength set="method" line="1090"><f a=""><x path="Int"/></f></get_byteLength>
		<get_endian get="inline" set="null" line="1098"><f a=""><c path="String"/></f></get_endian>
		<set_endian get="inline" set="null" line="1105"><f a="endian">
	<c path="String"/>
	<c path="String"/>
</f></set_endian>
		<set_length get="inline" set="null" line="1113"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_length>
		<new public="1" set="method" line="115"><f a="?size" v="0">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":autoBuild"><e>'???'</e></m></meta>
	</class>
	<enum path="lime.utils.CompressionAlgorithm" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<ZLIB/>
		<LZMA/>
		<GZIP/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.utils.Float32Array" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/Float32Array.hx">
		<extends path="lime.utils.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<set public="1" params="T" set="method" line="116"><f a="bufferOrArray:?offset" v=":0">
	<c path="set.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<subarray public="1" set="method" line="147"><f a="start:?end" v=":null">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.Float32Array"/>
</f></subarray>
		<__get public="1" get="inline" set="null" line="162">
			<f a="index">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="163">
			<f a="index:value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<new public="1" params="T" set="method" line="15"><f a="bufferOrArray:?start:?length" v=":0:null">
	<c path="new.T"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="lime.utils.GLUtils" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/GLUtils.hx">
		<compileShader public="1" set="method" line="12" static="1"><f a="source:type">
	<c path="String"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLShader"/>
</f></compileShader>
		<createProgram public="1" set="method" line="35" static="1"><f a="vertexSource:fragmentSource">
	<c path="String"/>
	<c path="String"/>
	<c path="lime.graphics.opengl.GLProgram"/>
</f></createProgram>
	</class>
	<class path="lime.utils.Int16Array" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/Int16Array.hx">
		<extends path="lime.utils.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<set public="1" params="T" set="method" line="88"><f a="bufferOrArray:?offset" v=":0">
	<c path="set.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<subarray public="1" set="method" line="119"><f a="start:?end" v=":null">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.Int16Array"/>
</f></subarray>
		<__get public="1" get="inline" set="null" line="127">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="128">
			<f a="index:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<new public="1" params="T" set="method" line="15"><f a="bufferOrArray:?start:?length" v=":0:null">
	<c path="new.T"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="lime.utils.Int32Array" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/Int32Array.hx">
		<extends path="lime.utils.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<set public="1" params="T" set="method" line="88"><f a="bufferOrArray:?offset" v=":0">
	<c path="set.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<subarray public="1" set="method" line="119"><f a="start:?end" v=":null">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.Int32Array"/>
</f></subarray>
		<__get public="1" get="inline" set="null" line="127">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="128">
			<f a="index:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<new public="1" params="T" set="method" line="15"><f a="bufferOrArray:?start:?length" v=":0:null">
	<c path="new.T"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="lime.utils.UInt16Array" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/UInt16Array.hx">
		<extends path="lime.utils.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<set public="1" params="T" set="method" line="88"><f a="bufferOrArray:?offset" v=":0">
	<c path="set.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<subarray public="1" set="method" line="119"><f a="start:?end" v=":null">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.UInt16Array"/>
</f></subarray>
		<__get public="1" get="inline" set="null" line="127">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="128">
			<f a="index:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<new public="1" params="T" set="method" line="15"><f a="bufferOrArray:?start:?length" v=":0:null">
	<c path="new.T"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="lime.utils.UInt8Array" params="" file="/usr/lib/haxe/lib/lime/2,0,0/lime/utils/UInt8Array.hx">
		<extends path="lime.utils.ArrayBufferView"/>
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></BYTES_PER_ELEMENT>
		<length public="1" set="null"><x path="Int"/></length>
		<set public="1" params="T" set="method" line="76"><f a="bufferOrArray:?offset" v=":0">
	<c path="set.T"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<subarray public="1" set="method" line="107"><f a="start:?end" v=":null">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.UInt8Array"/>
</f></subarray>
		<__get public="1" get="inline" set="null" line="115">
			<f a="index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="116">
			<f a="index:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":keep"/>
			</meta>
		</__set>
		<new public="1" params="T" set="method" line="15"><f a="bufferOrArray:?start:?length" v=":0:null">
	<c path="new.T"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="openfl.IAssetCache" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Assets.hx" module="openfl.Assets" interface="1">
		<enabled public="1" get="null" set="null"><x path="Bool"/></enabled>
		<clear public="1" set="method"><f a="?prefix">
	<c path="String"/>
	<x path="Void"/>
</f></clear>
		<getBitmapData public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="openfl.display.BitmapData"/>
</f></getBitmapData>
		<getFont public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="openfl.text.Font"/>
</f></getFont>
		<getSound public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
</f></getSound>
		<hasBitmapData public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasBitmapData>
		<hasFont public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasFont>
		<hasSound public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasSound>
		<removeBitmapData public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeBitmapData>
		<removeFont public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeFont>
		<removeSound public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeSound>
		<setBitmapData public="1" set="method"><f a="id:bitmapData">
	<c path="String"/>
	<c path="openfl.display.BitmapData"/>
	<x path="Void"/>
</f></setBitmapData>
		<setFont public="1" set="method"><f a="id:font">
	<c path="String"/>
	<c path="openfl.text.Font"/>
	<x path="Void"/>
</f></setFont>
		<setSound public="1" set="method"><f a="id:sound">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
	<x path="Void"/>
</f></setSound>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="openfl.AssetCache" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Assets.hx" module="openfl.Assets">
		<implements path="openfl.IAssetCache"/>
		<enabled public="1" get="accessor" set="accessor"><x path="Bool"/></enabled>
		<bitmapData public="1">
			<x path="Map">
				<c path="String"/>
				<c path="openfl.display.BitmapData"/>
			</x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</bitmapData>
		<font public="1">
			<x path="Map">
				<c path="String"/>
				<c path="openfl.text.Font"/>
			</x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</font>
		<sound public="1">
			<x path="Map">
				<c path="String"/>
				<c path="openfl.media.Sound"/>
			</x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</sound>
		<__enabled><x path="Bool"/></__enabled>
		<clear public="1" set="method" line="892"><f a="?prefix" v="null">
	<c path="String"/>
	<x path="Void"/>
</f></clear>
		<getBitmapData public="1" set="method" line="943"><f a="id">
	<c path="String"/>
	<c path="openfl.display.BitmapData"/>
</f></getBitmapData>
		<getFont public="1" set="method" line="950"><f a="id">
	<c path="String"/>
	<c path="openfl.text.Font"/>
</f></getFont>
		<getSound public="1" set="method" line="957"><f a="id">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
</f></getSound>
		<hasBitmapData public="1" set="method" line="964"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasBitmapData>
		<hasFont public="1" set="method" line="971"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasFont>
		<hasSound public="1" set="method" line="978"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasSound>
		<removeBitmapData public="1" set="method" line="985"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeBitmapData>
		<removeFont public="1" set="method" line="992"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeFont>
		<removeSound public="1" set="method" line="999"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeSound>
		<setBitmapData public="1" set="method" line="1006"><f a="id:bitmapData">
	<c path="String"/>
	<c path="openfl.display.BitmapData"/>
	<x path="Void"/>
</f></setBitmapData>
		<setFont public="1" set="method" line="1013"><f a="id:font">
	<c path="String"/>
	<c path="openfl.text.Font"/>
	<x path="Void"/>
</f></setFont>
		<setSound public="1" set="method" line="1020"><f a="id:sound">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
	<x path="Void"/>
</f></setSound>
		<get_enabled set="method" line="1034"><f a=""><x path="Bool"/></f></get_enabled>
		<set_enabled set="method" line="1041"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<new public="1" set="method" line="883"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="openfl.events.IEventDispatcher" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/IEventDispatcher.hx" interface="1">
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
	</class>
	<class path="openfl.events.EventDispatcher" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/EventDispatcher.hx">
		<implements path="openfl.events.IEventDispatcher"/>
		<__sortByPriority set="method" line="169" static="1">
			<f a="l1:l2">
				<c path="openfl.events._EventDispatcher.Listener"/>
				<c path="openfl.events._EventDispatcher.Listener"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__sortByPriority>
		<__targetDispatcher>
			<c path="openfl.events.IEventDispatcher"/>
			<meta><m n=":noCompletion"/></meta>
		</__targetDispatcher>
		<__eventMap>
			<x path="Map">
				<c path="String"/>
				<c path="Array"><c path="openfl.events._EventDispatcher.Listener"/></c>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__eventMap>
		<addEventListener public="1" set="method" line="27"><f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method" line="52"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method" line="110"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method" line="118"><f a="type:listener:?capture" v="::false">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<toString public="1" set="method" line="152"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method" line="162"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method" line="16"><f a="?target" v="null">
	<c path="openfl.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl.Assets" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Assets.hx">
		<cache public="1" line="43" static="1"><c path="openfl.IAssetCache"/></cache>
		<dispatcher line="45" static="1"><c path="openfl.events.EventDispatcher"/></dispatcher>
		<addEventListener public="1" set="method" line="48" static="1"><f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method" line="55" static="1"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<exists public="1" set="method" line="67" static="1">
			<f a="id:?type" v=":null">
				<c path="String"/>
				<x path="openfl.AssetType"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether a specific asset exists
	 * @param	id 		The ID or asset path for the file
	 * @param	type	The type of assets AssetType.BINARY | AssetType.FONT | AssetType.IMAGE | AssetType.MOVIE_CLIP | AssetType.MUSIC | AssetType.SOUND | AssetType.TEMPLATE | AssetType.TEXT
	 * @return	TRUE if an asset with a given id, and type exists FALSE otherwise</haxe_doc>
		</exists>
		<getBitmapData public="1" set="method" line="81" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap(Assets.getBitmapData("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache(Default: true)
	 * @return		A new BitmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="130" static="1">
			<f a="id">
				<c path="String"/>
				<t path="openfl.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="143" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getLibrary set="method" line="168" static="1"><f a="name">
	<c path="String"/>
	<c path="lime.AssetLibrary"/>
</f></getLibrary>
		<getMovieClip public="1" set="method" line="189" static="1">
			<f a="id">
				<c path="String"/>
				<c path="openfl.display.MovieClip"/>
			</f>
			<haxe_doc>* Gets an instance of a library MovieClip
	 * @usage		var movieClip = Assets.getMovieClip("library:BouncingBall");
	 * @param	id		The library and ID for the MovieClip
	 * @return		A new Sound object</haxe_doc>
		</getMovieClip>
		<getMusic public="1" set="method" line="236" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded streaming sound
	 * @usage		var sound = Assets.getMusic("sound.ogg");
	 * @param	id		The ID or asset path for the music track
	 * @return		A new Sound object</haxe_doc>
		</getMusic>
		<getPath public="1" set="method" line="266" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets the file path (if available) for an asset
	 * @usage		var path = Assets.getPath("image.jpg");
	 * @param	id		The ID or asset path for the asset
	 * @return		The path to the asset (or null)</haxe_doc>
		</getPath>
		<getSound public="1" set="method" line="279" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="338" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<hasEventListener public="1" set="method" line="345" static="1"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<isLocal public="1" set="method" line="358" static="1">
			<f a="id:?type:?useCache" v=":null:true">
				<c path="String"/>
				<x path="openfl.AssetType"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether an asset with a given id and "AssetType" exists within the cache or Asset Library
	 * @param	id 		The ID or asset path for the file
	 * @param	type	The type of assets AssetType.BINARY | AssetType.FONT | AssetType.IMAGE | AssetType.MOVIE_CLIP | AssetType.MUSIC | AssetType.SOUND | AssetType.TEMPLATE | AssetType.TEXT
	 * @param	useCache Whether or not to use the cache. if FALSE this function will search for the asset in any known library
	 * @return	whether or not an asset with the given id exists within the asset cache or any asset library;</haxe_doc>
		</isLocal>
		<isValidBitmapData set="method" line="401" static="1"><f a="bitmapData">
	<c path="openfl.display.BitmapData"/>
	<x path="Bool"/>
</f></isValidBitmapData>
		<isValidSound set="method" line="428" static="1"><f a="sound">
	<c path="openfl.media.Sound"/>
	<x path="Bool"/>
</f></isValidSound>
		<list public="1" set="method" line="448" static="1">
			<f a="?type" v="null">
				<x path="openfl.AssetType"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>* Returns an array of embeded assets
	 * @param	type	The type of assets to include AssetType.BINARY | AssetType.FONT | AssetType.IMAGE | AssetType.MOVIE_CLIP | AssetType.MUSIC | AssetType.SOUND | AssetType.TEMPLATE | AssetType.TEXT
	 * @return an Array of embeded assets</haxe_doc>
		</list>
		<loadBitmapData public="1" set="method" line="463" static="1">
			<f a="id:handler:?useCache" v="::true">
				<c path="String"/>
				<f a="">
					<c path="openfl.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Asynchronously loads an instance of an embeded bitmap
	 * @usage 	Asset.loadBitmapData("MyReallyBigPic.jpg", function(_loadedBitmapData):Void{
	 * 				var myReallyBigBitmap = new Bitmap(_loadedBitmapData);
	 * 			});
	 * @param	id 		The ID or asset path for the file
	 * @param	handler	a funtion to handle the loaded BitmapData
	 * @param	useCache whether or not to add / retrieve the asset from the cache</haxe_doc>
		</loadBitmapData>
		<loadBytes public="1" set="method" line="515" static="1">
			<f a="id:handler">
				<c path="String"/>
				<f a="">
					<t path="openfl.utils.ByteArray"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Asynchronously loads an instance of an embedded binary file
	 * @usage Asset.loadBytes("MyReallyBigBin.bin", function(_loadedByteArray):Void{
	 * 				myParserFunction(_loadedByteArray)
	 * 			});
	 * @param	id 		The ID or asset path for the file
	 * @param	handler	a funtion to handle the loaded ByteArray
	 * @param	useCache whether or not to add / retrieve the asset from the cache</haxe_doc>
		</loadBytes>
		<loadFont public="1" set="method" line="556" static="1">
			<f a="id:handler:?useCache" v="::true">
				<c path="String"/>
				<f a="">
					<c path="openfl.text.Font"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Asynchronously loads an instance of an embedded font
	 * @usage Asset.loadFont("MyReallyLongSong.ttf", function(_loadedFont):Void{
	 * 				myTextFortmat.font = _loadedFont.fontName;
	 * 			});
	 * @param	id 		The ID or asset path for the file
	 * @param	handler	a funtion to handle the loaded font
	 * @param	useCache whether or not to add / retrieve the asset from the cache</haxe_doc>
		</loadFont>
		<loadLibrary public="1" set="method" line="615" static="1">
			<f a="name:handler">
				<c path="String"/>
				<f a="">
					<t path="lime._Assets.LimeAssetLibrary"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Loads an Asset Library with a given Name
	 * @param	name the name of the library to load
	 * @param	handler the function to handle the loaded AssetLibrary</haxe_doc>
		</loadLibrary>
		<loadMusic public="1" set="method" line="630" static="1">
			<f a="id:handler:?useCache" v="::true">
				<c path="String"/>
				<f a="">
					<c path="openfl.media.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Asynchronously loads an instance of an embedded streaming sound
	 * @usage Asset.loadMusic("MyReallyLongSong.ogg", function(_loadedSound):Void{
	 * 				_loadedSound.play();
	 * 			});
	 * @param	id 		The ID or asset path for the file
	 * @param	handler	a funtion to handle the loaded music
	 * @param	useCache whether or not to add / retrieve the asset from the cache</haxe_doc>
		</loadMusic>
		<loadMovieClip public="1" set="method" line="661" static="1">
			<f a="id:handler">
				<c path="String"/>
				<f a="">
					<c path="openfl.display.MovieClip"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Asynchronously loads an instance of a MovieClip from a library
	 * @usage Asset.loadMovieClip("libary:MovieClip", function(_loadedMovieClip):Void{
	 * 				sprite.addChild(_loadedMovieClip);
	 * 			});
	 * @param	id 		The ID or asset path for the file
	 * @param	handler	a funtion to handle the loaded movieclip
	 * @param	useCache whether or not to add / retrieve the asset from the cache</haxe_doc>
		</loadMovieClip>
		<loadSound public="1" set="method" line="704" static="1">
			<f a="id:handler:?useCache" v="::true">
				<c path="String"/>
				<f a="">
					<c path="openfl.media.Sound"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Asynchronously loads an instance of a sound.
	 * @usage Asset.loadSound("MyReallyShortSong.wav", function(_loadedSound):Void{
	 * 				_loadedSound.play();
	 * 			});
	 * @param	id 		The ID or asset path for the file
	 * @param	handler	a funtion to handle the loaded sound
	 * @param	useCache whether or not to add / retrieve the asset from the cache</haxe_doc>
		</loadSound>
		<loadText public="1" set="method" line="736" static="1">
			<f a="id:handler">
				<c path="String"/>
				<f a="">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Asynchronously loads an instance of an embedded text
	 * @usage Asset.loadText("MyReallyLongText.txt", function(_loadedText):Void{
	 * 				myTextField.text = _loadedText;
	 * 			});
	 * @param	id 		The ID or asset path for the file
	 * @param	handler	a funtion to handle the loaded text
	 * @param	useCache whether or not to add / retrieve the asset from the cache</haxe_doc>
		</loadText>
		<registerLibrary public="1" set="method" line="747" static="1">
			<f a="name:library">
				<c path="String"/>
				<c path="openfl.AssetLibrary"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Registers an AssetLibrary
	 * @param	name the name of the library
	 * @param	library the AssetLibrary to register</haxe_doc>
		</registerLibrary>
		<removeEventListener public="1" set="method" line="754" static="1"><f a="type:listener:?capture" v="::false">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<resolveClass set="method" line="761" static="1"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum set="method" line="768" static="1"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<unloadLibrary public="1" set="method" line="787" static="1"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></unloadLibrary>
		<library_onEvent set="method" line="801" static="1"><f a="library:type">
	<c path="openfl.AssetLibrary"/>
	<c path="String"/>
	<x path="Void"/>
</f></library_onEvent>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl.AssetLibrary" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Assets.hx" module="openfl.Assets">
		<extends path="lime.AssetLibrary"/>
		<getMovieClip public="1" set="method" line="826"><f a="id">
	<c path="String"/>
	<c path="openfl.display.MovieClip"/>
</f></getMovieClip>
		<getMusic public="1" set="method" line="833"><f a="id">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
</f></getMusic>
		<getSound public="1" set="method" line="840"><f a="id">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
</f></getSound>
		<loadMovieClip public="1" set="method" line="847"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="openfl.display.MovieClip"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMovieClip>
		<loadMusic public="1" set="method" line="854"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="openfl.media.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadMusic>
		<loadSound public="1" set="method" line="861"><f a="id:handler">
	<c path="String"/>
	<f a="">
		<c path="openfl.media.Sound"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></loadSound>
		<new public="1" set="method" line="819"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<abstract path="openfl.AssetType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Assets.hx" module="openfl.Assets">
		<this><c path="String"/></this>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="openfl._Assets.AssetType_Impl_" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Assets.hx" private="1" module="openfl.Assets">
	<BINARY public="1" get="inline" set="null" line="1074" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BINARY>
	<FONT public="1" get="inline" set="null" line="1075" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONT>
	<IMAGE public="1" get="inline" set="null" line="1076" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</IMAGE>
	<MOVIE_CLIP public="1" get="inline" set="null" line="1077" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOVIE_CLIP>
	<MUSIC public="1" get="inline" set="null" line="1078" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUSIC>
	<SOUND public="1" get="inline" set="null" line="1079" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOUND>
	<TEMPLATE public="1" get="inline" set="null" line="1080" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEMPLATE>
	<TEXT public="1" get="inline" set="null" line="1081" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._Assets.AssetType_Impl_" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Assets.hx" private="1" module="openfl.Assets">
		<BINARY public="1" get="inline" set="null" line="1074" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BINARY>
		<FONT public="1" get="inline" set="null" line="1075" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONT>
		<IMAGE public="1" get="inline" set="null" line="1076" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</IMAGE>
		<MOVIE_CLIP public="1" get="inline" set="null" line="1077" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOVIE_CLIP>
		<MUSIC public="1" get="inline" set="null" line="1078" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUSIC>
		<SOUND public="1" get="inline" set="null" line="1079" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOUND>
		<TEMPLATE public="1" get="inline" set="null" line="1080" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEMPLATE>
		<TEXT public="1" get="inline" set="null" line="1081" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="openfl.display.IBitmapDrawable" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/IBitmapDrawable.hx" interface="1">
		<__worldTransform public="1"><c path="openfl.geom.Matrix"/></__worldTransform>
		<__renderCanvas public="1" set="method"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvas>
		<__renderMask public="1" set="method"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderMask>
		<__updateChildren public="1" set="method"><f a="transformOnly">
	<x path="Bool"/>
	<x path="Void"/>
</f></__updateChildren>
	</class>
	<class path="openfl.display.DisplayObject" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/DisplayObject.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<implements path="openfl.display.IBitmapDrawable"/>
		<__instanceCount line="161" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__instanceCount>
		<__worldRenderDirty line="162" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldRenderDirty>
		<__worldTransformDirty line="163" static="1">
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldTransformDirty>
		<alpha public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the alpha transparency value of the object specified. Valid
	 * values are 0(fully transparent) to 1(fully opaque). The default value is
	 * 1. Display objects with <code>alpha</code> set to 0 <i>are</i> active,
	 * even though they are invisible.]]></haxe_doc>
		</alpha>
		<blendMode public="1">
			<e path="openfl.display.BlendMode"/>
			<haxe_doc><![CDATA[* A value from the BlendMode class that specifies which blend mode to use. A
	 * bitmap can be drawn internally in two ways. If you have a blend mode
	 * enabled or an external clipping mask, the bitmap is drawn by adding a
	 * bitmap-filled square shape to the vector render. If you attempt to set
	 * this property to an invalid value, Flash runtimes set the value to
	 * <code>BlendMode.NORMAL</code>.
	 *
	 * <p>The <code>blendMode</code> property affects each pixel of the display
	 * object. Each pixel is composed of three constituent colors(red, green,
	 * and blue), and each constituent color has a value between 0x00 and 0xFF.
	 * Flash Player or Adobe AIR compares each constituent color of one pixel in
	 * the movie clip with the corresponding color of the pixel in the
	 * background. For example, if <code>blendMode</code> is set to
	 * <code>BlendMode.LIGHTEN</code>, Flash Player or Adobe AIR compares the red
	 * value of the display object with the red value of the background, and uses
	 * the lighter of the two as the value for the red component of the displayed
	 * color.</p>
	 *
	 * <p>The following table describes the <code>blendMode</code> settings. The
	 * BlendMode class defines string values you can use. The illustrations in
	 * the table show <code>blendMode</code> values applied to a circular display
	 * object(2) superimposed on another display object(1).</p>]]></haxe_doc>
		</blendMode>
		<cacheAsBitmap public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If set to <code>true</code>, NME will use the software renderer to cache
	 * an internal bitmap representation of the display object. For native targets,
	 * this is often much slower than the default hardware renderer. When you
	 * are using the Flash target, this caching may increase performance for display 
	 * objects that contain complex vector content.
	 *
	 * <p>All vector data for a display object that has a cached bitmap is drawn
	 * to the bitmap instead of the main display. If
	 * <code>cacheAsBitmapMatrix</code> is null or unsupported, the bitmap is
	 * then copied to the main display as unstretched, unrotated pixels snapped
	 * to the nearest pixel boundaries. Pixels are mapped 1 to 1 with the parent
	 * object. If the bounds of the bitmap change, the bitmap is recreated
	 * instead of being stretched.</p>
	 *
	 * <p>If <code>cacheAsBitmapMatrix</code> is non-null and supported, the
	 * object is drawn to the off-screen bitmap using that matrix and the
	 * stretched and/or rotated results of that rendering are used to draw the
	 * object to the main display.</p>
	 *
	 * <p>No internal bitmap is created unless the <code>cacheAsBitmap</code>
	 * property is set to <code>true</code>.</p>
	 *
	 * <p>After you set the <code>cacheAsBitmap</code> property to
	 * <code>true</code>, the rendering does not change, however the display
	 * object performs pixel snapping automatically. The animation speed can be
	 * significantly faster depending on the complexity of the vector content.
	 * </p>
	 *
	 * <p>The <code>cacheAsBitmap</code> property is automatically set to
	 * <code>true</code> whenever you apply a filter to a display object(when
	 * its <code>filter</code> array is not empty), and if a display object has a
	 * filter applied to it, <code>cacheAsBitmap</code> is reported as
	 * <code>true</code> for that display object, even if you set the property to
	 * <code>false</code>. If you clear all filters for a display object, the
	 * <code>cacheAsBitmap</code> setting changes to what it was last set to.</p>
	 *
	 * <p>A display object does not use a bitmap even if the
	 * <code>cacheAsBitmap</code> property is set to <code>true</code> and
	 * instead renders from vector data in the following cases:</p>
	 *
	 * <ul>
	 *   <li>The bitmap is too large. In AIR 1.5 and Flash Player 10, the maximum
	 * size for a bitmap image is 8,191 pixels in width or height, and the total
	 * number of pixels cannot exceed 16,777,215 pixels.(So, if a bitmap image
	 * is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9
	 * and earlier, the limitation is is 2880 pixels in height and 2,880 pixels
	 * in width.</li>
	 *   <li>The bitmap fails to allocate(out of memory error). </li>
	 * </ul>
	 *
	 * <p>The <code>cacheAsBitmap</code> property is best used with movie clips
	 * that have mostly static content and that do not scale and rotate
	 * frequently. With such movie clips, <code>cacheAsBitmap</code> can lead to
	 * performance increases when the movie clip is translated(when its <i>x</i>
	 * and <i>y</i> position is changed).</p>]]></haxe_doc>
		</cacheAsBitmap>
		<filters public="1" get="accessor" set="accessor">
			<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
			<haxe_doc><![CDATA[* An indexed array that contains each filter object currently associated
	 * with the display object. The openfl.filters package contains several
	 * classes that define specific filters you can use.
	 *
	 * <p>Filters can be applied in Flash Professional at design time, or at run
	 * time by using ActionScript code. To apply a filter by using ActionScript,
	 * you must make a temporary copy of the entire <code>filters</code> array,
	 * modify the temporary array, then assign the value of the temporary array
	 * back to the <code>filters</code> array. You cannot directly add a new
	 * filter object to the <code>filters</code> array.</p>
	 *
	 * <p>To add a filter by using ActionScript, perform the following steps
	 * (assume that the target display object is named
	 * <code>myDisplayObject</code>):</p>
	 *
	 * <ol>
	 *   <li>Create a new filter object by using the constructor method of your
	 * chosen filter class.</li>
	 *   <li>Assign the value of the <code>myDisplayObject.filters</code> array
	 * to a temporary array, such as one named <code>myFilters</code>.</li>
	 *   <li>Add the new filter object to the <code>myFilters</code> temporary
	 * array.</li>
	 *   <li>Assign the value of the temporary array to the
	 * <code>myDisplayObject.filters</code> array.</li>
	 * </ol>
	 *
	 * <p>If the <code>filters</code> array is undefined, you do not need to use
	 * a temporary array. Instead, you can directly assign an array literal that
	 * contains one or more filter objects that you create. The first example in
	 * the Examples section adds a drop shadow filter by using code that handles
	 * both defined and undefined <code>filters</code> arrays.</p>
	 *
	 * <p>To modify an existing filter object, you must use the technique of
	 * modifying a copy of the <code>filters</code> array:</p>
	 *
	 * <ol>
	 *   <li>Assign the value of the <code>filters</code> array to a temporary
	 * array, such as one named <code>myFilters</code>.</li>
	 *   <li>Modify the property by using the temporary array,
	 * <code>myFilters</code>. For example, to set the quality property of the
	 * first filter in the array, you could use the following code:
	 * <code>myFilters[0].quality = 1;</code></li>
	 *   <li>Assign the value of the temporary array to the <code>filters</code>
	 * array.</li>
	 * </ol>
	 *
	 * <p>At load time, if a display object has an associated filter, it is
	 * marked to cache itself as a transparent bitmap. From this point forward,
	 * as long as the display object has a valid filter list, the player caches
	 * the display object as a bitmap. This source bitmap is used as a source
	 * image for the filter effects. Each display object usually has two bitmaps:
	 * one with the original unfiltered source display object and another for the
	 * final image after filtering. The final image is used when rendering. As
	 * long as the display object does not change, the final image does not need
	 * updating.</p>
	 *
	 * <p>The openfl.filters package includes classes for filters. For example, to
	 * create a DropShadow filter, you would write:</p>
	 * 
	 * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	 *                       and the shader output type is not compatible with
	 *                       this operation(the shader must specify a
	 *                       <code>pixel4</code> output).
	 * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	 *                       and the shader doesn't specify any image input or
	 *                       the first input is not an <code>image4</code> input.
	 * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	 *                       and the shader specifies an image input that isn't
	 *                       provided.
	 * @throws ArgumentError When <code>filters</code> includes a ShaderFilter, a
	 *                       ByteArray or Vector.<Number> instance as a shader
	 *                       input, and the <code>width</code> and
	 *                       <code>height</code> properties aren't specified for
	 *                       the ShaderInput object, or the specified values
	 *                       don't match the amount of data in the input data.
	 *                       See the <code>ShaderInput.input</code> property for
	 *                       more information.]]></haxe_doc>
		</filters>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the height of the display object, in pixels. The height is
	 * calculated based on the bounds of the content of the display object. When
	 * you set the <code>height</code> property, the <code>scaleY</code> property
	 * is adjusted accordingly, as shown in the following code:
	 *
	 * <p>Except for TextField and Video objects, a display object with no
	 * content(such as an empty sprite) has a height of 0, even if you try to
	 * set <code>height</code> to a different value.</p>]]></haxe_doc>
		</height>
		<loaderInfo public="1">
			<c path="openfl.display.LoaderInfo"/>
			<haxe_doc><![CDATA[* Returns a LoaderInfo object containing information about loading the file
	 * to which this display object belongs. The <code>loaderInfo</code> property
	 * is defined only for the root display object of a SWF file or for a loaded
	 * Bitmap(not for a Bitmap that is drawn with ActionScript). To find the
	 * <code>loaderInfo</code> object associated with the SWF file that contains
	 * a display object named <code>myDisplayObject</code>, use
	 * <code>myDisplayObject.root.loaderInfo</code>.
	 *
	 * <p>A large SWF file can monitor its download by calling
	 * <code>this.root.loaderInfo.addEventListener(Event.COMPLETE,
	 * func)</code>.</p>]]></haxe_doc>
		</loaderInfo>
		<mask public="1" get="accessor" set="accessor">
			<c path="openfl.display.DisplayObject"/>
			<haxe_doc><![CDATA[* The calling display object is masked by the specified <code>mask</code>
	 * object. To ensure that masking works when the Stage is scaled, the
	 * <code>mask</code> display object must be in an active part of the display
	 * list. The <code>mask</code> object itself is not drawn. Set
	 * <code>mask</code> to <code>null</code> to remove the mask.
	 *
	 * <p>To be able to scale a mask object, it must be on the display list. To
	 * be able to drag a mask Sprite object(by calling its
	 * <code>startDrag()</code> method), it must be on the display list. To call
	 * the <code>startDrag()</code> method for a mask sprite based on a
	 * <code>mouseDown</code> event being dispatched by the sprite, set the
	 * sprite's <code>buttonMode</code> property to <code>true</code>.</p>
	 *
	 * <p>When display objects are cached by setting the
	 * <code>cacheAsBitmap</code> property to <code>true</code> an the
	 * <code>cacheAsBitmapMatrix</code> property to a Matrix object, both the
	 * mask and the display object being masked must be part of the same cached
	 * bitmap. Thus, if the display object is cached, then the mask must be a
	 * child of the display object. If an ancestor of the display object on the
	 * display list is cached, then the mask must be a child of that ancestor or
	 * one of its descendents. If more than one ancestor of the masked object is
	 * cached, then the mask must be a descendent of the cached container closest
	 * to the masked object in the display list.</p>
	 *
	 * <p><b>Note:</b> A single <code>mask</code> object cannot be used to mask
	 * more than one calling display object. When the <code>mask</code> is
	 * assigned to a second display object, it is removed as the mask of the
	 * first object, and that object's <code>mask</code> property becomes
	 * <code>null</code>.</p>]]></haxe_doc>
		</mask>
		<mouseX public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the x coordinate of the mouse or user input device position, in
	 * pixels.
	 *
	 * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned x
	 * coordinate will reflect the non-rotated object.</p>]]></haxe_doc>
		</mouseX>
		<mouseY public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the y coordinate of the mouse or user input device position, in
	 * pixels.
	 *
	 * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned y
	 * coordinate will reflect the non-rotated object.</p>]]></haxe_doc>
		</mouseY>
		<name public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc><![CDATA[* Indicates the instance name of the DisplayObject. The object can be
	 * identified in the child list of its parent display object container by
	 * calling the <code>getChildByName()</code> method of the display object
	 * container.
	 * 
	 * @throws IllegalOperationError If you are attempting to set this property
	 *                               on an object that was placed on the timeline
	 *                               in the Flash authoring tool.]]></haxe_doc>
		</name>
		<opaqueBackground public="1">
			<t path="Null"><x path="Int"/></t>
			<haxe_doc><![CDATA[* Specifies whether the display object is opaque with a certain background
	 * color. A transparent bitmap contains alpha channel data and is drawn
	 * transparently. An opaque bitmap has no alpha channel(and renders faster
	 * than a transparent bitmap). If the bitmap is opaque, you specify its own
	 * background color to use.
	 *
	 * <p>If set to a number value, the surface is opaque(not transparent) with
	 * the RGB background color that the number specifies. If set to
	 * <code>null</code>(the default value), the display object has a
	 * transparent background.</p>
	 *
	 * <p>The <code>opaqueBackground</code> property is intended mainly for use
	 * with the <code>cacheAsBitmap</code> property, for rendering optimization.
	 * For display objects in which the <code>cacheAsBitmap</code> property is
	 * set to true, setting <code>opaqueBackground</code> can improve rendering
	 * performance.</p>
	 *
	 * <p>The opaque background region is <i>not</i> matched when calling the
	 * <code>hitTestPoint()</code> method with the <code>shapeFlag</code>
	 * parameter set to <code>true</code>.</p>
	 *
	 * <p>The opaque background region does not respond to mouse events.</p>]]></haxe_doc>
		</opaqueBackground>
		<parent public="1" set="null">
			<c path="openfl.display.DisplayObjectContainer"/>
			<haxe_doc><![CDATA[* Indicates the DisplayObjectContainer object that contains this display
	 * object. Use the <code>parent</code> property to specify a relative path to
	 * display objects that are above the current display object in the display
	 * list hierarchy.
	 *
	 * <p>You can use <code>parent</code> to move up multiple levels in the
	 * display list as in the following:</p>
	 * 
	 * @throws SecurityError The parent display object belongs to a security
	 *                       sandbox to which you do not have access. You can
	 *                       avoid this situation by having the parent movie call
	 *                       the <code>Security.allowDomain()</code> method.]]></haxe_doc>
		</parent>
		<root public="1" get="accessor" set="null">
			<c path="openfl.display.DisplayObject"/>
			<haxe_doc><![CDATA[* For a display object in a loaded SWF file, the <code>root</code> property
	 * is the top-most display object in the portion of the display list's tree
	 * structure represented by that SWF file. For a Bitmap object representing a
	 * loaded image file, the <code>root</code> property is the Bitmap object
	 * itself. For the instance of the main class of the first SWF file loaded,
	 * the <code>root</code> property is the display object itself. The
	 * <code>root</code> property of the Stage object is the Stage object itself.
	 * The <code>root</code> property is set to <code>null</code> for any display
	 * object that has not been added to the display list, unless it has been
	 * added to a display object container that is off the display list but that
	 * is a child of the top-most display object in a loaded SWF file.
	 *
	 * <p>For example, if you create a new Sprite object by calling the
	 * <code>Sprite()</code> constructor method, its <code>root</code> property
	 * is <code>null</code> until you add it to the display list(or to a display
	 * object container that is off the display list but that is a child of the
	 * top-most display object in a SWF file).</p>
	 *
	 * <p>For a loaded SWF file, even though the Loader object used to load the
	 * file may not be on the display list, the top-most display object in the
	 * SWF file has its <code>root</code> property set to itself. The Loader
	 * object does not have its <code>root</code> property set until it is added
	 * as a child of a display object for which the <code>root</code> property is
	 * set.</p>]]></haxe_doc>
		</root>
		<rotation public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the rotation of the DisplayObject instance, in degrees, from its
	 * original orientation. Values from 0 to 180 represent clockwise rotation;
	 * values from 0 to -180 represent counterclockwise rotation. Values outside
	 * this range are added to or subtracted from 360 to obtain a value within
	 * the range. For example, the statement <code>my_video.rotation = 450</code>
	 * is the same as <code> my_video.rotation = 90</code>.]]></haxe_doc>
		</rotation>
		<scale9Grid public="1">
			<c path="openfl.geom.Rectangle"/>
			<haxe_doc><![CDATA[* The current scaling grid that is in effect. If set to <code>null</code>,
	 * the entire display object is scaled normally when any scale transformation
	 * is applied.
	 *
	 * <p>When you define the <code>scale9Grid</code> property, the display
	 * object is divided into a grid with nine regions based on the
	 * <code>scale9Grid</code> rectangle, which defines the center region of the
	 * grid. The eight other regions of the grid are the following areas: </p>
	 *
	 * <ul>
	 *   <li>The upper-left corner outside of the rectangle</li>
	 *   <li>The area above the rectangle </li>
	 *   <li>The upper-right corner outside of the rectangle</li>
	 *   <li>The area to the left of the rectangle</li>
	 *   <li>The area to the right of the rectangle</li>
	 *   <li>The lower-left corner outside of the rectangle</li>
	 *   <li>The area below the rectangle</li>
	 *   <li>The lower-right corner outside of the rectangle</li>
	 * </ul>
	 *
	 * <p>You can think of the eight regions outside of the center(defined by
	 * the rectangle) as being like a picture frame that has special rules
	 * applied to it when scaled.</p>
	 *
	 * <p>When the <code>scale9Grid</code> property is set and a display object
	 * is scaled, all text and gradients are scaled normally; however, for other
	 * types of objects the following rules apply:</p>
	 *
	 * <ul>
	 *   <li>Content in the center region is scaled normally. </li>
	 *   <li>Content in the corners is not scaled. </li>
	 *   <li>Content in the top and bottom regions is scaled horizontally only.
	 * Content in the left and right regions is scaled vertically only.</li>
	 *   <li>All fills(including bitmaps, video, and gradients) are stretched to
	 * fit their shapes.</li>
	 * </ul>
	 *
	 * <p>If a display object is rotated, all subsequent scaling is normal(and
	 * the <code>scale9Grid</code> property is ignored).</p>
	 *
	 * <p>For example, consider the following display object and a rectangle that
	 * is applied as the display object's <code>scale9Grid</code>:</p>
	 *
	 * <p>A common use for setting <code>scale9Grid</code> is to set up a display
	 * object to be used as a component, in which edge regions retain the same
	 * width when the component is scaled.</p>
	 * 
	 * @throws ArgumentError If you pass an invalid argument to the method.]]></haxe_doc>
		</scale9Grid>
		<scaleX public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the horizontal scale(percentage) of the object as applied from
	 * the registration point. The default registration point is(0,0). 1.0
	 * equals 100% scale.
	 *
	 * <p>Scaling the local coordinate system changes the <code>x</code> and
	 * <code>y</code> property values, which are defined in whole pixels. </p>]]></haxe_doc>
		</scaleX>
		<scaleY public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the vertical scale(percentage) of an object as applied from the
	 * registration point of the object. The default registration point is(0,0).
	 * 1.0 is 100% scale.
	 *
	 * <p>Scaling the local coordinate system changes the <code>x</code> and
	 * <code>y</code> property values, which are defined in whole pixels. </p>]]></haxe_doc>
		</scaleY>
		<scrollRect public="1" get="accessor" set="accessor">
			<c path="openfl.geom.Rectangle"/>
			<haxe_doc><![CDATA[* The scroll rectangle bounds of the display object. The display object is
	 * cropped to the size defined by the rectangle, and it scrolls within the
	 * rectangle when you change the <code>x</code> and <code>y</code> properties
	 * of the <code>scrollRect</code> object.
	 *
	 * <p>The properties of the <code>scrollRect</code> Rectangle object use the
	 * display object's coordinate space and are scaled just like the overall
	 * display object. The corner bounds of the cropped window on the scrolling
	 * display object are the origin of the display object(0,0) and the point
	 * defined by the width and height of the rectangle. They are not centered
	 * around the origin, but use the origin to define the upper-left corner of
	 * the area. A scrolled display object always scrolls in whole pixel
	 * increments. </p>
	 *
	 * <p>You can scroll an object left and right by setting the <code>x</code>
	 * property of the <code>scrollRect</code> Rectangle object. You can scroll
	 * an object up and down by setting the <code>y</code> property of the
	 * <code>scrollRect</code> Rectangle object. If the display object is rotated
	 * 90Â° and you scroll it left and right, the display object actually scrolls
	 * up and down.</p>]]></haxe_doc>
		</scrollRect>
		<stage public="1" set="null">
			<c path="openfl.display.Stage"/>
			<haxe_doc><![CDATA[* The Stage of the display object. A Flash runtime application has only one
	 * Stage object. For example, you can create and load multiple display
	 * objects into the display list, and the <code>stage</code> property of each
	 * display object refers to the same Stage object(even if the display object
	 * belongs to a loaded SWF file).
	 *
	 * <p>If a display object is not added to the display list, its
	 * <code>stage</code> property is set to <code>null</code>.</p>]]></haxe_doc>
		</stage>
		<transform public="1" get="accessor" set="accessor">
			<c path="openfl.geom.Transform"/>
			<haxe_doc><![CDATA[* An object with properties pertaining to a display object's matrix, color
	 * transform, and pixel bounds. The specific properties  -  matrix,
	 * colorTransform, and three read-only properties
	 * (<code>concatenatedMatrix</code>, <code>concatenatedColorTransform</code>,
	 * and <code>pixelBounds</code>)  -  are described in the entry for the
	 * Transform class.
	 *
	 * <p>Each of the transform object's properties is itself an object. This
	 * concept is important because the only way to set new values for the matrix
	 * or colorTransform objects is to create a new object and copy that object
	 * into the transform.matrix or transform.colorTransform property.</p>
	 *
	 * <p>For example, to increase the <code>tx</code> value of a display
	 * object's matrix, you must make a copy of the entire matrix object, then
	 * copy the new object into the matrix property of the transform object:</p>
	 * <pre xml:space="preserve"><code> var myMatrix:Matrix =
	 * myDisplayObject.transform.matrix; myMatrix.tx += 10;
	 * myDisplayObject.transform.matrix = myMatrix; </code></pre>
	 *
	 * <p>You cannot directly set the <code>tx</code> property. The following
	 * code has no effect on <code>myDisplayObject</code>: </p>
	 * <pre xml:space="preserve"><code> myDisplayObject.transform.matrix.tx +=
	 * 10; </code></pre>
	 *
	 * <p>You can also copy an entire transform object and assign it to another
	 * display object's transform property. For example, the following code
	 * copies the entire transform object from <code>myOldDisplayObj</code> to
	 * <code>myNewDisplayObj</code>:</p>
	 * <code>myNewDisplayObj.transform = myOldDisplayObj.transform;</code>
	 *
	 * <p>The resulting display object, <code>myNewDisplayObj</code>, now has the
	 * same values for its matrix, color transform, and pixel bounds as the old
	 * display object, <code>myOldDisplayObj</code>.</p>
	 *
	 * <p>Note that AIR for TV devices use hardware acceleration, if it is
	 * available, for color transforms.</p>]]></haxe_doc>
		</transform>
		<visible public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether or not the display object is visible. Display objects that are not
	 * visible are disabled. For example, if <code>visible=false</code> for an
	 * InteractiveObject instance, it cannot be clicked.]]></haxe_doc>
		</visible>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the width of the display object, in pixels. The width is
	 * calculated based on the bounds of the content of the display object. When
	 * you set the <code>width</code> property, the <code>scaleX</code> property
	 * is adjusted accordingly, as shown in the following code:
	 *
	 * <p>Except for TextField and Video objects, a display object with no
	 * content(such as an empty sprite) has a width of 0, even if you try to set
	 * <code>width</code> to a different value.</p>]]></haxe_doc>
		</width>
		<x public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the <i>x</i> coordinate of the DisplayObject instance relative
	 * to the local coordinates of the parent DisplayObjectContainer. If the
	 * object is inside a DisplayObjectContainer that has transformations, it is
	 * in the local coordinate system of the enclosing DisplayObjectContainer.
	 * Thus, for a DisplayObjectContainer rotated 90Â° counterclockwise, the
	 * DisplayObjectContainer's children inherit a coordinate system that is
	 * rotated 90Â° counterclockwise. The object's coordinates refer to the
	 * registration point position.]]></haxe_doc>
		</x>
		<y public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the <i>y</i> coordinate of the DisplayObject instance relative
	 * to the local coordinates of the parent DisplayObjectContainer. If the
	 * object is inside a DisplayObjectContainer that has transformations, it is
	 * in the local coordinate system of the enclosing DisplayObjectContainer.
	 * Thus, for a DisplayObjectContainer rotated 90Â° counterclockwise, the
	 * DisplayObjectContainer's children inherit a coordinate system that is
	 * rotated 90Â° counterclockwise. The object's coordinates refer to the
	 * registration point position.]]></haxe_doc>
		</y>
		<__worldTransform public="1">
			<c path="openfl.geom.Matrix"/>
			<meta>
				<m n=":dox"><e>hide</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__worldTransform>
		<__alpha>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__alpha>
		<__filters>
			<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__filters>
		<__graphics>
			<c path="openfl.display.Graphics"/>
			<meta><m n=":noCompletion"/></meta>
		</__graphics>
		<__interactive>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__interactive>
		<__isMask>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__isMask>
		<__mask>
			<c path="openfl.display.DisplayObject"/>
			<meta><m n=":noCompletion"/></meta>
		</__mask>
		<__name>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__name>
		<__renderable>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__renderable>
		<__renderDirty>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__renderDirty>
		<__rotation>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__rotation>
		<__rotationCache>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__rotationCache>
		<__rotationCosine>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__rotationCosine>
		<__rotationSine>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__rotationSine>
		<__scaleX>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__scaleX>
		<__scaleY>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__scaleY>
		<__scrollRect>
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__scrollRect>
		<__transform>
			<c path="openfl.geom.Transform"/>
			<meta><m n=":noCompletion"/></meta>
		</__transform>
		<__transformDirty>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__transformDirty>
		<__visible>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__visible>
		<__worldAlpha>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldAlpha>
		<__worldAlphaChanged>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldAlphaChanged>
		<__worldClip>
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldClip>
		<__worldClipChanged>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldClipChanged>
		<__worldTransformCache>
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldTransformCache>
		<__worldTransformChanged>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldTransformChanged>
		<__worldVisible>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldVisible>
		<__worldVisibleChanged>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldVisibleChanged>
		<__worldZ>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__worldZ>
		<__x>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__x>
		<__y>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__y>
		<dispatchEvent public="1" set="method" line="767" override="1"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<getBounds public="1" set="method" line="813">
			<f a="targetCoordinateSpace">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Returns a rectangle that defines the area of the display object relative
	 * to the coordinate system of the <code>targetCoordinateSpace</code> object.
	 * Consider the following code, which shows how the rectangle returned can
	 * vary depending on the <code>targetCoordinateSpace</code> parameter that
	 * you pass to the method:
	 *
	 * <p><b>Note:</b> Use the <code>localToGlobal()</code> and
	 * <code>globalToLocal()</code> methods to convert the display object's local
	 * coordinates to display coordinates, or display coordinates to local
	 * coordinates, respectively.</p>
	 *
	 * <p>The <code>getBounds()</code> method is similar to the
	 * <code>getRect()</code> method; however, the Rectangle returned by the
	 * <code>getBounds()</code> method includes any strokes on shapes, whereas
	 * the Rectangle returned by the <code>getRect()</code> method does not. For
	 * an example, see the description of the <code>getRect()</code> method.</p>
	 * 
	 * @param targetCoordinateSpace The display object that defines the
	 *                              coordinate system to use.
	 * @return The rectangle that defines the area of the display object relative
	 *         to the <code>targetCoordinateSpace</code> object's coordinate
	 *         system.]]></haxe_doc>
		</getBounds>
		<getRect public="1" set="method" line="850">
			<f a="targetCoordinateSpace">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Returns a rectangle that defines the boundary of the display object, based
	 * on the coordinate system defined by the <code>targetCoordinateSpace</code>
	 * parameter, excluding any strokes on shapes. The values that the
	 * <code>getRect()</code> method returns are the same or smaller than those
	 * returned by the <code>getBounds()</code> method.
	 *
	 * <p><b>Note:</b> Use <code>localToGlobal()</code> and
	 * <code>globalToLocal()</code> methods to convert the display object's local
	 * coordinates to Stage coordinates, or Stage coordinates to local
	 * coordinates, respectively.</p>
	 * 
	 * @param targetCoordinateSpace The display object that defines the
	 *                              coordinate system to use.
	 * @return The rectangle that defines the area of the display object relative
	 *         to the <code>targetCoordinateSpace</code> object's coordinate
	 *         system.]]></haxe_doc>
		</getRect>
		<globalToLocal public="1" set="method" line="875">
			<f a="pos">
				<c path="openfl.geom.Point"/>
				<c path="openfl.geom.Point"/>
			</f>
			<haxe_doc><![CDATA[* Converts the <code>point</code> object from the Stage(global) coordinates
	 * to the display object's(local) coordinates.
	 *
	 * <p>To use this method, first create an instance of the Point class. The
	 * <i>x</i> and <i>y</i> values that you assign represent global coordinates
	 * because they relate to the origin(0,0) of the main display area. Then
	 * pass the Point instance as the parameter to the
	 * <code>globalToLocal()</code> method. The method returns a new Point object
	 * with <i>x</i> and <i>y</i> values that relate to the origin of the display
	 * object instead of the origin of the Stage.</p>
	 * 
	 * @param point An object created with the Point class. The Point object
	 *              specifies the <i>x</i> and <i>y</i> coordinates as
	 *              properties.
	 * @return A Point object with coordinates relative to the display object.]]></haxe_doc>
		</globalToLocal>
		<hitTestObject public="1" set="method" line="890">
			<f a="obj">
				<c path="openfl.display.DisplayObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Evaluates the bounding box of the display object to see if it overlaps or
	 * intersects with the bounding box of the <code>obj</code> display object.
	 * 
	 * @param obj The display object to test against.
	 * @return <code>true</code> if the bounding boxes of the display objects
	 *         intersect; <code>false</code> if not.]]></haxe_doc>
		</hitTestObject>
		<hitTestPoint public="1" set="method" line="922">
			<f a="x:y:?shapeFlag" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Evaluates the display object to see if it overlaps or intersects with the
	 * point specified by the <code>x</code> and <code>y</code> parameters. The
	 * <code>x</code> and <code>y</code> parameters specify a point in the
	 * coordinate space of the Stage, not the display object container that
	 * contains the display object(unless that display object container is the
	 * Stage).
	 * 
	 * @param x         The <i>x</i> coordinate to test against this object.
	 * @param y         The <i>y</i> coordinate to test against this object.
	 * @param shapeFlag Whether to check against the actual pixels of the object
	 *                 (<code>true</code>) or the bounding box
	 *                 (<code>false</code>).
	 * @return <code>true</code> if the display object overlaps or intersects
	 *         with the specified point; <code>false</code> otherwise.]]></haxe_doc>
		</hitTestPoint>
		<localToGlobal public="1" set="method" line="959">
			<f a="point">
				<c path="openfl.geom.Point"/>
				<c path="openfl.geom.Point"/>
			</f>
			<haxe_doc><![CDATA[* Converts the <code>point</code> object from the display object's(local)
	 * coordinates to the Stage(global) coordinates.
	 *
	 * <p>This method allows you to convert any given <i>x</i> and <i>y</i>
	 * coordinates from values that are relative to the origin(0,0) of a
	 * specific display object(local coordinates) to values that are relative to
	 * the origin of the Stage(global coordinates).</p>
	 *
	 * <p>To use this method, first create an instance of the Point class. The
	 * <i>x</i> and <i>y</i> values that you assign represent local coordinates
	 * because they relate to the origin of the display object.</p>
	 *
	 * <p>You then pass the Point instance that you created as the parameter to
	 * the <code>localToGlobal()</code> method. The method returns a new Point
	 * object with <i>x</i> and <i>y</i> values that relate to the origin of the
	 * Stage instead of the origin of the display object.</p>
	 * 
	 * @param point The name or identifier of a point created with the Point
	 *              class, specifying the <i>x</i> and <i>y</i> coordinates as
	 *              properties.
	 * @return A Point object with coordinates relative to the Stage.]]></haxe_doc>
		</localToGlobal>
		<__broadcast set="method" line="966">
			<f a="event:notifyChilden">
				<c path="openfl.events.Event"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__broadcast>
		<__getBounds set="method" line="987">
			<f a="rect:matrix">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getBounds>
		<__getInteractive set="method" line="994">
			<f a="stack">
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getInteractive>
		<__getLocalBounds get="inline" set="null" line="1001">
			<f a="rect">
				<c path="openfl.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getLocalBounds>
		<__getTransform set="method" line="1009">
			<f a=""><c path="openfl.geom.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__getTransform>
		<__hitTest set="method" line="1048">
			<f a="x:y:shapeFlag:stack:interactiveOnly">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__hitTest>
		<__renderCanvas public="1" set="method" line="1055">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderCanvas>
		<__renderDOM public="1" set="method" line="1062">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderDOM>
		<__renderGL public="1" set="method" line="1069">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderGL>
		<__renderMask public="1" set="method" line="1076">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderMask>
		<__setStageReference set="method" line="1083">
			<f a="stage">
				<c path="openfl.display.Stage"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setStageReference>
		<__setRenderDirty get="inline" set="null" line="1106">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__setRenderDirty>
		<__setTransformDirty get="inline" set="null" line="1118">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__setTransformDirty>
		<__update public="1" set="method" line="1130">
			<f a="transformOnly:updateChildren">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__update>
		<__updateChildren public="1" set="method" line="1285">
			<f a="transformOnly">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__updateChildren>
		<get_alpha set="method" line="1308">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_alpha>
		<set_alpha set="method" line="1315">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_alpha>
		<get_filters set="method" line="1323">
			<f a=""><c path="Array"><c path="openfl.filters.BitmapFilter"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_filters>
		<set_filters set="method" line="1338">
			<f a="value">
				<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
				<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_filters>
		<get_height set="method" line="1347">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_height>
		<set_height set="method" line="1357">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_height>
		<get_mask set="method" line="1377">
			<f a=""><c path="openfl.display.DisplayObject"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mask>
		<set_mask set="method" line="1384">
			<f a="value">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_mask>
		<get_mouseX set="method" line="1394">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mouseX>
		<get_mouseY set="method" line="1407">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mouseY>
		<get_name set="method" line="1420">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_name>
		<set_name set="method" line="1427">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_name>
		<get_root set="method" line="1434">
			<f a=""><c path="openfl.display.DisplayObject"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_root>
		<get_rotation set="method" line="1447">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_rotation>
		<set_rotation set="method" line="1454">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_rotation>
		<get_scaleX set="method" line="1462">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_scaleX>
		<set_scaleX set="method" line="1469">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_scaleX>
		<get_scaleY set="method" line="1477">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_scaleY>
		<set_scaleY set="method" line="1484">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_scaleY>
		<get_scrollRect set="method" line="1492">
			<f a=""><c path="openfl.geom.Rectangle"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_scrollRect>
		<set_scrollRect set="method" line="1499">
			<f a="value">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Rectangle"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_scrollRect>
		<get_transform set="method" line="1513">
			<f a=""><c path="openfl.geom.Transform"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_transform>
		<set_transform set="method" line="1526">
			<f a="value">
				<c path="openfl.geom.Transform"/>
				<c path="openfl.geom.Transform"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_transform>
		<get_visible set="method" line="1549">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_visible>
		<set_visible set="method" line="1556">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_visible>
		<get_width set="method" line="1564">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_width>
		<set_width set="method" line="1574">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<get_x set="method" line="1594">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_x>
		<set_x set="method" line="1601">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_x>
		<get_y set="method" line="1609">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_y>
		<set_y set="method" line="1616">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_y>
		<new set="method" line="740"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl.display.InteractiveObject" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/InteractiveObject.hx">
		<extends path="openfl.display.DisplayObject"/>
		<doubleClickEnabled public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether the object receives <code>doubleClick</code> events. The
	 * default value is <code>false</code>, which means that by default an
	 * InteractiveObject instance does not receive <code>doubleClick</code>
	 * events. If the <code>doubleClickEnabled</code> property is set to
	 * <code>true</code>, the instance receives <code>doubleClick</code> events
	 * within its bounds. The <code>mouseEnabled</code> property of the
	 * InteractiveObject instance must also be set to <code>true</code> for the
	 * object to receive <code>doubleClick</code> events.
	 *
	 * <p>No event is dispatched by setting this property. You must use the
	 * <code>addEventListener()</code> method to add an event listener for the
	 * <code>doubleClick</code> event.</p>]]></haxe_doc>
		</doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether this object receives mouse, or other user input,
	 * messages. The default value is <code>true</code>, which means that by
	 * default any InteractiveObject instance that is on the display list
	 * receives mouse events or other user input events. If
	 * <code>mouseEnabled</code> is set to <code>false</code>, the instance does
	 * not receive any mouse events(or other user input events like keyboard
	 * events). Any children of this instance on the display list are not
	 * affected. To change the <code>mouseEnabled</code> behavior for all
	 * children of an object on the display list, use
	 * <code>openfl.display.DisplayObjectContainer.mouseChildren</code>.
	 *
	 * <p> No event is dispatched by setting this property. You must use the
	 * <code>addEventListener()</code> method to create interactive
	 * functionality.</p>]]></haxe_doc>
		</mouseEnabled>
		<needsSoftKeyboard public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether a virtual keyboard(an on-screen, software keyboard)
	 * should display when this InteractiveObject instance receives focus.
	 *
	 * <p>By default, the value is <code>false</code> and focusing an
	 * InteractiveObject instance does not raise a soft keyboard. If the
	 * <code>needsSoftKeyboard</code> property is set to <code>true</code>, the
	 * runtime raises a soft keyboard when the InteractiveObject instance is
	 * ready to accept user input. An InteractiveObject instance is ready to
	 * accept user input after a programmatic call to set the Stage
	 * <code>focus</code> property or a user interaction, such as a "tap." If the
	 * client system has a hardware keyboard available or does not support
	 * virtual keyboards, then the soft keyboard is not raised.</p>
	 *
	 * <p>The InteractiveObject instance dispatches
	 * <code>softKeyboardActivating</code>, <code>softKeyboardActivate</code>,
	 * and <code>softKeyboardDeactivate</code> events when the soft keyboard
	 * raises and lowers.</p>
	 *
	 * <p><b>Note:</b> This property is not supported in AIR applications on
	 * iOS.</p>]]></haxe_doc>
		</needsSoftKeyboard>
		<softKeyboardInputAreaOfInterest public="1"><c path="openfl.geom.Rectangle"/></softKeyboardInputAreaOfInterest>
		<tabEnabled public="1"><x path="Bool"/></tabEnabled>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<requestSoftKeyboard public="1" set="method" line="1155">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Raises a virtual keyboard.
	 *
	 * <p>Calling this method focuses the InteractiveObject instance and raises
	 * the soft keyboard, if necessary. The <code>needsSoftKeyboard</code> must
	 * also be <code>true</code>. A keyboard is not raised if a hardware keyboard
	 * is available, or if the client system does not support virtual
	 * keyboards.</p>
	 *
	 * <p><b>Note:</b> This method is not supported in AIR applications on
	 * iOS.</p>
	 * 
	 * @return A value of <code>true</code> means that the soft keyboard request
	 *         was granted; <code>false</code> means that the soft keyboard was
	 *         not raised.]]></haxe_doc>
		</requestSoftKeyboard>
		<__getInteractive set="method" line="1164" override="1">
			<f a="stack">
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getInteractive>
		<new public="1" set="method" line="1126">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Calling the <code>new InteractiveObject()</code> constructor throws an
	 * <code>ArgumentError</code> exception. You can, however, call constructors
	 * for the following subclasses of InteractiveObject:
	 * <ul>
	 *   <li><code>new SimpleButton()</code></li>
	 *   <li><code>new TextField()</code></li>
	 *   <li><code>new Loader()</code></li>
	 *   <li><code>new Sprite()</code></li>
	 *   <li><code>new MovieClip()</code></li>
	 * </ul>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The InteractiveObject class is the abstract base class for all display
 * objects with which the user can interact, using the mouse, keyboard, or
 * other user input device.
 *
 * <p>You cannot instantiate the InteractiveObject class directly. A call to
 * the <code>new InteractiveObject()</code> constructor throws an
 * <code>ArgumentError</code> exception.</p>
 *
 * <p>The InteractiveObject class itself does not include any APIs for
 * rendering content onscreen. To create a custom subclass of the
 * InteractiveObject class, extend one of the subclasses that do have APIs for
 * rendering content onscreen, such as the Sprite, SimpleButton, TextField, or
 * MovieClip classes.</p>
 * 
 * @event clear                  Dispatched when the user selects 'Clear'(or
 *                               'Delete') from the text context menu. This
 *                               event is dispatched to the object that
 *                               currently has focus. If the object that
 *                               currently has focus is a TextField, the
 *                               default behavior of this event is to cause
 *                               any currently selected text in the text field
 *                               to be deleted.
 * @event click                  Dispatched when a user presses and releases
 *                               the main button of the user's pointing device
 *                               over the same InteractiveObject. For a click
 *                               event to occur, it must always follow this
 *                               series of events in the order of occurrence:
 *                               mouseDown event, then mouseUp. The target
 *                               object must be identical for both of these
 *                               events; otherwise the <code>click</code>
 *                               event does not occur. Any number of other
 *                               mouse events can occur at any time between
 *                               the <code>mouseDown</code> or
 *                               <code>mouseUp</code> events; the
 *                               <code>click</code> event still occurs.
 * @event contextMenu            Dispatched when a user gesture triggers the
 *                               context menu associated with this interactive
 *                               object in an AIR application.
 * @event copy                   Dispatched when the user activates the
 *                               platform-specific accelerator key combination
 *                               for a copy operation or selects 'Copy' from
 *                               the text context menu. This event is
 *                               dispatched to the object that currently has
 *                               focus. If the object that currently has focus
 *                               is a TextField, the default behavior of this
 *                               event is to cause any currently selected text
 *                               in the text field to be copied to the
 *                               clipboard.
 * @event cut                    Dispatched when the user activates the
 *                               platform-specific accelerator key combination
 *                               for a cut operation or selects 'Cut' from the
 *                               text context menu. This event is dispatched
 *                               to the object that currently has focus. If
 *                               the object that currently has focus is a
 *                               TextField, the default behavior of this event
 *                               is to cause any currently selected text in
 *                               the text field to be cut to the clipboard.
 * @event doubleClick            Dispatched when a user presses and releases
 *                               the main button of a pointing device twice in
 *                               rapid succession over the same
 *                               InteractiveObject when that object's
 *                               <code>doubleClickEnabled</code> flag is set
 *                               to <code>true</code>. For a
 *                               <code>doubleClick</code> event to occur, it
 *                               must immediately follow the following series
 *                               of events: <code>mouseDown</code>,
 *                               <code>mouseUp</code>, <code>click</code>,
 *                               <code>mouseDown</code>, <code>mouseUp</code>.
 *                               All of these events must share the same
 *                               target as the <code>doubleClick</code> event.
 *                               The second click, represented by the second
 *                               <code>mouseDown</code> and
 *                               <code>mouseUp</code> events, must occur
 *                               within a specific period of time after the
 *                               <code>click</code> event. The allowable
 *                               length of this period varies by operating
 *                               system and can often be configured by the
 *                               user. If the target is a selectable text
 *                               field, the word under the pointer is selected
 *                               as the default behavior. If the target
 *                               InteractiveObject does not have its
 *                               <code>doubleClickEnabled</code> flag set to
 *                               <code>true</code> it receives two
 *                               <code>click</code> events.
 *
 *                               <p>The <code>doubleClickEnabled</code>
 *                               property defaults to <code>false</code>. </p>
 *
 *                               <p>The double-click text selection behavior
 *                               of a TextField object is not related to the
 *                               <code>doubleClick</code> event. Use
 *                               <code>TextField.doubleClickEnabled</code> to
 *                               control TextField selections.</p>
 * @event focusIn                Dispatched <i>after</i> a display object
 *                               gains focus. This situation happens when a
 *                               user highlights the object with a pointing
 *                               device or keyboard navigation. The recipient
 *                               of such focus is called the target object of
 *                               this event, while the corresponding
 *                               InteractiveObject instance that lost focus
 *                               because of this change is called the related
 *                               object. A reference to the related object is
 *                               stored in the receiving object's
 *                               <code>relatedObject</code> property. The
 *                               <code>shiftKey</code> property is not used.
 *                               This event follows the dispatch of the
 *                               previous object's <code>focusOut</code>
 *                               event.
 * @event focusOut               Dispatched <i>after</i> a display object
 *                               loses focus. This happens when a user
 *                               highlights a different object with a pointing
 *                               device or keyboard navigation. The object
 *                               that loses focus is called the target object
 *                               of this event, while the corresponding
 *                               InteractiveObject instance that receives
 *                               focus is called the related object. A
 *                               reference to the related object is stored in
 *                               the target object's
 *                               <code>relatedObject</code> property. The
 *                               <code>shiftKey</code> property is not used.
 *                               This event precedes the dispatch of the
 *                               <code>focusIn</code> event by the related
 *                               object.
 * @event gesturePan             Dispatched when the user moves a point of
 *                               contact over the InteractiveObject instance
 *                               on a touch-enabled device(such as moving a
 *                               finger from left to right over a display
 *                               object on a mobile phone or tablet with a
 *                               touch screen). Some devices might also
 *                               interpret this contact as a
 *                               <code>mouseOver</code> event and as a
 *                               <code>touchOver</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>mouseOver</code> event or a
 *                               <code>touchOver</code> event or a
 *                               <code>gesturePan</code> event, or all if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the openfl.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gesturePan</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event gesturePressAndTap     Dispatched when the user creates a point of
 *                               contact with an InteractiveObject instance,
 *                               then taps on a touch-enabled device(such as
 *                               placing several fingers over a display object
 *                               to open a menu and then taps one finger to
 *                               select a menu item on a mobile phone or
 *                               tablet with a touch screen). Some devices
 *                               might also interpret this contact as a
 *                               combination of several mouse events, as well.
 *
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, and then provides
 *                               a secondary tap, the InteractiveObject
 *                               instance can dispatch a
 *                               <code>mouseOver</code> event and a
 *                               <code>click</code> event(among others) as
 *                               well as the <code>gesturePressAndTap</code>
 *                               event, or all if the current environment
 *                               supports it. Choose how you want to handle
 *                               the user interaction. Use the
 *                               openfl.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gesturePressAndTap</code> event, you
 *                               can design your event handler to respond to
 *                               the specific needs of a touch-enabled
 *                               environment and provide users with a richer
 *                               touch-enabled experience. You can also handle
 *                               both events, separately, to provide a
 *                               different response for a touch event than a
 *                               mouse event.</p>
 *
 *                               <p>When handling the properties of the event
 *                               object, note that the <code>localX</code> and
 *                               <code>localY</code> properties are set to the
 *                               primary point of contact(the "push"). The
 *                               <code>offsetX</code> and <code>offsetY</code>
 *                               properties are the distance to the secondary
 *                               point of contact(the "tap").</p>
 * @event gestureRotate          Dispatched when the user performs a rotation
 *                               gesture at a point of contact with an
 *                               InteractiveObject instance(such as touching
 *                               two fingers and rotating them over a display
 *                               object on a mobile phone or tablet with a
 *                               touch screen). Two-finger rotation is a
 *                               common rotation gesture, but each device and
 *                               operating system can have its own
 *                               requirements to indicate rotation. Some
 *                               devices might also interpret this contact as
 *                               a combination of several mouse events, as
 *                               well.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>mouseOver</code> event and a
 *                               <code>click</code> event(among others), in
 *                               addition to the <code>gestureRotate</code>
 *                               event, or all if the current environment
 *                               supports it. Choose how you want to handle
 *                               the user interaction. Use the
 *                               openfl.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gestureRotate</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p>When handling the properties of the event
 *                               object, note that the <code>localX</code> and
 *                               <code>localY</code> properties are set to the
 *                               primary point of contact. The
 *                               <code>offsetX</code> and <code>offsetY</code>
 *                               properties are the distance to the point of
 *                               contact where the rotation gesture is
 *                               complete.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event gestureSwipe           Dispatched when the user performs a swipe
 *                               gesture at a point of contact with an
 *                               InteractiveObject instance(such as touching
 *                               three fingers to a screen and then moving
 *                               them in parallel over a display object on a
 *                               mobile phone or tablet with a touch screen).
 *                               Moving several fingers in parallel is a
 *                               common swipe gesture, but each device and
 *                               operating system can have its own
 *                               requirements for a swipe. Some devices might
 *                               also interpret this contact as a combination
 *                               of several mouse events, as well.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, and then moves the
 *                               fingers together, the InteractiveObject
 *                               instance can dispatch a <code>rollOver</code>
 *                               event and a <code>rollOut</code> event(among
 *                               others), in addition to the
 *                               <code>gestureSwipe</code> event, or all if
 *                               the current environment supports it. Choose
 *                               how you want to handle the user interaction.
 *                               If you choose to handle the
 *                               <code>rollOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gestureSwipe</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p>When handling the properties of the event
 *                               object, note that the <code>localX</code> and
 *                               <code>localY</code> properties are set to the
 *                               primary point of contact. The
 *                               <code>offsetX</code> and <code>offsetY</code>
 *                               properties are the distance to the point of
 *                               contact where the swipe gesture is
 *                               complete.</p>
 *
 *                               <p><b>Note:</b> While some devices using the
 *                               Mac OS operating system can interpret a
 *                               four-finger swipe, this API only supports a
 *                               three-finger swipe.</p>
 * @event gestureTwoFingerTap    Dispatched when the user presses two points
 *                               of contact over the same InteractiveObject
 *                               instance on a touch-enabled device(such as
 *                               presses and releases two fingers over a
 *                               display object on a mobile phone or tablet
 *                               with a touch screen). Some devices might also
 *                               interpret this contact as a
 *                               <code>doubleClick</code> event.
 *
 *                               <p>Specifically, if a user taps two fingers
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>doubleClick</code> event or a
 *                               <code>gestureTwoFingerTap</code> event, or
 *                               both if the current environment supports it.
 *                               Choose how you want to handle the user
 *                               interaction. Use the openfl.ui.Multitouch
 *                               class to manage touch event handling(enable
 *                               touch gesture event handling, simple touch
 *                               point event handling, or disable touch events
 *                               so only mouse events are dispatched). If you
 *                               choose to handle the <code>doubleClick</code>
 *                               event, then the same event handler will run
 *                               on a touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>gestureTwoFingerTap</code> event, you
 *                               can design your event handler to respond to
 *                               the specific needs of a touch-enabled
 *                               environment and provide users with a richer
 *                               touch-enabled experience. You can also handle
 *                               both events, separately, to provide a
 *                               different response for a touch event than a
 *                               mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event gestureZoom            Dispatched when the user performs a zoom
 *                               gesture at a point of contact with an
 *                               InteractiveObject instance(such as touching
 *                               two fingers to a screen and then quickly
 *                               spreading the fingers apart over a display
 *                               object on a mobile phone or tablet with a
 *                               touch screen). Moving fingers apart is a
 *                               common zoom gesture, but each device and
 *                               operating system can have its own
 *                               requirements to indicate zoom. Some devices
 *                               might also interpret this contact as a
 *                               combination of several mouse events, as well.
 *
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, and then moves the
 *                               fingers apart, the InteractiveObject instance
 *                               can dispatch a <code>mouseOver</code> event
 *                               and a <code>click</code> event(among
 *                               others), in addition to the
 *                               <code>gestureZoom</code> event, or all if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the openfl.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gestureZoom</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p>When handling the properties of the event
 *                               object, note that the <code>localX</code> and
 *                               <code>localY</code> properties are set to the
 *                               primary point of contact. The
 *                               <code>offsetX</code> and <code>offsetY</code>
 *                               properties are the distance to the point of
 *                               contact where the zoom gesture is
 *                               complete.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event imeStartComposition    This event is dispatched to any client app
 *                               that supports inline input with an IME
 * @event keyDown                Dispatched when the user presses a key.
 *                               Mappings between keys and specific characters
 *                               vary by device and operating system. This
 *                               event type is generated after such a mapping
 *                               occurs but before the processing of an input
 *                               method editor(IME). IMEs are used to enter
 *                               characters, such as Chinese ideographs, that
 *                               the standard QWERTY keyboard is ill-equipped
 *                               to produce. This event occurs before the
 *                               <code>keyUp</code> event.
 *
 *                               <p>In AIR, canceling this event prevents the
 *                               character from being entered into a text
 *                               field.</p>
 * @event keyFocusChange         Dispatched when the user attempts to change
 *                               focus by using keyboard navigation. The
 *                               default behavior of this event is to change
 *                               the focus and dispatch the corresponding
 *                               <code>focusIn</code> and
 *                               <code>focusOut</code> events.
 *
 *                               <p>This event is dispatched to the object
 *                               that currently has focus. The related object
 *                               for this event is the InteractiveObject
 *                               instance that receives focus if you do not
 *                               prevent the default behavior. You can prevent
 *                               the change in focus by calling the
 *                               <code>preventDefault()</code> method in an
 *                               event listener that is properly registered
 *                               with the target object. Focus changes and
 *                               <code>focusIn</code> and
 *                               <code>focusOut</code> events are dispatched
 *                               by default.</p>
 * @event keyUp                  Dispatched when the user releases a key.
 *                               Mappings between keys and specific characters
 *                               vary by device and operating system. This
 *                               event type is generated after such a mapping
 *                               occurs but before the processing of an input
 *                               method editor(IME). IMEs are used to enter
 *                               characters, such as Chinese ideographs, that
 *                               the standard QWERTY keyboard is ill-equipped
 *                               to produce. This event occurs after a
 *                               <code>keyDown</code> event and has the
 *                               following characteristics:
 * @event middleClick            Dispatched when a user presses and releases
 *                               the middle button of the user's pointing
 *                               device over the same InteractiveObject. For a
 *                               <code>middleClick</code> event to occur, it
 *                               must always follow this series of events in
 *                               the order of occurrence:
 *                               <code>middleMouseDown</code> event, then
 *                               <code>middleMouseUp</code>. The target object
 *                               must be identical for both of these events;
 *                               otherwise the <code>middleClick</code> event
 *                               does not occur. Any number of other mouse
 *                               events can occur at any time between the
 *                               <code>middleMouseDown</code> or
 *                               <code>middleMouseUp</code> events; the
 *                               <code>middleClick</code> event still occurs.
 * @event middleMouseDown        Dispatched when a user presses the middle
 *                               pointing device button over an
 *                               InteractiveObject instance.
 * @event middleMouseUp          Dispatched when a user releases the pointing
 *                               device button over an InteractiveObject
 *                               instance.
 * @event mouseDown              Dispatched when a user presses the pointing
 *                               device button over an InteractiveObject
 *                               instance. If the target is a SimpleButton
 *                               instance, the SimpleButton instance displays
 *                               the <code>downState</code> display object as
 *                               the default behavior. If the target is a
 *                               selectable text field, the text field begins
 *                               selection as the default behavior.
 * @event mouseFocusChange       Dispatched when the user attempts to change
 *                               focus by using a pointer device. The default
 *                               behavior of this event is to change the focus
 *                               and dispatch the corresponding
 *                               <code>focusIn</code> and
 *                               <code>focusOut</code> events.
 *
 *                               <p>This event is dispatched to the object
 *                               that currently has focus. The related object
 *                               for this event is the InteractiveObject
 *                               instance that receives focus if you do not
 *                               prevent the default behavior. You can prevent
 *                               the change in focus by calling
 *                               <code>preventDefault()</code> in an event
 *                               listener that is properly registered with the
 *                               target object. The <code>shiftKey</code>
 *                               property is not used. Focus changes and
 *                               <code>focusIn</code> and
 *                               <code>focusOut</code> events are dispatched
 *                               by default.</p>
 * @event mouseMove              Dispatched when a user moves the pointing
 *                               device while it is over an InteractiveObject.
 *                               If the target is a text field that the user
 *                               is selecting, the selection is updated as the
 *                               default behavior.
 * @event mouseOut               Dispatched when the user moves a pointing
 *                               device away from an InteractiveObject
 *                               instance. The event target is the object
 *                               previously under the pointing device. The
 *                               <code>relatedObject</code> is the object the
 *                               pointing device has moved to. If the target
 *                               is a SimpleButton instance, the button
 *                               displays the <code>upState</code> display
 *                               object as the default behavior.
 *
 *                               <p>The <code>mouseOut</code> event is
 *                               dispatched each time the mouse leaves the
 *                               area of any child object of the display
 *                               object container, even if the mouse remains
 *                               over another child object of the display
 *                               object container. This is different behavior
 *                               than the purpose of the <code>rollOut</code>
 *                               event, which is to simplify the coding of
 *                               rollover behaviors for display object
 *                               containers with children. When the mouse
 *                               leaves the area of a display object or the
 *                               area of any of its children to go to an
 *                               object that is not one of its children, the
 *                               display object dispatches the
 *                               <code>rollOut</code> event.The
 *                               <code>rollOut</code> events are dispatched
 *                               consecutively up the parent chain of the
 *                               object, starting with the object and ending
 *                               with the highest parent that is neither the
 *                               root nor an ancestor of the
 *                               <code>relatedObject</code>.</p>
 * @event mouseOver              Dispatched when the user moves a pointing
 *                               device over an InteractiveObject instance.
 *                               The <code>relatedObject</code> is the object
 *                               that was previously under the pointing
 *                               device. If the target is a SimpleButton
 *                               instance, the object displays the
 *                               <code>overState</code> or
 *                               <code>upState</code> display object,
 *                               depending on whether the mouse button is
 *                               down, as the default behavior.
 *
 *                               <p>The <code>mouseOver</code> event is
 *                               dispatched each time the mouse enters the
 *                               area of any child object of the display
 *                               object container, even if the mouse was
 *                               already over another child object of the
 *                               display object container. This is different
 *                               behavior than the purpose of the
 *                               <code>rollOver</code> event, which is to
 *                               simplify the coding of rollout behaviors for
 *                               display object containers with children. When
 *                               the mouse enters the area of a display object
 *                               or the area of any of its children from an
 *                               object that is not one of its children, the
 *                               display object dispatches the
 *                               <code>rollOver</code> event. The
 *                               <code>rollOver</code> events are dispatched
 *                               consecutively down the parent chain of the
 *                               object, starting with the highest parent that
 *                               is neither the root nor an ancestor of the
 *                               <code>relatedObject</code> and ending with
 *                               the object.</p>
 * @event mouseUp                Dispatched when a user releases the pointing
 *                               device button over an InteractiveObject
 *                               instance. If the target is a SimpleButton
 *                               instance, the object displays the
 *                               <code>upState</code> display object. If the
 *                               target is a selectable text field, the text
 *                               field ends selection as the default behavior.
 * @event mouseWheel             Dispatched when a mouse wheel is spun over an
 *                               InteractiveObject instance. If the target is
 *                               a text field, the text scrolls as the default
 *                               behavior. Only available on Microsoft Windows
 *                               operating systems.
 * @event nativeDragComplete     Dispatched by the drag initiator
 *                               InteractiveObject when the user releases the
 *                               drag gesture.
 *
 *                               <p>The event's dropAction property indicates
 *                               the action set by the drag target object; a
 *                               value of "none"
 *                              (<code>DragActions.NONE</code>) indicates
 *                               that the drop was canceled or was not
 *                               accepted.</p>
 *
 *                               <p>The <code>nativeDragComplete</code> event
 *                               handler is a convenient place to update the
 *                               state of the initiating display object, for
 *                               example, by removing an item from a list(on
 *                               a drag action of "move"), or by changing the
 *                               visual properties.</p>
 * @event nativeDragDrop         Dispatched by the target InteractiveObject
 *                               when a dragged object is dropped on it and
 *                               the drop has been accepted with a call to
 *                               DragManager.acceptDragDrop().
 *
 *                               <p>Access the dropped data using the event
 *                               object <code>clipboard</code> property.</p>
 *
 *                               <p>The handler for this event should set the
 *                               <code>DragManager.dropAction</code> property
 *                               to provide feedback to the initiator object
 *                               about which drag action was taken. If no
 *                               value is set, the DragManager will select a
 *                               default value from the list of allowed
 *                               actions.</p>
 * @event nativeDragEnter        Dispatched by an InteractiveObject when a
 *                               drag gesture enters its boundary.
 *
 *                               <p>Handle either the
 *                               <code>nativeDragEnter</code> or
 *                               <code>nativeDragOver</code> events to allow
 *                               the display object to become the drop
 *                               target.</p>
 *
 *                               <p>To determine whether the dispatching
 *                               display object can accept the drop, check the
 *                               suitability of the data in
 *                               <code>clipboard</code> property of the event
 *                               object, and the allowed drag actions in the
 *                               <code>allowedActions</code> property.</p>
 * @event nativeDragExit         Dispatched by an InteractiveObject when a
 *                               drag gesture leaves its boundary.
 * @event nativeDragOver         Dispatched by an InteractiveObject
 *                               continually while a drag gesture remains
 *                               within its boundary.
 *
 *                               <p><code>nativeDragOver</code> events are
 *                               dispatched whenever the mouse is moved. On
 *                               Windows and Mac, they are also dispatched on
 *                               a short timer interval even when the mouse
 *                               has not moved.</p>
 *
 *                               <p>Handle either the
 *                               <code>nativeDragOver</code> or
 *                               <code>nativeDragEnter</code> events to allow
 *                               the display object to become the drop
 *                               target.</p>
 *
 *                               <p>To determine whether the dispatching
 *                               display object can accept the drop, check the
 *                               suitability of the data in
 *                               <code>clipboard</code> property of the event
 *                               object, and the allowed drag actions in the
 *                               <code>allowedActions</code> property.</p>
 * @event nativeDragStart        Dispatched at the beginning of a drag
 *                               operation by the InteractiveObject that is
 *                               specified as the drag initiator in the
 *                               DragManager.doDrag() call.
 * @event nativeDragUpdate       Dispatched during a drag operation by the
 *                               InteractiveObject that is specified as the
 *                               drag initiator in the DragManager.doDrag()
 *                               call.
 *
 *                               <p><code>nativeDragUpdate</code> events are
 *                               not dispatched on Linux.</p>
 * @event paste                  Dispatched when the user activates the
 *                               platform-specific accelerator key combination
 *                               for a paste operation or selects 'Paste' from
 *                               the text context menu. This event is
 *                               dispatched to the object that currently has
 *                               focus. If the object that currently has focus
 *                               is a TextField, the default behavior of this
 *                               event is to cause the contents of the
 *                               clipboard to be pasted into the text field at
 *                               the current insertion point replacing any
 *                               currently selected text in the text field.
 * @event rightClick             Dispatched when a user presses and releases
 *                               the right button of the user's pointing
 *                               device over the same InteractiveObject. For a
 *                               <code>rightClick</code> event to occur, it
 *                               must always follow this series of events in
 *                               the order of occurrence:
 *                               <code>rightMouseDown</code> event, then
 *                               <code>rightMouseUp</code>. The target object
 *                               must be identical for both of these events;
 *                               otherwise the <code>rightClick</code> event
 *                               does not occur. Any number of other mouse
 *                               events can occur at any time between the
 *                               <code>rightMouseDown</code> or
 *                               <code>rightMouseUp</code> events; the
 *                               <code>rightClick</code> event still occurs.
 * @event rightMouseDown         Dispatched when a user presses the pointing
 *                               device button over an InteractiveObject
 *                               instance.
 * @event rightMouseUp           Dispatched when a user releases the pointing
 *                               device button over an InteractiveObject
 *                               instance.
 * @event rollOut                Dispatched when the user moves a pointing
 *                               device away from an InteractiveObject
 *                               instance. The event target is the object
 *                               previously under the pointing device or a
 *                               parent of that object. The
 *                               <code>relatedObject</code> is the object that
 *                               the pointing device has moved to. The
 *                               <code>rollOut</code> events are dispatched
 *                               consecutively up the parent chain of the
 *                               object, starting with the object and ending
 *                               with the highest parent that is neither the
 *                               root nor an ancestor of the
 *                               <code>relatedObject</code>.
 *
 *                               <p>The purpose of the <code>rollOut</code>
 *                               event is to simplify the coding of rollover
 *                               behaviors for display object containers with
 *                               children. When the mouse leaves the area of a
 *                               display object or the area of any of its
 *                               children to go to an object that is not one
 *                               of its children, the display object
 *                               dispatches the <code>rollOut</code> event.
 *                               This is different behavior than that of the
 *                               <code>mouseOut</code> event, which is
 *                               dispatched each time the mouse leaves the
 *                               area of any child object of the display
 *                               object container, even if the mouse remains
 *                               over another child object of the display
 *                               object container.</p>
 * @event rollOver               Dispatched when the user moves a pointing
 *                               device over an InteractiveObject instance.
 *                               The event target is the object under the
 *                               pointing device or a parent of that object.
 *                               The <code>relatedObject</code> is the object
 *                               that was previously under the pointing
 *                               device. The <code>rollOver</code> events are
 *                               dispatched consecutively down the parent
 *                               chain of the object, starting with the
 *                               highest parent that is neither the root nor
 *                               an ancestor of the <code>relatedObject</code>
 *                               and ending with the object.
 *
 *                               <p>The purpose of the <code>rollOver</code>
 *                               event is to simplify the coding of rollout
 *                               behaviors for display object containers with
 *                               children. When the mouse enters the area of a
 *                               display object or the area of any of its
 *                               children from an object that is not one of
 *                               its children, the display object dispatches
 *                               the <code>rollOver</code> event. This is
 *                               different behavior than that of the
 *                               <code>mouseOver</code> event, which is
 *                               dispatched each time the mouse enters the
 *                               area of any child object of the display
 *                               object container, even if the mouse was
 *                               already over another child object of the
 *                               display object container. </p>
 * @event selectAll              Dispatched when the user activates the
 *                               platform-specific accelerator key combination
 *                               for a select all operation or selects 'Select
 *                               All' from the text context menu. This event
 *                               is dispatched to the object that currently
 *                               has focus. If the object that currently has
 *                               focus is a TextField, the default behavior of
 *                               this event is to cause all the contents of
 *                               the text field to be selected.
 * @event softKeyboardActivate   Dispatched immediately after the soft
 *                               keyboard is raised.
 * @event softKeyboardActivating Dispatched immediately before the soft
 *                               keyboard is raised.
 * @event softKeyboardDeactivate Dispatched immediately after the soft
 *                               keyboard is lowered.
 * @event tabChildrenChange      Dispatched when the value of the object's
 *                               <code>tabChildren</code> flag changes.
 * @event tabEnabledChange       Dispatched when the object's
 *                               <code>tabEnabled</code> flag changes.
 * @event tabIndexChange         Dispatched when the value of the object's
 *                               <code>tabIndex</code> property changes.
 * @event textInput              Dispatched when a user enters one or more
 *                               characters of text. Various text input
 *                               methods can generate this event, including
 *                               standard keyboards, input method editors
 *                              (IMEs), voice or speech recognition systems,
 *                               and even the act of pasting plain text with
 *                               no formatting or style information.
 * @event touchBegin             Dispatched when the user first contacts a
 *                               touch-enabled device(such as touches a
 *                               finger to a mobile phone or tablet with a
 *                               touch screen). Some devices might also
 *                               interpret this contact as a
 *                               <code>mouseDown</code> event.
 *
 *                               <p>Specifically, if a user touches a finger
 *                               to a touch screen, the InteractiveObject
 *                               instance can dispatch a
 *                               <code>mouseDown</code> event or a
 *                               <code>touchBegin</code> event, or both if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the openfl.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseDown</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>touchBegin</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchEnd               Dispatched when the user removes contact with
 *                               a touch-enabled device(such as lifts a
 *                               finger off a mobile phone or tablet with a
 *                               touch screen). Some devices might also
 *                               interpret this contact as a
 *                               <code>mouseUp</code> event.
 *
 *                               <p>Specifically, if a user lifts a finger
 *                               from a touch screen, the InteractiveObject
 *                               instance can dispatch a <code>mouseUp</code>
 *                               event or a <code>touchEnd</code> event, or
 *                               both if the current environment supports it.
 *                               Choose how you want to handle the user
 *                               interaction. Use the openfl.ui.Multitouch
 *                               class to manage touch event handling(enable
 *                               touch gesture event handling, simple touch
 *                               point event handling, or disable touch events
 *                               so only mouse events are dispatched). If you
 *                               choose to handle the <code>mouseUp</code>
 *                               event, then the same event handler will run
 *                               on a touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchEnd</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchMove              Dispatched when the user moves the point of
 *                               contact with a touch-enabled device(such as
 *                               drags a finger across a mobile phone or
 *                               tablet with a touch screen). Some devices
 *                               might also interpret this contact as a
 *                               <code>mouseMove</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               across a touch screen, the InteractiveObject
 *                               instance can dispatch a
 *                               <code>mouseMove</code> event or a
 *                               <code>touchMove</code> event, or both if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the openfl.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseMove</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>touchMove</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchOut               Dispatched when the user moves the point of
 *                               contact away from InteractiveObject instance
 *                               on a touch-enabled device(such as drags a
 *                               finger from one display object to another on
 *                               a mobile phone or tablet with a touch
 *                               screen). Some devices might also interpret
 *                               this contact as a <code>mouseOut</code>
 *                               event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               across a touch screen, the InteractiveObject
 *                               instance can dispatch a <code>mouseOut</code>
 *                               event or a <code>touchOut</code> event, or
 *                               both if the current environment supports it.
 *                               Choose how you want to handle the user
 *                               interaction. Use the openfl.ui.Multitouch
 *                               class to manage touch event handling(enable
 *                               touch gesture event handling, simple touch
 *                               point event handling, or disable touch events
 *                               so only mouse events are dispatched). If you
 *                               choose to handle the <code>mouseOut</code>
 *                               event, then the same event handler will run
 *                               on a touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchOut</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchOver              Dispatched when the user moves the point of
 *                               contact over an InteractiveObject instance on
 *                               a touch-enabled device(such as drags a
 *                               finger from a point outside a display object
 *                               to a point over a display object on a mobile
 *                               phone or tablet with a touch screen). Some
 *                               devices might also interpret this contact as
 *                               a <code>mouseOver</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>mouseOver</code> event or a
 *                               <code>touchOver</code> event, or both if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the openfl.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>touchOver</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchRollOut           Dispatched when the user moves the point of
 *                               contact away from an InteractiveObject
 *                               instance on a touch-enabled device(such as
 *                               drags a finger from over a display object to
 *                               a point outside the display object on a
 *                               mobile phone or tablet with a touch screen).
 *                               Some devices might also interpret this
 *                               contact as a <code>rollOut</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>rollOut</code> event or a
 *                               <code>touchRollOut</code> event, or both if
 *                               the current environment supports it. Choose
 *                               how you want to handle the user interaction.
 *                               Use the openfl.ui.Multitouch class to manage
 *                               touch event handling(enable touch gesture
 *                               event handling, simple touch point event
 *                               handling, or disable touch events so only
 *                               mouse events are dispatched). If you choose
 *                               to handle the <code>rollOut</code> event,
 *                               then the same event handler will run on a
 *                               touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchRollOut</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchRollOver          Dispatched when the user moves the point of
 *                               contact over an InteractiveObject instance on
 *                               a touch-enabled device(such as drags a
 *                               finger from a point outside a display object
 *                               to a point over a display object on a mobile
 *                               phone or tablet with a touch screen). Some
 *                               devices might also interpret this contact as
 *                               a <code>rollOver</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>rollOver</code> event or a
 *                               <code>touchRollOver</code> event, or both if
 *                               the current environment supports it. Choose
 *                               how you want to handle the user interaction.
 *                               Use the openfl.ui.Multitouch class to manage
 *                               touch event handling(enable touch gesture
 *                               event handling, simple touch point event
 *                               handling, or disable touch events so only
 *                               mouse events are dispatched). If you choose
 *                               to handle the <code>rollOver</code> event,
 *                               then the same event handler will run on a
 *                               touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchRollOver</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchTap               Dispatched when the user lifts the point of
 *                               contact over the same InteractiveObject
 *                               instance on which the contact was initiated
 *                               on a touch-enabled device(such as presses
 *                               and releases a finger from a single point
 *                               over a display object on a mobile phone or
 *                               tablet with a touch screen). Some devices
 *                               might also interpret this contact as a
 *                               <code>click</code> event.
 *
 *                               <p>Specifically, if a user taps a finger over
 *                               an InteractiveObject, the InteractiveObject
 *                               instance can dispatch a <code>click</code>
 *                               event or a <code>touchTap</code> event, or
 *                               both if the current environment supports it.
 *                               Choose how you want to handle the user
 *                               interaction. Use the openfl.ui.Multitouch
 *                               class to manage touch event handling(enable
 *                               touch gesture event handling, simple touch
 *                               point event handling, or disable touch events
 *                               so only mouse events are dispatched). If you
 *                               choose to handle the <code>click</code>
 *                               event, then the same event handler will run
 *                               on a touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchTap</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>]]></haxe_doc>
	</class>
	<class path="openfl.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/DisplayObjectContainer.hx">
		<extends path="openfl.display.InteractiveObject"/>
		<mouseChildren public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Determines whether or not the children of the object are mouse, or user
	 * input device, enabled. If an object is enabled, a user can interact with
	 * it by using a mouse or user input device. The default is
	 * <code>true</code>.
	 *
	 * <p>This property is useful when you create a button with an instance of
	 * the Sprite class(instead of using the SimpleButton class). When you use a
	 * Sprite instance to create a button, you can choose to decorate the button
	 * by using the <code>addChild()</code> method to add additional Sprite
	 * instances. This process can cause unexpected behavior with mouse events
	 * because the Sprite instances you add as children can become the target
	 * object of a mouse event when you expect the parent instance to be the
	 * target object. To ensure that the parent instance serves as the target
	 * objects for mouse events, you can set the <code>mouseChildren</code>
	 * property of the parent instance to <code>false</code>.</p>
	 *
	 * <p> No event is dispatched by setting this property. You must use the
	 * <code>addEventListener()</code> method to create interactive
	 * functionality.</p>]]></haxe_doc>
		</mouseChildren>
		<numChildren public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Returns the number of children of this object.</haxe_doc>
		</numChildren>
		<tabChildren public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Determines whether the children of the object are tab enabled. Enables or
	 * disables tabbing for the children of the object. The default is
	 * <code>true</code>.
	 *
	 * <p><b>Note:</b> Do not use the <code>tabChildren</code> property with
	 * Flex. Instead, use the
	 * <code>mx.core.UIComponent.hasFocusableChildren</code> property.</p>
	 * 
	 * @throws IllegalOperationError Calling this property of the Stage object
	 *                               throws an exception. The Stage object does
	 *                               not implement this property.]]></haxe_doc>
		</tabChildren>
		<__children>
			<c path="Array"><c path="openfl.display.DisplayObject"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__children>
		<__removedChildren>
			<c path="Array"><c path="openfl.display.DisplayObject"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__removedChildren>
		<addChild public="1" set="method" line="138">
			<f a="child">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Adds a child DisplayObject instance to this DisplayObjectContainer
	 * instance. The child is added to the front(top) of all other children in
	 * this DisplayObjectContainer instance.(To add a child to a specific index
	 * position, use the <code>addChildAt()</code> method.)
	 *
	 * <p>If you add a child object that already has a different display object
	 * container as a parent, the object is removed from the child list of the
	 * other display object container. </p>
	 *
	 * <p><b>Note:</b> The command <code>stage.addChild()</code> can cause
	 * problems with a published SWF file, including security problems and
	 * conflicts with other loaded SWF files. There is only one Stage within a
	 * Flash runtime instance, no matter how many SWF files you load into the
	 * runtime. So, generally, objects should not be added to the Stage,
	 * directly, at all. The only object the Stage should contain is the root
	 * object. Create a DisplayObjectContainer to contain all of the items on the
	 * display list. Then, if necessary, add that DisplayObjectContainer instance
	 * to the Stage.</p>
	 * 
	 * @param child The DisplayObject instance to add as a child of this
	 *              DisplayObjectContainer instance.
	 * @return The DisplayObject instance that you pass in the <code>child</code>
	 *         parameter.
	 * @throws ArgumentError Throws if the child is the same as the parent. Also
	 *                       throws if the caller is a child(or grandchild etc.)
	 *                       of the child being added.
	 * @event added Dispatched when a display object is added to the display
	 *              list.]]></haxe_doc>
		</addChild>
		<addChildAt public="1" set="method" line="197">
			<f a="child:index">
				<c path="openfl.display.DisplayObject"/>
				<x path="Int"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Adds a child DisplayObject instance to this DisplayObjectContainer
	 * instance. The child is added at the index position specified. An index of
	 * 0 represents the back(bottom) of the display list for this
	 * DisplayObjectContainer object.
	 *
	 * <p>For example, the following example shows three display objects, labeled
	 * a, b, and c, at index positions 0, 2, and 1, respectively:</p>
	 *
	 * <p>If you add a child object that already has a different display object
	 * container as a parent, the object is removed from the child list of the
	 * other display object container. </p>
	 * 
	 * @param child The DisplayObject instance to add as a child of this
	 *              DisplayObjectContainer instance.
	 * @param index The index position to which the child is added. If you
	 *              specify a currently occupied index position, the child object
	 *              that exists at that position and all higher positions are
	 *              moved up one position in the child list.
	 * @return The DisplayObject instance that you pass in the <code>child</code>
	 *         parameter.
	 * @throws ArgumentError Throws if the child is the same as the parent. Also
	 *                       throws if the caller is a child(or grandchild etc.)
	 *                       of the child being added.
	 * @throws RangeError    Throws if the index position does not exist in the
	 *                       child list.
	 * @event added Dispatched when a display object is added to the display
	 *              list.]]></haxe_doc>
		</addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method" line="259">
			<f a="point">
				<c path="openfl.geom.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Indicates whether the security restrictions would cause any display
	 * objects to be omitted from the list returned by calling the
	 * <code>DisplayObjectContainer.getObjectsUnderPoint()</code> method with the
	 * specified <code>point</code> point. By default, content from one domain
	 * cannot access objects from another domain unless they are permitted to do
	 * so with a call to the <code>Security.allowDomain()</code> method. For more
	 * information, related to security, see the Flash Player Developer Center
	 * Topic: <a href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.
	 *
	 * <p>The <code>point</code> parameter is in the coordinate space of the
	 * Stage, which may differ from the coordinate space of the display object
	 * container(unless the display object container is the Stage). You can use
	 * the <code>globalToLocal()</code> and the <code>localToGlobal()</code>
	 * methods to convert points between these coordinate spaces.</p>
	 * 
	 * @param point The point under which to look.
	 * @return <code>true</code> if the point contains child display objects with
	 *         security restrictions.]]></haxe_doc>
		</areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method" line="278">
			<f a="child">
				<c path="openfl.display.DisplayObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determines whether the specified display object is a child of the
	 * DisplayObjectContainer instance or the instance itself. The search
	 * includes the entire display list including this DisplayObjectContainer
	 * instance. Grandchildren, great-grandchildren, and so on each return
	 * <code>true</code>.
	 * 
	 * @param child The child object to test.
	 * @return <code>true</code> if the <code>child</code> object is a child of
	 *         the DisplayObjectContainer or the container itself; otherwise
	 *         <code>false</code>.]]></haxe_doc>
		</contains>
		<getChildAt public="1" set="method" line="312">
			<f a="index">
				<x path="Int"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Returns the child display object instance that exists at the specified
	 * index.
	 * 
	 * @param index The index position of the child object.
	 * @return The child display object at the specified index position.
	 * @throws RangeError    Throws if the index does not exist in the child
	 *                       list.
	 * @throws SecurityError This child display object belongs to a sandbox to
	 *                       which you do not have access. You can avoid this
	 *                       situation by having the child movie call
	 *                       <code>Security.allowDomain()</code>.]]></haxe_doc>
		</getChildAt>
		<getChildByName public="1" set="method" line="343">
			<f a="name">
				<c path="String"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Returns the child display object that exists with the specified name. If
	 * more that one child display object has the specified name, the method
	 * returns the first object in the child list.
	 *
	 * <p>The <code>getChildAt()</code> method is faster than the
	 * <code>getChildByName()</code> method. The <code>getChildAt()</code> method
	 * accesses a child from a cached array, whereas the
	 * <code>getChildByName()</code> method has to traverse a linked list to
	 * access a child.</p>
	 * 
	 * @param name The name of the child to return.
	 * @return The child display object with the specified name.
	 * @throws SecurityError This child display object belongs to a sandbox to
	 *                       which you do not have access. You can avoid this
	 *                       situation by having the child movie call the
	 *                       <code>Security.allowDomain()</code> method.]]></haxe_doc>
		</getChildByName>
		<getChildIndex public="1" set="method" line="364">
			<f a="child">
				<c path="openfl.display.DisplayObject"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Returns the index position of a <code>child</code> DisplayObject instance.
	 * 
	 * @param child The DisplayObject instance to identify.
	 * @return The index position of the child display object to identify.
	 * @throws ArgumentError Throws if the child parameter is not a child of this
	 *                       object.]]></haxe_doc>
		</getChildIndex>
		<getObjectsUnderPoint public="1" set="method" line="396">
			<f a="point">
				<c path="openfl.geom.Point"/>
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
			</f>
			<haxe_doc><![CDATA[* Returns an array of objects that lie under the specified point and are
	 * children(or grandchildren, and so on) of this DisplayObjectContainer
	 * instance. Any child objects that are inaccessible for security reasons are
	 * omitted from the returned array. To determine whether this security
	 * restriction affects the returned array, call the
	 * <code>areInaccessibleObjectsUnderPoint()</code> method.
	 *
	 * <p>The <code>point</code> parameter is in the coordinate space of the
	 * Stage, which may differ from the coordinate space of the display object
	 * container(unless the display object container is the Stage). You can use
	 * the <code>globalToLocal()</code> and the <code>localToGlobal()</code>
	 * methods to convert points between these coordinate spaces.</p>
	 * 
	 * @param point The point under which to look.
	 * @return An array of objects that lie under the specified point and are
	 *         children(or grandchildren, and so on) of this
	 *         DisplayObjectContainer instance.]]></haxe_doc>
		</getObjectsUnderPoint>
		<removeChild public="1" set="method" line="426">
			<f a="child">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Removes the specified <code>child</code> DisplayObject instance from the
	 * child list of the DisplayObjectContainer instance. The <code>parent</code>
	 * property of the removed child is set to <code>null</code> , and the object
	 * is garbage collected if no other references to the child exist. The index
	 * positions of any display objects above the child in the
	 * DisplayObjectContainer are decreased by 1.
	 *
	 * <p>The garbage collector reallocates unused memory space. When a variable
	 * or object is no longer actively referenced or stored somewhere, the
	 * garbage collector sweeps through and wipes out the memory space it used to
	 * occupy if no other references to it exist.</p>
	 * 
	 * @param child The DisplayObject instance to remove.
	 * @return The DisplayObject instance that you pass in the <code>child</code>
	 *         parameter.
	 * @throws ArgumentError Throws if the child parameter is not a child of this
	 *                       object.]]></haxe_doc>
		</removeChild>
		<removeChildAt public="1" set="method" line="472">
			<f a="index">
				<x path="Int"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Removes a child DisplayObject from the specified <code>index</code>
	 * position in the child list of the DisplayObjectContainer. The
	 * <code>parent</code> property of the removed child is set to
	 * <code>null</code>, and the object is garbage collected if no other
	 * references to the child exist. The index positions of any display objects
	 * above the child in the DisplayObjectContainer are decreased by 1.
	 *
	 * <p>The garbage collector reallocates unused memory space. When a variable
	 * or object is no longer actively referenced or stored somewhere, the
	 * garbage collector sweeps through and wipes out the memory space it used to
	 * occupy if no other references to it exist.</p>
	 * 
	 * @param index The child index of the DisplayObject to remove.
	 * @return The DisplayObject instance that was removed.
	 * @throws RangeError    Throws if the index does not exist in the child
	 *                       list.
	 * @throws SecurityError This child display object belongs to a sandbox to
	 *                       which the calling object does not have access. You
	 *                       can avoid this situation by having the child movie
	 *                       call the <code>Security.allowDomain()</code> method.]]></haxe_doc>
		</removeChildAt>
		<removeChildren public="1" set="method" line="485"><f a="?beginIndex:?endIndex" v="0:2147483647">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></removeChildren>
		<setChildIndex public="1" set="method" line="548">
			<f a="child:index">
				<c path="openfl.display.DisplayObject"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Changes the position of an existing child in the display object container.
	 * This affects the layering of child objects. For example, the following
	 * example shows three display objects, labeled a, b, and c, at index
	 * positions 0, 1, and 2, respectively:
	 *
	 * <p>When you use the <code>setChildIndex()</code> method and specify an
	 * index position that is already occupied, the only positions that change
	 * are those in between the display object's former and new position. All
	 * others will stay the same. If a child is moved to an index LOWER than its
	 * current index, all children in between will INCREASE by 1 for their index
	 * reference. If a child is moved to an index HIGHER than its current index,
	 * all children in between will DECREASE by 1 for their index reference. For
	 * example, if the display object container in the previous example is named
	 * <code>container</code>, you can swap the position of the display objects
	 * labeled a and b by calling the following code:</p>
	 *
	 * <p>This code results in the following arrangement of objects:</p>
	 * 
	 * @param child The child DisplayObject instance for which you want to change
	 *              the index number.
	 * @param index The resulting index number for the <code>child</code> display
	 *              object.
	 * @throws ArgumentError Throws if the child parameter is not a child of this
	 *                       object.
	 * @throws RangeError    Throws if the index does not exist in the child
	 *                       list.]]></haxe_doc>
		</setChildIndex>
		<swapChildren public="1" set="method" line="570">
			<f a="child1:child2">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Swaps the z-order(front-to-back order) of the two specified child
	 * objects. All other child objects in the display object container remain in
	 * the same index positions.
	 * 
	 * @param child1 The first child object.
	 * @param child2 The second child object.
	 * @throws ArgumentError Throws if either child parameter is not a child of
	 *                       this object.</haxe_doc>
		</swapChildren>
		<swapChildrenAt public="1" set="method" line="617">
			<f a="child1:child2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Swaps the z-order(front-to-back order) of the child objects at the two
	 * specified index positions in the child list. All other child objects in
	 * the display object container remain in the same index positions.
	 * 
	 * @param index1 The index position of the first child object.
	 * @param index2 The index position of the second child object.
	 * @throws RangeError If either index does not exist in the child list.</haxe_doc>
		</swapChildrenAt>
		<__broadcast set="method" line="627" override="1">
			<f a="event:notifyChilden">
				<c path="openfl.events.Event"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__broadcast>
		<__getBounds set="method" line="656" override="1">
			<f a="rect:matrix">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getBounds>
		<__hitTest set="method" line="687" override="1">
			<f a="x:y:shapeFlag:stack:interactiveOnly">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__hitTest>
		<__renderCanvas public="1" set="method" line="734" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderCanvas>
		<__renderDOM public="1" set="method" line="773" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderDOM>
		<__renderGL public="1" set="method" line="812" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderGL>
		<__renderMask public="1" set="method" line="827" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderMask>
		<__setStageReference set="method" line="837" override="1">
			<f a="stage">
				<c path="openfl.display.Stage"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setStageReference>
		<__update public="1" set="method" line="866" override="1">
			<f a="transformOnly:updateChildren">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__update>
		<__updateChildren public="1" set="method" line="891" override="1">
			<f a="transformOnly">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__updateChildren>
		<get_numChildren set="method" line="911">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numChildren>
		<new public="1" set="method" line="96">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Calling the <code>new DisplayObjectContainer()</code> constructor throws
	 * an <code>ArgumentError</code> exception. You <i>can</i>, however, call
	 * constructors for the following subclasses of DisplayObjectContainer:
	 * <ul>
	 *   <li><code>new Loader()</code></li>
	 *   <li><code>new Sprite()</code></li>
	 *   <li><code>new MovieClip()</code></li>
	 * </ul>]]></haxe_doc>
		</new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl.display.Sprite" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/Sprite.hx">
		<extends path="openfl.display.DisplayObjectContainer"/>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<graphics public="1" get="accessor" set="null"><c path="openfl.display.Graphics"/></graphics>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<startDrag public="1" set="method" line="35"><f a="?lockCenter:?bounds" v="false:null">
	<x path="Bool"/>
	<c path="openfl.geom.Rectangle"/>
	<x path="Void"/>
</f></startDrag>
		<stopDrag public="1" set="method" line="46"><f a=""><x path="Void"/></f></stopDrag>
		<__getBounds set="method" line="57" override="1">
			<f a="rect:matrix">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getBounds>
		<__hitTest set="method" line="70" override="1">
			<f a="x:y:shapeFlag:stack:interactiveOnly">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__hitTest>
		<__renderCanvas public="1" set="method" line="103" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderCanvas>
		<__renderDOM public="1" set="method" line="112" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderDOM>
		<__renderGL public="1" set="method" line="121" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderGL>
		<__renderMask public="1" set="method" line="142" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderMask>
		<get_graphics set="method" line="164">
			<f a=""><c path="openfl.display.Graphics"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_graphics>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl.display.MovieClip" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/MovieClip.hx">
		<extends path="openfl.display.Sprite"/>
		<currentFrame public="1" get="accessor" set="null"><x path="Int"/></currentFrame>
		<currentFrameLabel public="1" get="accessor" set="null"><c path="String"/></currentFrameLabel>
		<currentLabel public="1" get="accessor" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" get="accessor" set="null"><c path="Array"><c path="openfl.display.FrameLabel"/></c></currentLabels>
		<enabled public="1"><x path="Bool"/></enabled>
		<framesLoaded public="1" get="accessor" set="null"><x path="Int"/></framesLoaded>
		<totalFrames public="1" get="accessor" set="null"><x path="Int"/></totalFrames>
		<__currentFrame>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__currentFrame>
		<__currentFrameLabel>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__currentFrameLabel>
		<__currentLabel>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__currentLabel>
		<__currentLabels>
			<c path="Array"><c path="openfl.display.FrameLabel"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__currentLabels>
		<__totalFrames>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__totalFrames>
		<gotoAndPlay public="1" set="method" line="36"><f a="frame:?scene" v=":null">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method" line="43"><f a="frame:?scene" v=":null">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method" line="50"><f a=""><x path="Void"/></f></nextFrame>
		<play public="1" set="method" line="57"><f a=""><x path="Void"/></f></play>
		<prevFrame public="1" set="method" line="64"><f a=""><x path="Void"/></f></prevFrame>
		<stop public="1" set="method" line="71"><f a=""><x path="Void"/></f></stop>
		<get_currentFrame set="method" line="85">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_currentFrame>
		<get_currentFrameLabel set="method" line="86">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_currentFrameLabel>
		<get_currentLabel set="method" line="87">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_currentLabel>
		<get_currentLabels set="method" line="88">
			<f a=""><c path="Array"><c path="openfl.display.FrameLabel"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_currentLabels>
		<get_framesLoaded set="method" line="89">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_framesLoaded>
		<get_totalFrames set="method" line="90">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_totalFrames>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.display.LoaderInfo" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/LoaderInfo.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<create public="1" set="method" line="47" static="1"><f a="loader">
	<c path="openfl.display.Loader"/>
	<c path="openfl.display.LoaderInfo"/>
</f></create>
		<applicationDomain public="1"><c path="openfl.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null"><t path="openfl.utils.ByteArray"/></bytes>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<content public="1" set="null"><c path="openfl.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<height public="1" set="null"><x path="Int"/></height>
		<loader public="1" set="null"><c path="openfl.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="openfl.events.EventDispatcher"/></sharedEvents>
		<uncaughtErrorEvents public="1" set="null"><c path="openfl.events.UncaughtErrorEvents"/></uncaughtErrorEvents>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><x path="Int"/></width>
		<new set="method" line="34"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.system.ApplicationDomain" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/system/ApplicationDomain.hx">
		<currentDomain public="1" set="null" line="7" static="1"><c path="openfl.system.ApplicationDomain"/></currentDomain>
		<parentDomain public="1" set="null"><c path="openfl.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method" line="27"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<hasDefinition public="1" set="method" line="34"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method" line="12"><f a="?parentDomain" v="null">
	<c path="openfl.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.UncaughtErrorEvents" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/UncaughtErrorEvents.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<new public="1" set="method" line="4"><f a="?target">
	<c path="openfl.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.geom.Matrix" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/geom/Matrix.hx">
		<__identity line="20" static="1">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":noCompletion"/></meta>
		</__identity>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<__array>
			<c path="lime.utils.Float32Array"/>
			<meta><m n=":noCompletion"/></meta>
		</__array>
		<clone public="1" get="inline" set="null" line="37"><f a=""><c path="openfl.geom.Matrix"/></f></clone>
		<concat public="1" set="method" line="44"><f a="m">
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<copyColumnFrom public="1" set="method" line="63"><f a="column:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1" set="method" line="89"><f a="column:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1" set="method" line="118"><f a="sourceMatrix">
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></copyFrom>
		<copyRowFrom public="1" set="method" line="130"><f a="row:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1" set="method" line="156"><f a="row:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowTo>
		<createBox public="1" set="method" line="183"><f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createBox>
		<createGradientBox public="1" set="method" line="194"><f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createGradientBox>
		<equals public="1" set="method" line="223"><f a="matrix">
	<a>
		<ty set="null"><x path="Float"/></ty>
		<tx set="null"><x path="Float"/></tx>
		<d set="null"><x path="Float"/></d>
		<c set="null"><x path="Float"/></c>
		<b set="null"><x path="Float"/></b>
		<a set="null"><x path="Float"/></a>
	</a>
	<x path="Bool"/>
</f></equals>
		<deltaTransformPoint public="1" set="method" line="230"><f a="point">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method" line="237"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method" line="249"><f a=""><c path="openfl.geom.Matrix"/></f></invert>
		<mult public="1" get="inline" set="null" line="281"><f a="m">
	<c path="openfl.geom.Matrix"/>
	<c path="openfl.geom.Matrix"/>
</f></mult>
		<rotate public="1" set="method" line="298"><f a="theta">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method" line="334"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setRotation get="inline" set="null" line="357"><f a="theta:?scale" v=":1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setRotation>
		<setTo public="1" set="method" line="369"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<to3DString public="1" get="inline" set="null" line="381"><f a="?roundPixels" v="false">
	<x path="Bool"/>
	<c path="String"/>
</f></to3DString>
		<toMozString public="1" get="inline" set="null" line="404"><f a=""><c path="String"/></f></toMozString>
		<toString public="1" get="inline" set="null" line="411"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method" line="418"><f a="pos">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method" line="425"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<toArray set="method" line="435">
			<f a="?transpose" v="false">
				<x path="Bool"/>
				<c path="lime.utils.Float32Array"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toArray>
		<__cleanValues get="inline" set="null" line="468">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__cleanValues>
		<__transformX public="1" get="inline" set="null" line="480">
			<f a="pos">
				<c path="openfl.geom.Point"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__transformX>
		<__transformY public="1" get="inline" set="null" line="487">
			<f a="pos">
				<c path="openfl.geom.Point"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__transformY>
		<__translateTransformed public="1" get="inline" set="null" line="494">
			<f a="pos">
				<c path="openfl.geom.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__translateTransformed>
		<new public="1" set="method" line="23"><f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.Lib" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Lib.hx">
		<application public="1" static="1"><c path="openfl.display.Application"/></application>
		<current public="1" set="null" line="24" static="1"><c path="openfl.display.MovieClip"/></current>
		<__sentWarnings line="29" static="1">
			<x path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__sentWarnings>
		<__startTime line="30" static="1">
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__startTime>
		<as public="1" params="T" set="method" line="33" static="1"><f a="v:c">
	<d/>
	<x path="Class"><c path="as.T"/></x>
	<t path="Null"><c path="as.T"/></t>
</f></as>
		<attach public="1" set="method" line="44" static="1"><f a="name">
	<c path="String"/>
	<c path="openfl.display.MovieClip"/>
</f></attach>
		<getTimer public="1" set="method" line="83" static="1"><f a=""><x path="Int"/></f></getTimer>
		<getURL public="1" set="method" line="94" static="1"><f a="request:?target" v=":null">
	<c path="openfl.net.URLRequest"/>
	<c path="String"/>
	<x path="Void"/>
</f></getURL>
		<notImplemented public="1" set="method" line="111" static="1"><f a="api">
	<c path="String"/>
	<x path="Void"/>
</f></notImplemented>
		<preventDefaultTouchMove public="1" set="method" line="124" static="1"><f a=""><x path="Void"/></f></preventDefaultTouchMove>
		<trace public="1" set="method" line="146" static="1"><f a="arg">
	<d/>
	<x path="Void"/>
</f></trace>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl.Memory" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Memory.hx">
		<gcRef static="1"><t path="openfl.utils.ByteArray"/></gcRef>
		<len static="1"><x path="Int"/></len>
		<_setPositionTemporarily params="T" set="method" line="15" static="1">
			<f a="position:action">
				<x path="Int"/>
				<f a=""><c path="_setPositionTemporarily.T"/></f>
				<c path="_setPositionTemporarily.T"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_setPositionTemporarily>
		<getByte public="1" get="inline" set="null" line="27" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Int"/>
</f></getByte>
		<getDouble public="1" get="inline" set="null" line="36" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getFloat public="1" get="inline" set="null" line="49" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat>
		<getI32 public="1" get="inline" set="null" line="62" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Int"/>
</f></getI32>
		<getUI16 public="1" get="inline" set="null" line="75" static="1"><f a="addr">
	<x path="Int"/>
	<x path="Int"/>
</f></getUI16>
		<select public="1" set="method" line="88" static="1"><f a="inBytes">
	<t path="openfl.utils.ByteArray"/>
	<x path="Void"/>
</f></select>
		<setByte public="1" get="inline" set="null" line="96" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setByte>
		<setDouble public="1" get="inline" set="null" line="105" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setDouble>
		<setFloat public="1" get="inline" set="null" line="118" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<setI16 public="1" get="inline" set="null" line="131" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setI16>
		<setI32 public="1" get="inline" set="null" line="144" static="1"><f a="addr:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setI32>
	</class>
	<abstract path="openfl.Vector" params="T" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Vector.hx">
		<from>
			<icast><c path="Array"><c path="openfl.Vector.T"/></c></icast>
			<icast field="fromHaxeVector"><x path="haxe.ds.Vector"><c path="fromHaxeVector.T"/></x></icast>
		</from>
		<this><c path="Array"><c path="openfl.Vector.T"/></c></this>
		<to>
			<icast><c path="Array"><c path="openfl.Vector.T"/></c></icast>
			<icast field="toHaxeVector"><x path="haxe.ds.Vector"><c path="toHaxeVector.T"/></x></icast>
		</to>
		<meta><m n=":arrayAccess"/></meta>
		<impl><class path="openfl._Vector.Vector_Impl_" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Vector.hx" private="1" module="openfl.Vector">
	<length public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<fixed public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</fixed>
	<_new public="1" get="inline" set="null" line="780" static="1">
		<f a="?length:?fixed" v="null:null">
			<x path="Int"/>
			<x path="Bool"/>
			<c path="Array"><c path="openfl.Vector.T"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<concat public="1" get="inline" set="null" line="787" static="1">
		<f a="this:?a" v=":null">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</concat>
	<copy public="1" get="inline" set="null" line="794" static="1">
		<f a="this">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</copy>
	<iterator public="1" params="T" get="inline" set="null" line="801" static="1">
		<f a="this">
			<c path="Array"><c path="iterator.T"/></c>
			<t path="Iterator"><c path="iterator.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<join public="1" get="inline" set="null" line="808" static="1">
		<f a="this:sep">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</join>
	<pop public="1" get="inline" set="null" line="815" static="1">
		<f a="this">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<t path="Null"><c path="openfl.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</pop>
	<push public="1" get="inline" set="null" line="822" static="1">
		<f a="this:x">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<reverse public="1" get="inline" set="null" line="829" static="1">
		<f a="this">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
	<shift public="1" get="inline" set="null" line="836" static="1">
		<f a="this">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<t path="Null"><c path="openfl.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</shift>
	<unshift public="1" get="inline" set="null" line="843" static="1">
		<f a="this:x">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</unshift>
	<slice public="1" get="inline" set="null" line="850" static="1">
		<f a="this:?pos:?end" v=":null:null">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</slice>
	<sort public="1" get="inline" set="null" line="857" static="1">
		<f a="this:f">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<f a=":">
				<c path="openfl.Vector.T"/>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
			</f>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</sort>
	<splice public="1" get="inline" set="null" line="864" static="1">
		<f a="this:pos:len">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</splice>
	<toString public="1" get="inline" set="null" line="871" static="1">
		<f a="this">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<indexOf public="1" get="inline" set="null" line="878" static="1">
		<f a="this:x:?from" v="::0">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</indexOf>
	<lastIndexOf public="1" get="inline" set="null" line="885" static="1">
		<f a="this:x:?from" v="::null">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</lastIndexOf>
	<get public="1" get="inline" set="null" line="892" static="1">
		<f a="this:index">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<t path="Null"><c path="openfl.Vector.T"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" get="inline" set="null" line="903" static="1">
		<f a="this:index:value">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<c path="openfl.Vector.T"/>
			<c path="openfl.Vector.T"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<ofArray public="1" params="T" get="inline" set="null" line="914" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="openfl.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
	<convert public="1" params="T:U" get="inline" set="null" line="921" static="1"><f a="v">
	<c path="Array"><c path="convert.T"/></c>
	<x path="openfl.Vector"><c path="convert.U"/></x>
</f></convert>
	<fromHaxeVector public="1" params="T" get="inline" set="null" line="928" static="1">
		<f a="value">
			<x path="haxe.ds.Vector"><c path="fromHaxeVector.T"/></x>
			<x path="openfl.Vector"><c path="fromHaxeVector.T"/></x>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":from"/>
		</meta>
	</fromHaxeVector>
	<toHaxeVector public="1" params="T" get="inline" set="null" line="935" static="1">
		<f a="this">
			<c path="Array"><c path="toHaxeVector.T"/></c>
			<x path="haxe.ds.Vector"><c path="toHaxeVector.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</toHaxeVector>
	<get_length get="inline" set="null" line="949" static="1">
		<f a="this">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_length>
	<set_length get="inline" set="null" line="956" static="1">
		<f a="this:value">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_length>
	<get_fixed get="inline" set="null" line="964" static="1">
		<f a="this">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_fixed>
	<set_fixed get="inline" set="null" line="971" static="1">
		<f a="this:value">
			<c path="Array"><c path="openfl.Vector.T"/></c>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_fixed>
</class></impl>
	</abstract>
	<class path="openfl._Vector.Vector_Impl_" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Vector.hx" private="1" module="openfl.Vector">
		<length public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<fixed public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</fixed>
		<_new public="1" get="inline" set="null" line="780" static="1">
			<f a="?length:?fixed" v="null:null">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.Vector.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<concat public="1" get="inline" set="null" line="787" static="1">
			<f a="this:?a" v=":null">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</concat>
		<copy public="1" get="inline" set="null" line="794" static="1">
			<f a="this">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</copy>
		<iterator public="1" params="T" get="inline" set="null" line="801" static="1">
			<f a="this">
				<c path="Array"><c path="iterator.T"/></c>
				<t path="Iterator"><c path="iterator.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<join public="1" get="inline" set="null" line="808" static="1">
			<f a="this:sep">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</join>
		<pop public="1" get="inline" set="null" line="815" static="1">
			<f a="this">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<t path="Null"><c path="openfl.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</pop>
		<push public="1" get="inline" set="null" line="822" static="1">
			<f a="this:x">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<reverse public="1" get="inline" set="null" line="829" static="1">
			<f a="this">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<shift public="1" get="inline" set="null" line="836" static="1">
			<f a="this">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<t path="Null"><c path="openfl.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</shift>
		<unshift public="1" get="inline" set="null" line="843" static="1">
			<f a="this:x">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</unshift>
		<slice public="1" get="inline" set="null" line="850" static="1">
			<f a="this:?pos:?end" v=":null:null">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</slice>
		<sort public="1" get="inline" set="null" line="857" static="1">
			<f a="this:f">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<f a=":">
					<c path="openfl.Vector.T"/>
					<c path="openfl.Vector.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</sort>
		<splice public="1" get="inline" set="null" line="864" static="1">
			<f a="this:pos:len">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</splice>
		<toString public="1" get="inline" set="null" line="871" static="1">
			<f a="this">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<indexOf public="1" get="inline" set="null" line="878" static="1">
			<f a="this:x:?from" v="::0">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</indexOf>
		<lastIndexOf public="1" get="inline" set="null" line="885" static="1">
			<f a="this:x:?from" v="::null">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</lastIndexOf>
		<get public="1" get="inline" set="null" line="892" static="1">
			<f a="this:index">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<t path="Null"><c path="openfl.Vector.T"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" get="inline" set="null" line="903" static="1">
			<f a="this:index:value">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<c path="openfl.Vector.T"/>
				<c path="openfl.Vector.T"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<ofArray public="1" params="T" get="inline" set="null" line="914" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="openfl.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="921" static="1"><f a="v">
	<c path="Array"><c path="convert.T"/></c>
	<x path="openfl.Vector"><c path="convert.U"/></x>
</f></convert>
		<fromHaxeVector public="1" params="T" get="inline" set="null" line="928" static="1">
			<f a="value">
				<x path="haxe.ds.Vector"><c path="fromHaxeVector.T"/></x>
				<x path="openfl.Vector"><c path="fromHaxeVector.T"/></x>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":from"/>
			</meta>
		</fromHaxeVector>
		<toHaxeVector public="1" params="T" get="inline" set="null" line="935" static="1">
			<f a="this">
				<c path="Array"><c path="toHaxeVector.T"/></c>
				<x path="haxe.ds.Vector"><c path="toHaxeVector.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</toHaxeVector>
		<get_length get="inline" set="null" line="949" static="1">
			<f a="this">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_length>
		<set_length get="inline" set="null" line="956" static="1">
			<f a="this:value">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_length>
		<get_fixed get="inline" set="null" line="964" static="1">
			<f a="this">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_fixed>
		<set_fixed get="inline" set="null" line="971" static="1">
			<f a="this:value">
				<c path="Array"><c path="openfl.Vector.T"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_fixed>
	</class>
	<typedef path="openfl.VectorData" params="T" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Vector.hx" module="openfl.Vector"><c path="Array"><c path="openfl.VectorData.T"/></c></typedef>
	<typedef path="openfl.VectorDataIterator" params="T" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/Vector.hx" module="openfl.Vector"><t path="Iterator"><c path="openfl.VectorDataIterator.T"/></t></typedef>
	<class path="openfl._internal.renderer.AbstractRenderer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/AbstractRenderer.hx">
		<height public="1"><x path="Int"/></height>
		<width public="1"><x path="Int"/></width>
		<renderSession><c path="openfl._internal.renderer.RenderSession"/></renderSession>
		<render public="1" set="method" line="25"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<renderShape public="1" set="method" line="32"><f a="shape">
	<c path="openfl.display.Shape"/>
	<x path="Void"/>
</f></renderShape>
		<resize public="1" set="method" line="39"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<new set="method" line="17"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.RenderSession" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/RenderSession.hx">
		<context public="1"><c path="lime.graphics.CanvasRenderContext"/></context>
		<element public="1"><c path="lime.graphics.DOMRenderContext"/></element>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<projectionMatrix public="1"><x path="lime.math.Matrix4"/></projectionMatrix>
		<renderer public="1"><c path="openfl._internal.renderer.AbstractRenderer"/></renderer>
		<roundPixels public="1"><x path="Bool"/></roundPixels>
		<transformProperty public="1"><c path="String"/></transformProperty>
		<transformOriginProperty public="1"><c path="String"/></transformOriginProperty>
		<vendorPrefix public="1"><c path="String"/></vendorPrefix>
		<z public="1"><x path="Int"/></z>
		<drawCount public="1"><x path="Int"/></drawCount>
		<currentBlendMode public="1"><e path="openfl.display.BlendMode"/></currentBlendMode>
		<projection public="1"><c path="openfl.geom.Point"/></projection>
		<offset public="1"><c path="openfl.geom.Point"/></offset>
		<shaderManager public="1"><c path="openfl._internal.renderer.opengl.utils.ShaderManager"/></shaderManager>
		<maskManager public="1"><d/></maskManager>
		<filterManager public="1"><c path="openfl._internal.renderer.opengl.utils.FilterManager"/></filterManager>
		<blendModeManager public="1"><c path="openfl._internal.renderer.opengl.utils.BlendModeManager"/></blendModeManager>
		<spriteBatch public="1"><c path="openfl._internal.renderer.opengl.utils.SpriteBatch"/></spriteBatch>
		<stencilManager public="1"><c path="openfl._internal.renderer.opengl.utils.StencilManager"/></stencilManager>
		<new public="1" set="method" line="50"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasBitmap" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/canvas/CanvasBitmap.hx">
		<render public="1" get="inline" set="null" line="14" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasGraphics" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/canvas/CanvasGraphics.hx">
		<bounds static="1"><c path="openfl.geom.Rectangle"/></bounds>
		<hasFill static="1"><x path="Bool"/></hasFill>
		<hasStroke static="1"><x path="Bool"/></hasStroke>
		<inPath static="1"><x path="Bool"/></inPath>
		<inversePendingMatrix static="1"><c path="openfl.geom.Matrix"/></inversePendingMatrix>
		<pendingMatrix static="1"><c path="openfl.geom.Matrix"/></pendingMatrix>
		<positionX static="1"><x path="Float"/></positionX>
		<positionY static="1"><x path="Float"/></positionY>
		<setFill static="1"><x path="Bool"/></setFill>
		<beginPath set="method" line="47" static="1"><f a=""><x path="Void"/></f></beginPath>
		<beginPatternFill set="method" line="61" static="1"><f a="bitmapFill:bitmapRepeat">
	<c path="openfl.display.BitmapData"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></beginPatternFill>
		<closePath set="method" line="79" static="1"><f a="closeFill">
	<x path="Bool"/>
	<x path="Void"/>
</f></closePath>
		<drawRoundRect set="method" line="129" static="1"><f a="x:y:width:height:rx:ry">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRect>
		<render public="1" set="method" line="349" static="1"><f a="graphics:renderSession">
	<c path="openfl.display.Graphics"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<renderMask public="1" set="method" line="850" static="1"><f a="graphics:renderSession">
	<c path="openfl.display.Graphics"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderMask>
		<createTempPatternCanvas set="method" line="934" static="1"><f a="bitmap:repeat:width:height">
	<c path="openfl.display.BitmapData"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createTempPatternCanvas>
		<isCCW get="inline" set="null" line="956" static="1"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isCCW>
		<normalizeUvt set="method" line="960" static="1"><f a="uvt:?skipT" v=":false">
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="Bool"/>
	<a>
		<uvt><x path="openfl.Vector"><x path="Float"/></x></uvt>
		<max><x path="Float"/></max>
	</a>
</f></normalizeUvt>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasRenderer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/canvas/CanvasRenderer.hx">
		<extends path="openfl._internal.renderer.AbstractRenderer"/>
		<context><c path="lime.graphics.CanvasRenderContext"/></context>
		<render public="1" set="method" line="33" override="1"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="18"><f a="width:height:context">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.CanvasRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasShape" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/canvas/CanvasShape.hx">
		<render public="1" get="inline" set="null" line="13" static="1"><f a="shape:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasTextField" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/canvas/CanvasTextField.hx">
		<render public="1" get="inline" set="null" line="26" static="1"><f a="textField:renderSession">
	<c path="openfl.text.TextField"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<renderText get="inline" set="null" line="69" static="1"><f a="textField:text:format:offsetX">
	<c path="openfl.text.TextField"/>
	<c path="String"/>
	<c path="openfl.text.TextFormat"/>
	<x path="Float"/>
	<x path="Void"/>
</f></renderText>
		<update public="1" set="method" line="109" static="1"><f a="textField">
	<c path="openfl.text.TextField"/>
	<x path="Bool"/>
</f></update>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl._internal.renderer.canvas.MaskManager" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/canvas/MaskManager.hx">
		<renderSession><c path="openfl._internal.renderer.RenderSession"/></renderSession>
		<pushMask public="1" set="method" line="19"><f a="mask">
	<c path="openfl.display.IBitmapDrawable"/>
	<x path="Void"/>
</f></pushMask>
		<pushRect public="1" set="method" line="41"><f a="rect:transform">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></pushRect>
		<popMask public="1" set="method" line="55"><f a=""><x path="Void"/></f></popMask>
		<new public="1" set="method" line="12"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.dom.DOMBitmap" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/dom/DOMBitmap.hx">
		<render public="1" get="inline" set="null" line="20" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<renderCanvas set="method" line="59" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderCanvas>
		<renderImage set="method" line="100" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderImage>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.dom.DOMRenderer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/dom/DOMRenderer.hx">
		<extends path="openfl._internal.renderer.AbstractRenderer"/>
		<applyStyle public="1" set="method" line="61" static="1"><f a="displayObject:renderSession:setTransform:setAlpha:setClip">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></applyStyle>
		<element><c path="lime.graphics.DOMRenderContext"/></element>
		<render public="1" set="method" line="134" override="1"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="24"><f a="width:height:element">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.DOMRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.dom.DOMShape" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/dom/DOMShape.hx">
		<render public="1" get="inline" set="null" line="19" static="1"><f a="shape:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.dom.DOMTextField" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/dom/DOMTextField.hx">
		<render public="1" get="inline" set="null" line="19" static="1"><f a="textField:renderSession">
	<c path="openfl.text.TextField"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.GLBitmap" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/GLBitmap.hx">
		<render public="1" get="inline" set="null" line="13" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.GLRenderer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/GLRenderer.hx">
		<extends path="openfl._internal.renderer.AbstractRenderer"/>
		<blendModesWebGL public="1" line="24" static="1"><x path="Map">
	<e path="openfl.display.BlendMode"/>
	<c path="Array"><x path="Int"/></c>
</x></blendModesWebGL>
		<glContextId public="1" line="25" static="1"><x path="Int"/></glContextId>
		<glContexts public="1" line="26" static="1"><c path="Array"><c path="lime.graphics.GLRenderContext"/></c></glContexts>
		<blendModeManager public="1"><c path="openfl._internal.renderer.opengl.utils.BlendModeManager"/></blendModeManager>
		<contextLost public="1"><x path="Bool"/></contextLost>
		<filterManager public="1"><c path="openfl._internal.renderer.opengl.utils.FilterManager"/></filterManager>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<_glContextId public="1"><x path="Int"/></_glContextId>
		<maskManager public="1"><c path="openfl._internal.renderer.opengl.utils.MaskManager"/></maskManager>
		<offset public="1"><c path="openfl.geom.Point"/></offset>
		<options public="1"><d/></options>
		<preserveDrawingBuffer public="1"><x path="Bool"/></preserveDrawingBuffer>
		<projection public="1"><c path="openfl.geom.Point"/></projection>
		<shaderManager public="1"><c path="openfl._internal.renderer.opengl.utils.ShaderManager"/></shaderManager>
		<spriteBatch public="1"><c path="openfl._internal.renderer.opengl.utils.SpriteBatch"/></spriteBatch>
		<stencilManager public="1"><c path="openfl._internal.renderer.opengl.utils.StencilManager"/></stencilManager>
		<transparent public="1"><x path="Bool"/></transparent>
		<view public="1"><d/></view>
		<__stage><d/></__stage>
		<destroy public="1" set="method" line="129"><f a=""><x path="Void"/></f></destroy>
		<handleContextLost set="method" line="180"><f a="event">
	<d/>
	<x path="Void"/>
</f></handleContextLost>
		<handleContextRestored set="method" line="188"><f a=""><x path="Void"/></f></handleContextRestored>
		<render public="1" set="method" line="238" override="1"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<renderDisplayObject public="1" set="method" line="264"><f a="displayObject:projection:?buffer" v="::null">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.geom.Point"/>
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></renderDisplayObject>
		<resize public="1" set="method" line="283" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method" line="47"><f a="?width:?height:gl:?transparent:?antialias:?preserveDrawingBuffer" v="800:600::false:false:false">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.GLTextField" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/GLTextField.hx">
		<render public="1" set="method" line="14" static="1"><f a="textField:renderSession">
	<c path="openfl.text.TextField"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders.AbstractShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/shaders/AbstractShader.hx">
		<__UID line="12" static="1"><x path="Int"/></__UID>
		<compileProgram public="1" set="method" line="65" static="1"><f a="gl:vertexSrc:fragmentSrc">
	<c path="lime.graphics.GLRenderContext"/>
	<a><join set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></join></a>
	<a><join set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></join></a>
	<d/>
</f></compileProgram>
		<CompileVertexShader public="1" set="method" line="91" static="1"><f a="gl:shaderSrc">
	<d/>
	<a><join set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></join></a>
	<c path="lime.graphics.opengl.GLShader"/>
</f></CompileVertexShader>
		<CompileFragmentShader public="1" set="method" line="98" static="1"><f a="gl:shaderSrc">
	<d/>
	<a><join set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></join></a>
	<c path="lime.graphics.opengl.GLShader"/>
</f></CompileFragmentShader>
		<_CompileShader public="1" set="method" line="105" static="1"><f a="gl:shaderSrc:shaderType">
	<d/>
	<a><join set="null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></join></a>
	<unknown/>
	<c path="lime.graphics.opengl.GLShader"/>
</f></_CompileShader>
		<attributes public="1"><c path="Array"><x path="Int"/></c></attributes>
		<aTextureCoord public="1"><x path="Int"/></aTextureCoord>
		<aVertexPosition public="1"><x path="Int"/></aVertexPosition>
		<colorAttribute public="1"><x path="Int"/></colorAttribute>
		<fragmentSrc public="1"><c path="Array"><c path="String"/></c></fragmentSrc>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<program public="1"><c path="lime.graphics.opengl.GLProgram"/></program>
		<projectionVector public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></projectionVector>
		<uniforms public="1"><x path="Map">
	<c path="String"/>
	<d/>
</x></uniforms>
		<vertexSrc public="1"><c path="Array"><c path="String"/></c></vertexSrc>
		<_UID public="1"><x path="Int"/></_UID>
		<destroy public="1" set="method" line="38"><f a=""><x path="Void"/></f></destroy>
		<init public="1" set="method" line="53"><f a=""><x path="Void"/></f></init>
		<new set="method" line="27"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders.ComplexPrimitiveShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/shaders/ComplexPrimitiveShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders.AbstractShader"/>
		<alpha public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></alpha>
		<color public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></color>
		<offsetVector public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></offsetVector>
		<tintColor public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></tintColor>
		<translationMatrix public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></translationMatrix>
		<init public="1" set="method" line="59" override="1"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="19"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders.DefaultShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/shaders/DefaultShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders.AbstractShader"/>
		<defaultVertexSrc public="1" line="12" static="1"><c path="Array"><c path="String"/></c></defaultVertexSrc>
		<dimensions public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></dimensions>
		<offsetVector public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></offsetVector>
		<textureCount public="1"><x path="Int"/></textureCount>
		<uSampler public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></uSampler>
		<init public="1" set="method" line="63" override="1"><f a=""><x path="Void"/></f></init>
		<initSampler2D public="1" set="method" line="107"><f a="uniform">
	<d/>
	<x path="Void"/>
</f></initSampler2D>
		<initUniforms public="1" set="method" line="169"><f a=""><x path="Void"/></f></initUniforms>
		<syncUniforms public="1" set="method" line="240"><f a=""><x path="Void"/></f></syncUniforms>
		<new public="1" set="method" line="39"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders.DrawTrianglesShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/shaders/DrawTrianglesShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders.AbstractShader"/>
		<offsetVector public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></offsetVector>
		<translationMatrix public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></translationMatrix>
		<patternTL public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></patternTL>
		<patternBR public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></patternBR>
		<sampler public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></sampler>
		<color public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></color>
		<useTexture public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></useTexture>
		<alpha public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></alpha>
		<init public="1" set="method" line="71" override="1"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="17"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders.FastShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/shaders/FastShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders.AbstractShader"/>
		<aPositionCoord public="1"><x path="Int"/></aPositionCoord>
		<aRotation public="1"><x path="Int"/></aRotation>
		<aScale public="1"><x path="Int"/></aScale>
		<dimensions public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></dimensions>
		<offsetVector public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></offsetVector>
		<textureCount public="1"><x path="Int"/></textureCount>
		<uMatrix public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></uMatrix>
		<uSampler public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></uSampler>
		<init public="1" set="method" line="75" override="1"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="22"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders.FillShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/shaders/FillShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders.AbstractShader"/>
		<offsetVector public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></offsetVector>
		<translationMatrix public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></translationMatrix>
		<alpha public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></alpha>
		<color public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></color>
		<init public="1" set="method" line="46" override="1"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="13"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders.PatternFillShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/shaders/PatternFillShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders.AbstractShader"/>
		<offsetVector public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></offsetVector>
		<translationMatrix public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></translationMatrix>
		<patternMatrix public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></patternMatrix>
		<patternTL public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></patternTL>
		<patternBR public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></patternBR>
		<sampler public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></sampler>
		<alpha public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></alpha>
		<init public="1" set="method" line="59" override="1"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="16"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders.PrimitiveShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/shaders/PrimitiveShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders.AbstractShader"/>
		<alpha public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></alpha>
		<offsetVector public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></offsetVector>
		<tintColor public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></tintColor>
		<translationMatrix public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></translationMatrix>
		<init public="1" set="method" line="57" override="1"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="18"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders.StripShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/shaders/StripShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders.AbstractShader"/>
		<alpha public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></alpha>
		<offsetVector public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></offsetVector>
		<translationMatrix public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></translationMatrix>
		<uSampler public="1"><t path="lime.graphics.opengl.GLUniformLocation"/></uSampler>
		<init public="1" set="method" line="62" override="1"><f a=""><x path="Void"/></f></init>
		<new public="1" set="method" line="18"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.BlendModeManager" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/BlendModeManager.hx">
		<currentBlendMode public="1"><e path="openfl.display.BlendMode"/></currentBlendMode>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<destroy public="1" set="method" line="23"><f a=""><x path="Void"/></f></destroy>
		<setBlendMode public="1" set="method" line="30"><f a="blendMode">
	<e path="openfl.display.BlendMode"/>
	<x path="Bool"/>
</f></setBlendMode>
		<new public="1" set="method" line="15"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.DrawPath" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/DrawPath.hx">
		<getStack public="1" set="method" line="56" static="1"><f a="graphics:gl">
	<c path="openfl.display.Graphics"/>
	<c path="lime.graphics.GLRenderContext"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
</f></getStack>
		<line public="1"><c path="openfl._internal.renderer.opengl.utils.LineStyle"/></line>
		<fill public="1"><e path="openfl._internal.renderer.opengl.utils.FillType"/></fill>
		<fillIndex public="1"><x path="Int"/></fillIndex>
		<isRemovable public="1"><x path="Bool"/></isRemovable>
		<points public="1"><c path="Array"><x path="Float"/></c></points>
		<type public="1"><e path="openfl._internal.renderer.opengl.utils.GraphicType"/></type>
		<update public="1" set="method" line="40"><f a="line:fill:fillIndex">
	<c path="openfl._internal.renderer.opengl.utils.LineStyle"/>
	<e path="openfl._internal.renderer.opengl.utils.FillType"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<updateLine public="1" set="method" line="46"><f a="line">
	<c path="openfl._internal.renderer.opengl.utils.LineStyle"/>
	<x path="Void"/>
</f></updateLine>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.PathBuiler" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/DrawPath.hx" module="openfl._internal.renderer.opengl.utils.DrawPath">
		<__currentPath static="1"><c path="openfl._internal.renderer.opengl.utils.DrawPath"/></__currentPath>
		<__drawPaths static="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.DrawPath"/></c></__drawPaths>
		<__line static="1"><c path="openfl._internal.renderer.opengl.utils.LineStyle"/></__line>
		<__fill static="1"><e path="openfl._internal.renderer.opengl.utils.FillType"/></__fill>
		<__fillIndex line="70" static="1"><x path="Int"/></__fillIndex>
		<closePath set="method" line="72" static="1"><f a=""><x path="Void"/></f></closePath>
		<endFill set="method" line="89" static="1"><f a=""><x path="Void"/></f></endFill>
		<moveTo set="method" line="96" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<graphicDataPop get="inline" set="null" line="109" static="1"><f a=""><x path="Void"/></f></graphicDataPop>
		<build public="1" set="method" line="119" static="1"><f a="graphics:gl">
	<c path="openfl.display.Graphics"/>
	<c path="lime.graphics.GLRenderContext"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
</f></build>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.LineStyle" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/DrawPath.hx" module="openfl._internal.renderer.opengl.utils.DrawPath">
		<width public="1"><x path="Float"/></width>
		<color public="1"><x path="Int"/></color>
		<alpha public="1"><t path="Null"><x path="Float"/></t></alpha>
		<scaleMode public="1"><e path="openfl.display.LineScaleMode"/></scaleMode>
		<caps public="1"><e path="openfl.display.CapsStyle"/></caps>
		<joints public="1"><e path="openfl.display.JointStyle"/></joints>
		<miterLimit public="1"><x path="Float"/></miterLimit>
		<new public="1" set="method" line="411"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="openfl._internal.renderer.opengl.utils.FillType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/DrawPath.hx" module="openfl._internal.renderer.opengl.utils.DrawPath">
		<None/>
		<Color a="color:alpha">
			<x path="Int"/>
			<x path="Float"/>
		</Color>
		<Texture a="bitmap:matrix:repeat:smooth">
			<c path="openfl.display.BitmapData"/>
			<c path="openfl.geom.Matrix"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</Texture>
		<Gradient/>
	</enum>
	<class path="openfl._internal.renderer.opengl.utils.FilterManager" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/FilterManager.hx">
		<buffer public="1"><c path="lime.graphics.opengl.GLFramebuffer"/></buffer>
		<colorArray public="1"><c path="lime.utils.Float32Array"/></colorArray>
		<colorBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></colorBuffer>
		<defaultShader public="1"><c path="openfl._internal.renderer.opengl.shaders.DefaultShader"/></defaultShader>
		<filterStack public="1"><c path="Array"><d/></c></filterStack>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<height public="1"><x path="Int"/></height>
		<indexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></indexBuffer>
		<offsetX public="1"><x path="Float"/></offsetX>
		<offsetY public="1"><x path="Float"/></offsetY>
		<renderSession public="1"><c path="openfl._internal.renderer.RenderSession"/></renderSession>
		<texturePool public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.FilterTexture"/></c></texturePool>
		<transparent public="1"><x path="Bool"/></transparent>
		<uvArray public="1"><c path="lime.utils.Float32Array"/></uvArray>
		<uvBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></uvBuffer>
		<vertexArray public="1"><c path="lime.utils.Float32Array"/></vertexArray>
		<vertexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></vertexBuffer>
		<width public="1"><x path="Int"/></width>
		<applyFilterPass public="1" set="method" line="52"><f a="filter:filterArea:width:height">
	<d/>
	<c path="openfl.geom.Rectangle"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></applyFilterPass>
		<begin public="1" set="method" line="101"><f a="renderSession:?buffer" v=":null">
	<c path="openfl._internal.renderer.RenderSession"/>
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></begin>
		<destroy public="1" set="method" line="115"><f a=""><x path="Void"/></f></destroy>
		<initShaderBuffers public="1" set="method" line="140"><f a=""><x path="Void"/></f></initShaderBuffers>
		<popFilter public="1" set="method" line="170"><f a=""><x path="Void"/></f></popFilter>
		<pushFilter public="1" set="method" line="327"><f a="filterBlock">
	<d/>
	<x path="Void"/>
</f></pushFilter>
		<setContext public="1" set="method" line="401"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<new public="1" set="method" line="38"><f a="gl:transparent">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.FilterTexture" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/FilterTexture.hx">
		<frameBuffer public="1"><c path="lime.graphics.opengl.GLFramebuffer"/></frameBuffer>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<renderBuffer public="1"><c path="lime.graphics.opengl.GLRenderbuffer"/></renderBuffer>
		<smoothing public="1"><x path="Bool"/></smoothing>
		<texture public="1"><c path="lime.graphics.opengl.GLTexture"/></texture>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<clear public="1" set="method" line="47"><f a=""><x path="Void"/></f></clear>
		<destroy public="1" set="method" line="57"><f a=""><x path="Void"/></f></destroy>
		<resize public="1" set="method" line="69"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method" line="22"><f a="gl:width:height:?smoothing" v=":::true">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.geom.Rectangle" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/geom/Rectangle.hx">
		<bottom public="1" get="accessor" set="accessor"><x path="Float"/></bottom>
		<bottomRight public="1" get="accessor" set="accessor"><c path="openfl.geom.Point"/></bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor"><x path="Float"/></left>
		<right public="1" get="accessor" set="accessor"><x path="Float"/></right>
		<size public="1" get="accessor" set="accessor"><c path="openfl.geom.Point"/></size>
		<top public="1" get="accessor" set="accessor"><x path="Float"/></top>
		<topLeft public="1" get="accessor" set="accessor"><c path="openfl.geom.Point"/></topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="33"><f a=""><c path="openfl.geom.Rectangle"/></f></clone>
		<contains public="1" set="method" line="40"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method" line="47"><f a="point">
	<c path="openfl.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method" line="54"><f a="rect">
	<c path="openfl.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<copyFrom public="1" set="method" line="69"><f a="sourceRect">
	<c path="openfl.geom.Rectangle"/>
	<x path="Void"/>
</f></copyFrom>
		<equals public="1" set="method" line="79"><f a="toCompare">
	<c path="openfl.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<inflate public="1" set="method" line="86"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method" line="94"><f a="point">
	<c path="openfl.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method" line="101"><f a="toIntersect">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method" line="126"><f a="toIntersect">
	<c path="openfl.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method" line="145"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method" line="152"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method" line="160"><f a="point">
	<c path="openfl.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method" line="168"><f a=""><x path="Void"/></f></setEmpty>
		<setTo public="1" set="method" line="175"><f a="xa:ya:widtha:heighta">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<transform public="1" set="method" line="185"><f a="m">
	<c path="openfl.geom.Matrix"/>
	<c path="openfl.geom.Rectangle"/>
</f></transform>
		<union public="1" set="method" line="221"><f a="toUnion">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Rectangle"/>
</f></union>
		<__contract public="1" set="method" line="243">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__contract>
		<__expand public="1" set="method" line="262">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__expand>
		<__toLimeRectangle set="method" line="285">
			<f a=""><t path="lime.math._Rectangle.LimeRectangle"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__toLimeRectangle>
		<get_bottom set="method" line="299">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bottom>
		<set_bottom set="method" line="300">
			<f a="b">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bottom>
		<get_bottomRight set="method" line="301">
			<f a=""><c path="openfl.geom.Point"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bottomRight>
		<set_bottomRight set="method" line="302">
			<f a="p">
				<c path="openfl.geom.Point"/>
				<c path="openfl.geom.Point"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bottomRight>
		<get_left set="method" line="303">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_left>
		<set_left set="method" line="304">
			<f a="l">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_left>
		<get_right set="method" line="305">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_right>
		<set_right set="method" line="306">
			<f a="r">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_right>
		<get_size set="method" line="307">
			<f a=""><c path="openfl.geom.Point"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_size>
		<set_size set="method" line="308">
			<f a="p">
				<c path="openfl.geom.Point"/>
				<c path="openfl.geom.Point"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_size>
		<get_top set="method" line="309">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_top>
		<set_top set="method" line="310">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_top>
		<get_topLeft set="method" line="311">
			<f a=""><c path="openfl.geom.Point"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_topLeft>
		<set_topLeft set="method" line="312">
			<f a="p">
				<c path="openfl.geom.Point"/>
				<c path="openfl.geom.Point"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_topLeft>
		<new public="1" set="method" line="23"><f a="?x:?y:?width:?height" v="0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.geom.Point" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/geom/Point.hx">
		<distance public="1" set="method" line="37" static="1"><f a="pt1:pt2">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" line="53" static="1"><f a="pt1:pt2:f">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
	<x path="Float"/>
	<c path="openfl.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" line="85" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Point"/>
</f></polar>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method" line="23"><f a="v">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></add>
		<clone public="1" set="method" line="30"><f a=""><c path="openfl.geom.Point"/></f></clone>
		<equals public="1" set="method" line="46"><f a="toCompare">
	<c path="openfl.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<normalize public="1" set="method" line="60"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method" line="77"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setTo public="1" get="inline" set="null" line="92"><f a="xa:ya">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<subtract public="1" set="method" line="99"><f a="v">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></subtract>
		<toString public="1" set="method" line="106"><f a=""><c path="String"/></f></toString>
		<__toLimeVector2 set="method" line="113">
			<f a=""><c path="lime.math.Vector2"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__toLimeVector2>
		<get_length set="method" line="127">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<new public="1" set="method" line="15"><f a="?x:?y" v="0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.GraphicsRenderer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx">
		<graphicsDataPool public="1" line="41" static="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/></c></graphicsDataPool>
		<bucketPool public="1" line="42" static="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLBucket"/></c></bucketPool>
		<objectPosition line="44" static="1"><c path="openfl.geom.Point"/></objectPosition>
		<objectBounds line="45" static="1"><c path="openfl.geom.Rectangle"/></objectBounds>
		<lastVertsBuffer static="1"><c path="lime.graphics.opengl.GLBuffer"/></lastVertsBuffer>
		<lastBucketMode static="1"><e path="openfl._internal.renderer.opengl.utils.BucketMode"/></lastBucketMode>
		<lastTexture static="1"><t path="openfl.gl.GLTexture"/></lastTexture>
		<lastTextureRepeat static="1"><x path="Bool"/></lastTextureRepeat>
		<lastTextureSmooth static="1"><x path="Bool"/></lastTextureSmooth>
		<buildCircle public="1" set="method" line="53" static="1"><f a="path:glStack:?localCoords" v="::false">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></buildCircle>
		<buildComplexPoly public="1" set="method" line="124" static="1"><f a="path:glStack:?localCoords" v="::false">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></buildComplexPoly>
		<buildLine public="1" set="method" line="155" static="1"><f a="path:bucket:?localCoords" v="::false">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucketData"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></buildLine>
		<buildPoly public="1" set="method" line="403" static="1"><f a="path:glStack">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<x path="Void"/>
</f></buildPoly>
		<buildRectangle public="1" set="method" line="453" static="1"><f a="path:glStack:?localCoords" v="::false">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></buildRectangle>
		<buildRoundedRectangle public="1" set="method" line="501" static="1"><f a="path:glStack:?localCoords" v="::false">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></buildRoundedRectangle>
		<buildDrawTriangles public="1" set="method" line="564" static="1"><f a="path:object:glStack:?localCoords" v=":::false">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></buildDrawTriangles>
		<buildDrawTiles public="1" get="inline" set="null" line="702" static="1"><f a="path:glStack">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<x path="Void"/>
</f></buildDrawTiles>
		<quadraticBezierCurve set="method" line="706" static="1"><f a="fromX:fromY:cpX:cpY:toX:toY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><x path="Float"/></c>
</f></quadraticBezierCurve>
		<render public="1" set="method" line="741" static="1"><f a="object:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<renderGraphics public="1" set="method" line="792" static="1"><f a="object:renderSession:projection:?localCoords" v=":::false">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<c path="openfl.geom.Point"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></renderGraphics>
		<updateGraphics public="1" set="method" line="867" static="1"><f a="object:gl:?localCoords" v="::false">
	<c path="openfl.display.DisplayObject"/>
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></updateGraphics>
		<prepareBucket set="method" line="917" static="1"><f a="path:glStack">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucketData"/>
</f></prepareBucket>
		<getBucket set="method" line="979" static="1"><f a="glStack:mode">
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<e path="openfl._internal.renderer.opengl.utils.BucketMode"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
</f></getBucket>
		<switchBucket set="method" line="989" static="1"><f a="fillIndex:glStack:mode">
	<x path="Int"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<e path="openfl._internal.renderer.opengl.utils.BucketMode"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
</f></switchBucket>
		<prepareShader set="method" line="1007" static="1"><f a="bucket:renderSession:object:projection:translationMatrix">
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.geom.Point"/>
	<c path="lime.utils.Float32Array"/>
	<unknown/>
</f></prepareShader>
		<renderFill set="method" line="1063" static="1"><f a="bucket:shader:renderSession">
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<d/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderFill>
		<renderDrawTriangles set="method" line="1075" static="1"><f a="bucket:shader:renderSession">
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<c path="openfl._internal.renderer.opengl.shaders.DrawTrianglesShader"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderDrawTriangles>
		<renderDrawTiles get="inline" set="null" line="1092" static="1"><f a="object:bucket:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderDrawTiles>
		<bindDrawTrianglesBuffer set="method" line="1097" static="1"><f a="gl:shader:data">
	<c path="lime.graphics.GLRenderContext"/>
	<c path="openfl._internal.renderer.opengl.shaders.DrawTrianglesShader"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucketData"/>
	<x path="Void"/>
</f></bindDrawTrianglesBuffer>
		<bindTexture set="method" line="1110" static="1"><f a="gl:bucket">
	<c path="lime.graphics.GLRenderContext"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<x path="Void"/>
</f></bindTexture>
		<isCCW get="inline" set="null" line="1138" static="1"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isCCW>
		<hex2rgb public="1" get="inline" set="null" line="1142" static="1"><f a="hex">
	<t path="Null"><x path="Int"/></t>
	<c path="Array"><x path="Float"/></c>
</f></hex2rgb>
		<hex2rgba public="1" get="inline" set="null" line="1146" static="1"><f a="hex">
	<t path="Null"><x path="Int"/></t>
	<c path="Array"><x path="Float"/></c>
</f></hex2rgba>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.GLStack" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<buckets public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLBucket"/></c></buckets>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<reset public="1" set="method" line="1164"><f a=""><x path="Void"/></f></reset>
		<upload public="1" set="method" line="1169"><f a=""><x path="Void"/></f></upload>
		<new public="1" set="method" line="1158"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.GLBucket" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<color public="1"><c path="Array"><x path="Float"/></c></color>
		<alpha public="1"><x path="Float"/></alpha>
		<dirty public="1"><x path="Bool"/></dirty>
		<graphicType public="1"><e path="openfl._internal.renderer.opengl.utils.GraphicType"/></graphicType>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<fillIndex public="1"><x path="Int"/></fillIndex>
		<mode public="1"><e path="openfl._internal.renderer.opengl.utils.BucketMode"/></mode>
		<data public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLBucketData"/></c></data>
		<bitmap public="1"><c path="openfl.display.BitmapData"/></bitmap>
		<texture public="1"><t path="openfl.gl.GLTexture"/></texture>
		<textureMatrix public="1"><c path="openfl.geom.Matrix"/></textureMatrix>
		<textureRepeat public="1"><x path="Bool"/></textureRepeat>
		<textureSmooth public="1"><x path="Bool"/></textureSmooth>
		<textureTL public="1"><c path="openfl.geom.Point"/></textureTL>
		<textureBR public="1"><c path="openfl.geom.Point"/></textureBR>
		<tileBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></tileBuffer>
		<glTile public="1"><t path="openfl.utils.Int16Array"/></glTile>
		<tile public="1"><c path="Array"><x path="Int"/></c></tile>
		<uploadTileBuffer public="1"><x path="Bool"/></uploadTileBuffer>
		<getData public="1" set="method" line="1224"><f a=""><c path="openfl._internal.renderer.opengl.utils.GLBucketData"/></f></getData>
		<reset public="1" set="method" line="1248"><f a=""><x path="Void"/></f></reset>
		<upload public="1" set="method" line="1257"><f a=""><x path="Void"/></f></upload>
		<new public="1" set="method" line="1208"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.GLBucketData" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<drawMode public="1"><x path="Int"/></drawMode>
		<glLength public="1"><x path="Int"/></glLength>
		<glStart public="1"><x path="Int"/></glStart>
		<vertsBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></vertsBuffer>
		<lastVertsSize public="1"><x path="Int"/></lastVertsSize>
		<glVerts public="1"><c path="lime.utils.Float32Array"/></glVerts>
		<verts public="1"><c path="Array"><x path="Float"/></c></verts>
		<rawVerts public="1"><x path="Bool"/></rawVerts>
		<stride public="1"><x path="Int"/></stride>
		<indexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></indexBuffer>
		<glIndices public="1"><c path="lime.utils.UInt16Array"/></glIndices>
		<indices public="1"><c path="Array"><x path="Int"/></c></indices>
		<rawIndices public="1"><x path="Bool"/></rawIndices>
		<line public="1"><c path="openfl._internal.renderer.opengl.utils.GLBucketData"/></line>
		<destroyed public="1"><x path="Bool"/></destroyed>
		<parent public="1"><c path="openfl._internal.renderer.opengl.utils.GLBucket"/></parent>
		<destroy public="1" set="method" line="1322"><f a=""><x path="Void"/></f></destroy>
		<upload public="1" set="method" line="1334"><f a=""><x path="Void"/></f></upload>
		<new public="1" set="method" line="1309"><f a="gl:?initLine" v=":true">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="openfl._internal.renderer.opengl.utils.BucketMode" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<None/>
		<Fill/>
		<PatternFill/>
		<Line/>
		<PatternLine/>
		<DrawTriangles/>
		<DrawTiles/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl._internal.renderer.opengl.utils.GLGraphicsData" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<tint public="1"><c path="Array"><x path="Float"/></c></tint>
		<alpha public="1"><x path="Float"/></alpha>
		<dirty public="1"><x path="Bool"/></dirty>
		<mode public="1"><x path="openfl._internal.renderer.opengl.utils.RenderMode"/></mode>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<data public="1"><c path="Array"><x path="Float"/></c></data>
		<glData public="1"><c path="lime.utils.Float32Array"/></glData>
		<dataBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></dataBuffer>
		<indices public="1"><c path="Array"><x path="Int"/></c></indices>
		<glIndices public="1"><c path="lime.utils.UInt16Array"/></glIndices>
		<indexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></indexBuffer>
		<reset public="1" set="method" line="1407"><f a=""><x path="Void"/></f></reset>
		<upload public="1" set="method" line="1416"><f a=""><x path="Void"/></f></upload>
		<new public="1" set="method" line="1397"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.PolyK" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<triangulate public="1" set="method" line="1438" static="1"><f a="p">
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
</f></triangulate>
		<_PointInTriangle public="1" set="method" line="1523" static="1"><f a="px:py:ax:ay:bx:by:cx:cy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></_PointInTriangle>
		<_convex public="1" set="method" line="1547" static="1"><f a="ax:ay:bx:by:cx:cy:sign">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></_convex>
	</class>
	<enum path="openfl._internal.renderer.opengl.utils.GraphicType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<Polygon/>
		<Rectangle a="rounded"><x path="Bool"/></Rectangle>
		<Circle/>
		<Ellipse/>
		<DrawTriangles a="vertices:indices:uvtData:culling:colors:blendMode">
			<x path="openfl.Vector"><x path="Float"/></x>
			<x path="openfl.Vector"><x path="Int"/></x>
			<x path="openfl.Vector"><x path="Float"/></x>
			<e path="openfl.display.TriangleCulling"/>
			<x path="openfl.Vector"><x path="Int"/></x>
			<x path="Int"/>
		</DrawTriangles>
		<DrawTiles a="sheet:tileData:smooth:flags:count">
			<c path="openfl.display.Tilesheet"/>
			<c path="Array"><x path="Float"/></c>
			<x path="Bool"/>
			<x path="Int"/>
			<x path="Int"/>
		</DrawTiles>
	</enum>
	<abstract path="openfl._internal.renderer.opengl.utils.RenderMode" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.utils._GraphicsRenderer.RenderMode_Impl_" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" private="1" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
	<DEFAULT public="1" get="inline" set="null" line="1568" static="1">
		<x path="openfl._internal.renderer.opengl.utils.RenderMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT>
	<STENCIL public="1" get="inline" set="null" line="1569" static="1">
		<x path="openfl._internal.renderer.opengl.utils.RenderMode"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STENCIL>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.utils._GraphicsRenderer.RenderMode_Impl_" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" private="1" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<DEFAULT public="1" get="inline" set="null" line="1568" static="1">
			<x path="openfl._internal.renderer.opengl.utils.RenderMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT>
		<STENCIL public="1" get="inline" set="null" line="1569" static="1">
			<x path="openfl._internal.renderer.opengl.utils.RenderMode"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STENCIL>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.MaskManager" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/MaskManager.hx">
		<count public="1"><x path="Int"/></count>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<maskPosition public="1"><x path="Int"/></maskPosition>
		<maskStack public="1"><c path="Array"><d/></c></maskStack>
		<reverse public="1"><x path="Bool"/></reverse>
		<destroy public="1" set="method" line="30"><f a=""><x path="Void"/></f></destroy>
		<popMask public="1" set="method" line="38"><f a="maskData:renderSession">
	<d/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></popMask>
		<pushMask public="1" set="method" line="46"><f a="maskData:renderSession">
	<d/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></pushMask>
		<setContext public="1" set="method" line="62"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<new public="1" set="method" line="17"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.ShaderManager" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/ShaderManager.hx">
		<attribState public="1"><c path="Array"><x path="Bool"/></c></attribState>
		<complexPrimitiveShader public="1"><c path="openfl._internal.renderer.opengl.shaders.ComplexPrimitiveShader"/></complexPrimitiveShader>
		<currentShader public="1"><c path="openfl._internal.renderer.opengl.shaders.AbstractShader"/></currentShader>
		<defaultShader public="1"><c path="openfl._internal.renderer.opengl.shaders.DefaultShader"/></defaultShader>
		<fastShader public="1"><c path="openfl._internal.renderer.opengl.shaders.FastShader"/></fastShader>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<maxAttibs public="1"><x path="Int"/></maxAttibs>
		<primitiveShader public="1"><c path="openfl._internal.renderer.opengl.shaders.PrimitiveShader"/></primitiveShader>
		<fillShader public="1"><c path="openfl._internal.renderer.opengl.shaders.FillShader"/></fillShader>
		<patternFillShader public="1"><c path="openfl._internal.renderer.opengl.shaders.PatternFillShader"/></patternFillShader>
		<drawTrianglesShader public="1"><c path="openfl._internal.renderer.opengl.shaders.DrawTrianglesShader"/></drawTrianglesShader>
		<shaderMap public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.shaders.AbstractShader"/></c></shaderMap>
		<stripShader public="1"><c path="openfl._internal.renderer.opengl.shaders.StripShader"/></stripShader>
		<tempAttribState public="1"><c path="Array"><x path="Bool"/></c></tempAttribState>
		<_currentId><x path="Int"/></_currentId>
		<destroy public="1" set="method" line="57"><f a=""><x path="Void"/></f></destroy>
		<setAttribs public="1" set="method" line="75"><f a="attribs">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></setAttribs>
		<setContext public="1" set="method" line="115"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<setShader public="1" set="method" line="134"><f a="shader">
	<c path="openfl._internal.renderer.opengl.shaders.AbstractShader"/>
	<x path="Bool"/>
</f></setShader>
		<new public="1" set="method" line="39"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.SpriteBatch" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/SpriteBatch.hx">
		<states public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils._SpriteBatch.State"/></c></states>
		<currentState public="1"><c path="openfl._internal.renderer.opengl.utils._SpriteBatch.State"/></currentState>
		<currentBaseTexture public="1"><c path="lime.graphics.opengl.GLTexture"/></currentBaseTexture>
		<currentBatchSize public="1"><x path="Int"/></currentBatchSize>
		<currentBlendMode public="1"><e path="openfl.display.BlendMode"/></currentBlendMode>
		<dirty public="1"><x path="Bool"/></dirty>
		<drawing public="1"><x path="Bool"/></drawing>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<indexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></indexBuffer>
		<indices public="1"><c path="lime.utils.UInt16Array"/></indices>
		<lastIndexCount public="1"><x path="Int"/></lastIndexCount>
		<renderSession public="1"><c path="openfl._internal.renderer.RenderSession"/></renderSession>
		<shader public="1"><c path="openfl._internal.renderer.opengl.shaders.AbstractShader"/></shader>
		<size public="1"><x path="Int"/></size>
		<vertexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></vertexBuffer>
		<vertices public="1"><c path="lime.utils.Float32Array"/></vertices>
		<vertSize public="1"><x path="Int"/></vertSize>
		<begin public="1" set="method" line="92"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></begin>
		<destroy public="1" set="method" line="102"><f a=""><x path="Void"/></f></destroy>
		<end public="1" set="method" line="117"><f a=""><x path="Void"/></f></end>
		<flush set="method" line="125"><f a=""><x path="Void"/></f></flush>
		<render public="1" set="method" line="200"><f a="sprite">
	<c path="openfl.display.Bitmap"/>
	<x path="Void"/>
</f></render>
		<renderCachedGraphics public="1" set="method" line="235"><f a="object">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></renderCachedGraphics>
		<renderTiles public="1" set="method" line="270"><f a="object:sheet:tileData:?smooth:?flags:?count" v=":::false:0:-1">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.display.Tilesheet"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderTiles>
		<fillVertices get="inline" set="null" line="440"><f a="index:aX:aY:width:height:tint:alpha:uvs:matrix">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<c path="openfl.display.TextureUvs"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></fillVertices>
		<setState set="method" line="490"><f a="index:texture:?smooth:blendMode" v="::true:">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Bool"/>
	<e path="openfl.display.BlendMode"/>
	<x path="Void"/>
</f></setState>
		<renderBatch set="method" line="501"><f a="state:size:startIndex">
	<c path="openfl._internal.renderer.opengl.utils._SpriteBatch.State"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderBatch>
		<renderTilingSprite public="1" set="method" line="531"><f a="tilingSprite">
	<d/>
	<x path="Void"/>
</f></renderTilingSprite>
		<setContext public="1" set="method" line="628"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<start public="1" set="method" line="646"><f a=""><x path="Void"/></f></start>
		<stop public="1" set="method" line="653"><f a=""><x path="Void"/></f></stop>
		<new public="1" set="method" line="50"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils._SpriteBatch.State" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/SpriteBatch.hx" private="1" module="openfl._internal.renderer.opengl.utils.SpriteBatch">
		<texture public="1"><c path="lime.graphics.opengl.GLTexture"/></texture>
		<textureSmooth public="1"><x path="Bool"/></textureSmooth>
		<blendMode public="1"><e path="openfl.display.BlendMode"/></blendMode>
		<new public="1" set="method" line="669"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.StencilManager" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/_internal/renderer/opengl/utils/StencilManager.hx">
		<count public="1"><x path="Int"/></count>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<maskStack public="1"><c path="Array"><d/></c></maskStack>
		<reverse public="1"><x path="Bool"/></reverse>
		<stencilStack public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/></c></stencilStack>
		<bucketStack public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLBucket"/></c></bucketStack>
		<prepareGraphics public="1" get="inline" set="null" line="39"><f a="bucketData:renderSession:projection:translationMatrix">
	<c path="openfl._internal.renderer.opengl.utils.GLBucketData"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<c path="openfl.geom.Point"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></prepareGraphics>
		<pushBucket public="1" set="method" line="53"><f a="bucket:renderSession:projection:translationMatrix">
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<c path="openfl.geom.Point"/>
	<c path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></pushBucket>
		<popBucket public="1" set="method" line="81"><f a="object:bucket:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></popBucket>
		<bindGraphics public="1" set="method" line="88"><f a="object:glData:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></bindGraphics>
		<destroy public="1" set="method" line="144"><f a=""><x path="Void"/></f></destroy>
		<popStencil public="1" set="method" line="153"><f a="object:glData:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></popStencil>
		<pushStencil public="1" set="method" line="239"><f a="object:glData:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></pushStencil>
		<setContext public="1" set="method" line="329"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<new public="1" set="method" line="29"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl.display.Application" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/Application.hx">
		<extends path="lime.app.Application"/>
		<stage><c path="openfl.display.Stage"/></stage>
		<convertKeyCode set="method" line="38">
			<f a="keyCode">
				<x path="lime.ui.KeyCode"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</convertKeyCode>
		<create public="1" set="method" line="284" override="1"><f a="config">
	<t path="lime.app._Config.LimeConfig"/>
	<x path="Void"/>
</f></create>
		<onKey set="method" line="294">
			<f a="event">
				<c path="openfl.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onKey>
		<onKeyDown public="1" set="method" line="318" override="1"><f a="keyCode:modifier">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onKeyDown>
		<onKeyUp public="1" set="method" line="329" override="1"><f a="keyCode:modifier">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onKeyUp>
		<onMouse set="method" line="340">
			<f a="type:x:y">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onMouse>
		<onMouseDown public="1" set="method" line="399" override="1"><f a="x:y:button">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMouseDown>
		<onMouseMove public="1" set="method" line="406" override="1"><f a="x:y:button">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMouseMove>
		<onMouseUp public="1" set="method" line="413" override="1"><f a="x:y:button">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMouseUp>
		<onTouch set="method" line="420">
			<f a="type:x:y:id">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onTouch>
		<onTouchMove public="1" set="method" line="495" override="1"><f a="x:y:id">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTouchMove>
		<onTouchEnd public="1" set="method" line="502" override="1"><f a="x:y:id">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTouchEnd>
		<onTouchStart public="1" set="method" line="509" override="1"><f a="x:y:id">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTouchStart>
		<onWindowActivate public="1" set="method" line="516" override="1"><f a=""><x path="Void"/></f></onWindowActivate>
		<onWindowDeactivate public="1" set="method" line="524" override="1"><f a=""><x path="Void"/></f></onWindowDeactivate>
		<onWindowResize public="1" set="method" line="532" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onWindowResize>
		<render public="1" set="method" line="543" override="1"><f a="context">
	<e path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl.display.Bitmap" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/Bitmap.hx">
		<extends path="openfl.display.DisplayObjectContainer"/>
		<bitmapData public="1">
			<c path="openfl.display.BitmapData"/>
			<haxe_doc>* The BitmapData object being referenced.</haxe_doc>
		</bitmapData>
		<pixelSnapping public="1">
			<e path="openfl.display.PixelSnapping"/>
			<haxe_doc><![CDATA[* Controls whether or not the Bitmap object is snapped to the nearest pixel.
	 * This value is ignored in the native and HTML5 targets.
	 * The PixelSnapping class includes possible values:
	 * <ul>
	 *   <li><code>PixelSnapping.NEVER</code> - No pixel snapping occurs.</li>
	 *   <li><code>PixelSnapping.ALWAYS</code> - The image is always snapped to
	 * the nearest pixel, independent of transformation.</li>
	 *   <li><code>PixelSnapping.AUTO</code> - The image is snapped to the
	 * nearest pixel if it is drawn with no rotation or skew and it is drawn at a
	 * scale factor of 99.9% to 100.1%. If these conditions are satisfied, the
	 * bitmap image is drawn at 100% scale, snapped to the nearest pixel.
	 * When targeting Flash Player, this value allows the image to be drawn as fast 
	 * as possible using the internal vector renderer.</li>
	 * </ul>]]></haxe_doc>
		</pixelSnapping>
		<smoothing public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether or not the bitmap is smoothed when scaled. If
	 * <code>true</code>, the bitmap is smoothed when scaled. If
	 * <code>false</code>, the bitmap is not smoothed when scaled.]]></haxe_doc>
		</smoothing>
		<__getBounds set="method" line="108" override="1">
			<f a="rect:matrix">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getBounds>
		<__hitTest set="method" line="122" override="1">
			<f a="x:y:shapeFlag:stack:interactiveOnly">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__hitTest>
		<__renderCanvas public="1" set="method" line="145" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderCanvas>
		<__renderDOM public="1" set="method" line="152" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderDOM>
		<__renderGL public="1" set="method" line="159" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderGL>
		<__renderMask public="1" set="method" line="166" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderMask>
		<get_height set="method" line="180" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_height>
		<set_height set="method" line="193" override="1">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_height>
		<get_width set="method" line="213" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_width>
		<set_width set="method" line="226" override="1">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<new public="1" set="method" line="91"><f a="?bitmapData:?pixelSnapping:?smoothing" v="null:null:false">
	<c path="openfl.display.BitmapData"/>
	<e path="openfl.display.PixelSnapping"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl.display.BitmapData" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/BitmapData.hx">
		<implements path="openfl.display.IBitmapDrawable"/>
		<fromBase64 public="1" set="method" line="588" static="1"><f a="base64:type:?onload" v="::null">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="openfl.display.BitmapData"/>
		<x path="Void"/>
	</f>
	<c path="openfl.display.BitmapData"/>
</f></fromBase64>
		<fromBytes public="1" set="method" line="597" static="1"><f a="bytes:?rawAlpha:?onload" v=":null:null">
	<t path="openfl.utils.ByteArray"/>
	<t path="openfl.utils.ByteArray"/>
	<f a="">
		<c path="openfl.display.BitmapData"/>
		<x path="Void"/>
	</f>
	<c path="openfl.display.BitmapData"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="618" static="1"><f a="path:?onload:?onerror" v=":null:null">
	<c path="String"/>
	<f a="">
		<c path="openfl.display.BitmapData"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<c path="openfl.display.BitmapData"/>
</f></fromFile>
		<fromImage public="1" set="method" line="627" static="1"><f a="image:?transparent" v=":true">
	<c path="lime.graphics.Image"/>
	<x path="Bool"/>
	<c path="openfl.display.BitmapData"/>
</f></fromImage>
		<__flipPixel get="inline" set="null" line="1438" static="1">
			<f a="pixel">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__flipPixel>
		<__ucompare set="method" line="1573" static="1">
			<f a="n1:n2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__ucompare>
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the bitmap image in pixels.</haxe_doc>
		</height>
		<rect public="1" set="null">
			<c path="openfl.geom.Rectangle"/>
			<haxe_doc>* The rectangle that defines the size and location of the bitmap image. The
	 * top and left of the rectangle are 0; the width and height are equal to the
	 * width and height in pixels of the BitmapData object.</haxe_doc>
		</rect>
		<transparent public="1" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Defines whether the bitmap image supports per-pixel transparency. You can
	 * set this value only when you construct a BitmapData object by passing in
	 * <code>true</code> for the <code>transparent</code> parameter of the
	 * constructor. Then, after you create a BitmapData object, you can check
	 * whether it supports per-pixel transparency by determining if the value of
	 * the <code>transparent</code> property is <code>true</code>.]]></haxe_doc>
		</transparent>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the bitmap image in pixels.</haxe_doc>
		</width>
		<__worldTransform public="1">
			<c path="openfl.geom.Matrix"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__worldTransform>
		<__buffer>
			<c path="lime.graphics.opengl.GLBuffer"/>
			<meta><m n=":noCompletion"/></meta>
		</__buffer>
		<__image>
			<c path="lime.graphics.Image"/>
			<meta><m n=":noCompletion"/></meta>
		</__image>
		<__isValid>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__isValid>
		<__texture>
			<c path="lime.graphics.opengl.GLTexture"/>
			<meta><m n=":noCompletion"/></meta>
		</__texture>
		<__textureImage>
			<c path="lime.graphics.Image"/>
			<meta><m n=":noCompletion"/></meta>
		</__textureImage>
		<__uvData>
			<c path="openfl.display.TextureUvs"/>
			<meta><m n=":noCompletion"/></meta>
		</__uvData>
		<applyFilter public="1" set="method" line="206">
			<f a="sourceBitmapData:sourceRect:destPoint:filter">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<c path="openfl.filters.BitmapFilter"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Takes a source image and a filter object and generates the filtered image. 
	 * 
	 * This method relies on the behavior of built-in filter objects, which determine the 
	 * destination rectangle that is affected by an input source rectangle.
	 * 
	 * After a filter is applied, the resulting image can be larger than the input image. 
	 * For example, if you use a BlurFilter class to blur a source rectangle of(50,50,100,100) 
	 * and a destination point of(10,10), the area that changes in the destination image is 
	 * larger than(10,10,60,60) because of the blurring. This happens internally during the 
	 * applyFilter() call.
	 * 
	 * If the <code>sourceRect</code> parameter of the sourceBitmapData parameter is an 
	 * interior region, such as(50,50,100,100) in a 200 x 200 image, the filter uses the source 
	 * pixels outside the <code>sourceRect</code> parameter to generate the destination rectangle.
	 * 
	 * If the BitmapData object and the object specified as the <code>sourceBitmapData</code> 
	 * parameter are the same object, the application uses a temporary copy of the object to 
	 * perform the filter. For best performance, avoid this situation.
	 * 
	 * @param	sourceBitmapData		The input bitmap image to use. The source image can be a different BitmapData object or it can refer to the current BitmapData instance.
	 * @param	sourceRect		A rectangle that defines the area of the source image to use as input.
	 * @param	destPoint		The point within the destination image(the current BitmapData instance) that corresponds to the upper-left corner of the source rectangle. 
	 * @param	filter		The filter object that you use to perform the filtering operation.]]></haxe_doc>
		</applyFilter>
		<clone public="1" set="method" line="230">
			<f a=""><c path="openfl.display.BitmapData"/></f>
			<haxe_doc>* Returns a new BitmapData object that is a clone of the original instance with an exact copy of the contained bitmap. 
	 * @return		A new BitmapData object that is identical to the original.</haxe_doc>
		</clone>
		<colorTransform public="1" set="method" line="252">
			<f a="rect:colorTransform">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adjusts the color values in a specified area of a bitmap image by using a <code>ColorTransform</code>
	 * object. If the rectangle matches the boundaries of the bitmap image, this method transforms the color 
	 * values of the entire image. 
	 * @param	rect		A Rectangle object that defines the area of the image in which the ColorTransform object is applied.
	 * @param	colorTransform		A ColorTransform object that describes the color transformation values to apply.]]></haxe_doc>
		</colorTransform>
		<copyChannel public="1" set="method" line="302">
			<f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Transfers data from one channel of another BitmapData object or the
	 * current BitmapData object into a channel of the current BitmapData object.
	 * All of the data in the other channels in the destination BitmapData object
	 * are preserved.
	 *
	 * <p>The source channel value and destination channel value can be one of
	 * following values: </p>
	 *
	 * <ul>
	 *   <li><code>BitmapDataChannel.RED</code></li>
	 *   <li><code>BitmapDataChannel.GREEN</code></li>
	 *   <li><code>BitmapDataChannel.BLUE</code></li>
	 *   <li><code>BitmapDataChannel.ALPHA</code></li>
	 * </ul>
	 * 
	 * @param sourceBitmapData The input bitmap image to use. The source image
	 *                         can be a different BitmapData object or it can
	 *                         refer to the current BitmapData object.
	 * @param sourceRect       The source Rectangle object. To copy only channel
	 *                         data from a smaller area within the bitmap,
	 *                         specify a source rectangle that is smaller than
	 *                         the overall size of the BitmapData object.
	 * @param destPoint        The destination Point object that represents the
	 *                         upper-left corner of the rectangular area where
	 *                         the new channel data is placed. To copy only
	 *                         channel data from one area to a different area in
	 *                         the destination image, specify a point other than
	 *                        (0,0).
	 * @param sourceChannel    The source channel. Use a value from the
	 *                         BitmapDataChannel class
	 *                        (<code>BitmapDataChannel.RED</code>,
	 *                         <code>BitmapDataChannel.BLUE</code>,
	 *                         <code>BitmapDataChannel.GREEN</code>,
	 *                         <code>BitmapDataChannel.ALPHA</code>).
	 * @param destChannel      The destination channel. Use a value from the
	 *                         BitmapDataChannel class
	 *                        (<code>BitmapDataChannel.RED</code>,
	 *                         <code>BitmapDataChannel.BLUE</code>,
	 *                         <code>BitmapDataChannel.GREEN</code>,
	 *                         <code>BitmapDataChannel.ALPHA</code>).
	 * @throws TypeError The sourceBitmapData, sourceRect or destPoint are null.]]></haxe_doc>
		</copyChannel>
		<copyPixels public="1" set="method" line="370">
			<f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha" v=":::null:null:false">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Provides a fast routine to perform pixel manipulation between images with
	 * no stretching, rotation, or color effects. This method copies a
	 * rectangular area of a source image to a rectangular area of the same size
	 * at the destination point of the destination BitmapData object.
	 *
	 * <p>If you include the <code>alphaBitmap</code> and <code>alphaPoint</code>
	 * parameters, you can use a secondary image as an alpha source for the
	 * source image. If the source image has alpha data, both sets of alpha data
	 * are used to composite pixels from the source image to the destination
	 * image. The <code>alphaPoint</code> parameter is the point in the alpha
	 * image that corresponds to the upper-left corner of the source rectangle.
	 * Any pixels outside the intersection of the source image and alpha image
	 * are not copied to the destination image.</p>
	 *
	 * <p>The <code>mergeAlpha</code> property controls whether or not the alpha
	 * channel is used when a transparent image is copied onto another
	 * transparent image. To copy pixels with the alpha channel data, set the
	 * <code>mergeAlpha</code> property to <code>true</code>. By default, the
	 * <code>mergeAlpha</code> property is <code>false</code>.</p>
	 * 
	 * @param sourceBitmapData The input bitmap image from which to copy pixels.
	 *                         The source image can be a different BitmapData
	 *                         instance, or it can refer to the current
	 *                         BitmapData instance.
	 * @param sourceRect       A rectangle that defines the area of the source
	 *                         image to use as input.
	 * @param destPoint        The destination point that represents the
	 *                         upper-left corner of the rectangular area where
	 *                         the new pixels are placed.
	 * @param alphaBitmapData  A secondary, alpha BitmapData object source.
	 * @param alphaPoint       The point in the alpha BitmapData object source
	 *                         that corresponds to the upper-left corner of the
	 *                         <code>sourceRect</code> parameter.
	 * @param mergeAlpha       To use the alpha channel, set the value to
	 *                         <code>true</code>. To copy pixels with no alpha
	 *                         channel, set the value to <code>false</code>.
	 * @throws TypeError The sourceBitmapData, sourceRect, destPoint are null.]]></haxe_doc>
		</copyPixels>
		<dispose public="1" set="method" line="398">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Frees memory that is used to store the BitmapData object.
	 *
	 * <p>When the <code>dispose()</code> method is called on an image, the width
	 * and height of the image are set to 0. All subsequent calls to methods or
	 * properties of this BitmapData instance fail, and an exception is thrown.
	 * </p>
	 *
	 * <p><code>BitmapData.dispose()</code> releases the memory occupied by the
	 * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
	 * memory). After using <code>BitmapData.dispose()</code>, the BitmapData
	 * object is no longer usable and an exception may be thrown if
	 * you call functions on the BitmapData object. However,
	 * <code>BitmapData.dispose()</code> does not garbage collect the BitmapData
	 * object(approximately 128 bytes); the memory occupied by the actual
	 * BitmapData object is released at the time the BitmapData object is
	 * collected by the garbage collector.</p>
	 *]]></haxe_doc>
		</dispose>
		<draw public="1" set="method" line="482">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing" v=":null:null:null:null:false">
				<c path="openfl.display.IBitmapDrawable"/>
				<c path="openfl.geom.Matrix"/>
				<c path="openfl.geom.ColorTransform"/>
				<e path="openfl.display.BlendMode"/>
				<c path="openfl.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws the <code>source</code> display object onto the bitmap image, using
	 * the NME software renderer. You can specify <code>matrix</code>,
	 * <code>colorTransform</code>, <code>blendMode</code>, and a destination
	 * <code>clipRect</code> parameter to control how the rendering performs.
	 * Optionally, you can specify whether the bitmap should be smoothed when
	 * scaled(this works only if the source object is a BitmapData object).
	 *
	 * <p>The source display object does not use any of its applied
	 * transformations for this call. It is treated as it exists in the library
	 * or file, with no matrix transform, no color transform, and no blend mode.
	 * To draw a display object(such as a movie clip) by using its own transform
	 * properties, you can copy its <code>transform</code> property object to the
	 * <code>transform</code> property of the Bitmap object that uses the
	 * BitmapData object.</p>
	 * 
	 * @param source         The display object or BitmapData object to draw to
	 *                       the BitmapData object.(The DisplayObject and
	 *                       BitmapData classes implement the IBitmapDrawable
	 *                       interface.)
	 * @param matrix         A Matrix object used to scale, rotate, or translate
	 *                       the coordinates of the bitmap. If you do not want to
	 *                       apply a matrix transformation to the image, set this
	 *                       parameter to an identity matrix, created with the
	 *                       default <code>new Matrix()</code> constructor, or
	 *                       pass a <code>null</code> value.
	 * @param colorTransform A ColorTransform object that you use to adjust the
	 *                       color values of the bitmap. If no object is
	 *                       supplied, the bitmap image's colors are not
	 *                       transformed. If you must pass this parameter but you
	 *                       do not want to transform the image, set this
	 *                       parameter to a ColorTransform object created with
	 *                       the default <code>new ColorTransform()</code>
	 *                       constructor.
	 * @param blendMode      A string value, from the openfl.display.BlendMode
	 *                       class, specifying the blend mode to be applied to
	 *                       the resulting bitmap.
	 * @param clipRect       A Rectangle object that defines the area of the
	 *                       source object to draw. If you do not supply this
	 *                       value, no clipping occurs and the entire source
	 *                       object is drawn.
	 * @param smoothing      A Boolean value that determines whether a BitmapData
	 *                       object is smoothed when scaled or rotated, due to a
	 *                       scaling or rotation in the <code>matrix</code>
	 *                       parameter. The <code>smoothing</code> parameter only
	 *                       applies if the <code>source</code> parameter is a
	 *                       BitmapData object. With <code>smoothing</code> set
	 *                       to <code>false</code>, the rotated or scaled
	 *                       BitmapData image can appear pixelated or jagged. For
	 *                       example, the following two images use the same
	 *                       BitmapData object for the <code>source</code>
	 *                       parameter, but the <code>smoothing</code> parameter
	 *                       is set to <code>true</code> on the left and
	 *                       <code>false</code> on the right:
	 *
	 *                       <p>Drawing a bitmap with <code>smoothing</code> set
	 *                       to <code>true</code> takes longer than doing so with
	 *                       <code>smoothing</code> set to
	 *                       <code>false</code>.</p>
	 * @throws ArgumentError The <code>source</code> parameter is not a
	 *                       BitmapData or DisplayObject object.
	 * @throws ArgumentError The source is null or not a valid IBitmapDrawable
	 *                       object.
	 * @throws SecurityError The <code>source</code> object and(in the case of a
	 *                       Sprite or MovieClip object) all of its child objects
	 *                       do not come from the same domain as the caller, or
	 *                       are not in a content that is accessible to the
	 *                       caller by having called the
	 *                       <code>Security.allowDomain()</code> method. This
	 *                       restriction does not apply to AIR content in the
	 *                       application security sandbox.]]></haxe_doc>
		</draw>
		<encode public="1" set="method" line="544">
			<f a="rect:compressor:?byteArray" v="::null">
				<c path="openfl.geom.Rectangle"/>
				<d/>
				<t path="openfl.utils.ByteArray"/>
				<t path="openfl.utils.ByteArray"/>
			</f>
			<haxe_doc>* Encodes the current image as a JPG or PNG format ByteArray.
	 * 
	 * This method is not available to the HTML5 and Flash targets.
	 * 
	 * @param format  The encoding format, either "png" or "jpg".
	 * @param quality The encoding quality, when encoding with the JPG format.
	 * @return  A ByteArray in the specified encoding format</haxe_doc>
		</encode>
		<fillRect public="1" set="method" line="561">
			<f a="rect:color">
				<c path="openfl.geom.Rectangle"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fills a rectangular area of pixels with a specified ARGB color.
	 * 
	 * @param rect  The rectangular area to fill.
	 * @param color The ARGB color value that fills the area. ARGB colors are
	 *              often specified in hexadecimal format; for example,
	 *              0xFF336699.
	 * @throws TypeError The rect is null.</haxe_doc>
		</fillRect>
		<floodFill public="1" set="method" line="580">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Performs a flood fill operation on an image starting at an(<i>x</i>,
	 * <i>y</i>) coordinate and filling with a certain color. The
	 * <code>floodFill()</code> method is similar to the paint bucket tool in
	 * various paint programs. The color is an ARGB color that contains alpha
	 * information and color information.
	 * 
	 * @param x     The <i>x</i> coordinate of the image.
	 * @param y     The <i>y</i> coordinate of the image.
	 * @param color The ARGB color to use as a fill.]]></haxe_doc>
		</floodFill>
		<generateFilterRect public="1" set="method" line="664">
			<f a="sourceRect:filter">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.filters.BitmapFilter"/>
				<c path="openfl.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Determines the destination rectangle that the <code>applyFilter()</code>
	 * method call affects, given a BitmapData object, a source rectangle, and a
	 * filter object.
	 *
	 * <p>For example, a blur filter normally affects an area larger than the
	 * size of the original image. A 100 x 200 pixel image that is being filtered
	 * by a default BlurFilter instance, where <code>blurX = blurY = 4</code>
	 * generates a destination rectangle of <code>(-2,-2,104,204)</code>. The
	 * <code>generateFilterRect()</code> method lets you find out the size of
	 * this destination rectangle in advance so that you can size the destination
	 * image appropriately before you perform a filter operation.</p>
	 *
	 * <p>Some filters clip their destination rectangle based on the source image
	 * size. For example, an inner <code>DropShadow</code> does not generate a
	 * larger result than its source image. In this API, the BitmapData object is
	 * used as the source bounds and not the source <code>rect</code>
	 * parameter.</p>
	 * 
	 * @param sourceRect A rectangle defining the area of the source image to use
	 *                   as input.
	 * @param filter     A filter object that you use to calculate the
	 *                   destination rectangle.
	 * @return A destination rectangle computed by using an image, the
	 *         <code>sourceRect</code> parameter, and a filter.
	 * @throws TypeError The sourceRect or filter are null.]]></haxe_doc>
		</generateFilterRect>
		<getBuffer public="1" set="method" line="671"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<c path="lime.graphics.opengl.GLBuffer"/>
</f></getBuffer>
		<getColorBoundsRect public="1" set="method" line="730">
			<f a="mask:color:?findColor" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="openfl.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Determines a rectangular region that either fully encloses all pixels of a
	 * specified color within the bitmap image(if the <code>findColor</code>
	 * parameter is set to <code>true</code>) or fully encloses all pixels that
	 * do not include the specified color(if the <code>findColor</code>
	 * parameter is set to <code>false</code>).
	 *
	 * <p>For example, if you have a source image and you want to determine the
	 * rectangle of the image that contains a nonzero alpha channel, pass
	 * <code>{mask: 0xFF000000, color: 0x00000000}</code> as parameters. If the
	 * <code>findColor</code> parameter is set to <code>true</code>, the entire
	 * image is searched for the bounds of pixels for which <code>(value & mask)
	 * == color</code>(where <code>value</code> is the color value of the
	 * pixel). If the <code>findColor</code> parameter is set to
	 * <code>false</code>, the entire image is searched for the bounds of pixels
	 * for which <code>(value & mask) != color</code>(where <code>value</code>
	 * is the color value of the pixel). To determine white space around an
	 * image, pass <code>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</code> to find the
	 * bounds of nonwhite pixels.</p>
	 * 
	 * @param mask      A hexadecimal value, specifying the bits of the ARGB
	 *                  color to consider. The color value is combined with this
	 *                  hexadecimal value, by using the <code>&</code>(bitwise
	 *                  AND) operator.
	 * @param color     A hexadecimal value, specifying the ARGB color to match
	 *                 (if <code>findColor</code> is set to <code>true</code>)
	 *                  or <i>not</i> to match(if <code>findColor</code> is set
	 *                  to <code>false</code>).
	 * @param findColor If the value is set to <code>true</code>, returns the
	 *                  bounds of a color value in an image. If the value is set
	 *                  to <code>false</code>, returns the bounds of where this
	 *                  color doesn't exist in an image.
	 * @return The region of the image that is the specified color.]]></haxe_doc>
		</getColorBoundsRect>
		<getPixel public="1" set="method" line="760">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Returns an integer that represents an RGB pixel value from a BitmapData
	 * object at a specific point(<i>x</i>, <i>y</i>). The
	 * <code>getPixel()</code> method returns an unmultiplied pixel value. No
	 * alpha information is returned.
	 *
	 * <p>All pixels in a BitmapData object are stored as premultiplied color
	 * values. A premultiplied image pixel has the red, green, and blue color
	 * channel values already multiplied by the alpha data. For example, if the
	 * alpha value is 0, the values for the RGB channels are also 0, independent
	 * of their unmultiplied values. This loss of data can cause some problems
	 * when you perform operations. All BitmapData methods take and return
	 * unmultiplied values. The internal pixel representation is converted from
	 * premultiplied to unmultiplied before it is returned as a value. During a
	 * set operation, the pixel value is premultiplied before the raw image pixel
	 * is set.</p>
	 * 
	 * @param x The <i>x</i> position of the pixel.
	 * @param y The <i>y</i> position of the pixel.
	 * @return A number that represents an RGB pixel value. If the(<i>x</i>,
	 *         <i>y</i>) coordinates are outside the bounds of the image, the
	 *         method returns 0.]]></haxe_doc>
		</getPixel>
		<getPixel32 public="1" set="method" line="790">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Returns an ARGB color value that contains alpha channel data and RGB data.
	 * This method is similar to the <code>getPixel()</code> method, which
	 * returns an RGB color without alpha channel data.
	 *
	 * <p>All pixels in a BitmapData object are stored as premultiplied color
	 * values. A premultiplied image pixel has the red, green, and blue color
	 * channel values already multiplied by the alpha data. For example, if the
	 * alpha value is 0, the values for the RGB channels are also 0, independent
	 * of their unmultiplied values. This loss of data can cause some problems
	 * when you perform operations. All BitmapData methods take and return
	 * unmultiplied values. The internal pixel representation is converted from
	 * premultiplied to unmultiplied before it is returned as a value. During a
	 * set operation, the pixel value is premultiplied before the raw image pixel
	 * is set.</p>
	 * 
	 * @param x The <i>x</i> position of the pixel.
	 * @param y The <i>y</i> position of the pixel.
	 * @return A number representing an ARGB pixel value. If the(<i>x</i>,
	 *         <i>y</i>) coordinates are outside the bounds of the image, 0 is
	 *         returned.]]></haxe_doc>
		</getPixel32>
		<getPixels public="1" set="method" line="807">
			<f a="rect">
				<c path="openfl.geom.Rectangle"/>
				<t path="openfl.utils.ByteArray"/>
			</f>
			<haxe_doc>* Generates a byte array from a rectangular region of pixel data. Writes an
	 * unsigned integer(a 32-bit unmultiplied pixel value) for each pixel into
	 * the byte array.
	 * 
	 * @param rect A rectangular area in the current BitmapData object.
	 * @return A ByteArray representing the pixels in the given Rectangle.
	 * @throws TypeError The rect is null.</haxe_doc>
		</getPixels>
		<getTexture public="1" set="method" line="816"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<c path="lime.graphics.opengl.GLTexture"/>
</f></getTexture>
		<getVector public="1" set="method" line="855">
			<f a="rect">
				<c path="openfl.geom.Rectangle"/>
				<x path="openfl.Vector"><x path="UInt"/></x>
			</f>
			<haxe_doc>* Generates a vector array from a rectangular region of pixel data. Returns
	 * a Vector object of unsigned integers(a 32-bit unmultiplied pixel value)
	 * for the specified rectangle.
	 * 
	 * @param rect A rectangular area in the current BitmapData object.
	 * @return A Vector representing the given Rectangle.
	 * @throws TypeError The rect is null.</haxe_doc>
		</getVector>
		<histogram public="1" set="method" line="871"><f a="?hRect" v="null">
	<c path="openfl.geom.Rectangle"/>
	<c path="Array"><c path="Array"><x path="Int"/></c></c>
</f></histogram>
		<hitTest public="1" set="method" line="888"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold" v=":::null:1">
	<c path="openfl.geom.Point"/>
	<x path="Int"/>
	<d/>
	<c path="openfl.geom.Point"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></hitTest>
		<lock public="1" set="method" line="907">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Locks an image so that any objects that reference the BitmapData object,
	 * such as Bitmap objects, are not updated when this BitmapData object
	 * changes. To improve performance, use this method along with the
	 * <code>unlock()</code> method before and after numerous calls to the
	 * <code>setPixel()</code> or <code>setPixel32()</code> method.
	 *]]></haxe_doc>
		</lock>
		<noise public="1" set="method" line="942">
			<f a="randomSeed:?low:?high:?channelOptions:?grayScale" v=":0:255:7:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fills an image with pixels representing random noise.
	 * 
	 * @param randomSeed     The random seed number to use. If you keep all other
	 *                       parameters the same, you can generate different
	 *                       pseudo-random results by varying the random seed
	 *                       value. The noise function is a mapping function, not
	 *                       a true random-number generation function, so it
	 *                       creates the same results each time from the same
	 *                       random seed.
	 * @param low            The lowest value to generate for each channel(0 to
	 *                       255).
	 * @param high           The highest value to generate for each channel(0 to
	 *                       255).
	 * @param channelOptions A number that can be a combination of any of the
	 *                       four color channel values
	 *                      (<code>BitmapDataChannel.RED</code>,
	 *                       <code>BitmapDataChannel.BLUE</code>,
	 *                       <code>BitmapDataChannel.GREEN</code>, and
	 *                       <code>BitmapDataChannel.ALPHA</code>). You can use
	 *                       the logical OR operator(<code>|</code>) to combine
	 *                       channel values.
	 * @param grayScale      A Boolean value. If the value is <code>true</code>,
	 *                       a grayscale image is created by setting all of the
	 *                       color channels to the same value. The alpha channel
	 *                       selection is not affected by setting this parameter
	 *                       to <code>true</code>.]]></haxe_doc>
		</noise>
		<paletteMap public="1" set="method" line="951"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray" v=":::null:null:null:null">
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method" line="1058">
			<f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets" v="::::::7:false:null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.geom.Point"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Generates a Perlin noise image.
	 *
	 * <p>The Perlin noise generation algorithm interpolates and combines
	 * individual random noise functions(called octaves) into a single function
	 * that generates more natural-seeming random noise. Like musical octaves,
	 * each octave function is twice the frequency of the one before it. Perlin
	 * noise has been described as a "fractal sum of noise" because it combines
	 * multiple sets of noise data with different levels of detail.</p>
	 *
	 * <p>You can use Perlin noise functions to simulate natural phenomena and
	 * landscapes, such as wood grain, clouds, and mountain ranges. In most
	 * cases, the output of a Perlin noise function is not displayed directly but
	 * is used to enhance other images and give them pseudo-random
	 * variations.</p>
	 *
	 * <p>Simple digital random noise functions often produce images with harsh,
	 * contrasting points. This kind of harsh contrast is not often found in
	 * nature. The Perlin noise algorithm blends multiple noise functions that
	 * operate at different levels of detail. This algorithm results in smaller
	 * variations among neighboring pixel values.</p>
	 * 
	 * @param baseX          Frequency to use in the <i>x</i> direction. For
	 *                       example, to generate a noise that is sized for a 64
	 *                       x 128 image, pass 64 for the <code>baseX</code>
	 *                       value.
	 * @param baseY          Frequency to use in the <i>y</i> direction. For
	 *                       example, to generate a noise that is sized for a 64
	 *                       x 128 image, pass 128 for the <code>baseY</code>
	 *                       value.
	 * @param numOctaves     Number of octaves or individual noise functions to
	 *                       combine to create this noise. Larger numbers of
	 *                       octaves create images with greater detail. Larger
	 *                       numbers of octaves also require more processing
	 *                       time.
	 * @param randomSeed     The random seed number to use. If you keep all other
	 *                       parameters the same, you can generate different
	 *                       pseudo-random results by varying the random seed
	 *                       value. The Perlin noise function is a mapping
	 *                       function, not a true random-number generation
	 *                       function, so it creates the same results each time
	 *                       from the same random seed.
	 * @param stitch         A Boolean value. If the value is <code>true</code>,
	 *                       the method attempts to smooth the transition edges
	 *                       of the image to create seamless textures for tiling
	 *                       as a bitmap fill.
	 * @param fractalNoise   A Boolean value. If the value is <code>true</code>,
	 *                       the method generates fractal noise; otherwise, it
	 *                       generates turbulence. An image with turbulence has
	 *                       visible discontinuities in the gradient that can
	 *                       make it better approximate sharper visual effects
	 *                       like flames and ocean waves.
	 * @param channelOptions A number that can be a combination of any of the
	 *                       four color channel values
	 *                      (<code>BitmapDataChannel.RED</code>,
	 *                       <code>BitmapDataChannel.BLUE</code>,
	 *                       <code>BitmapDataChannel.GREEN</code>, and
	 *                       <code>BitmapDataChannel.ALPHA</code>). You can use
	 *                       the logical OR operator(<code>|</code>) to combine
	 *                       channel values.
	 * @param grayScale      A Boolean value. If the value is <code>true</code>,
	 *                       a grayscale image is created by setting each of the
	 *                       red, green, and blue color channels to identical
	 *                       values. The alpha channel value is not affected if
	 *                       this value is set to <code>true</code>.]]></haxe_doc>
		</perlinNoise>
		<scroll public="1" set="method" line="1072">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Scrolls an image by a certain(<i>x</i>, <i>y</i>) pixel amount. Edge
	 * regions outside the scrolling area are left unchanged.
	 * 
	 * @param x The amount by which to scroll horizontally.
	 * @param y The amount by which to scroll vertically.]]></haxe_doc>
		</scroll>
		<setPixel public="1" set="method" line="1096">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sets a single pixel of a BitmapData object. The current alpha channel
	 * value of the image pixel is preserved during this operation. The value of
	 * the RGB color parameter is treated as an unmultiplied color value.
	 *
	 * <p><b>Note:</b> To increase performance, when you use the
	 * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	 * call the <code>lock()</code> method before you call the
	 * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	 * the <code>unlock()</code> method when you have made all pixel changes.
	 * This process prevents objects that reference this BitmapData instance from
	 * updating until you finish making the pixel changes.</p>
	 * 
	 * @param x     The <i>x</i> position of the pixel whose value changes.
	 * @param y     The <i>y</i> position of the pixel whose value changes.
	 * @param color The resulting RGB color for the pixel.]]></haxe_doc>
		</setPixel>
		<setPixel32 public="1" set="method" line="1135">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sets the color and alpha transparency values of a single pixel of a
	 * BitmapData object. This method is similar to the <code>setPixel()</code>
	 * method; the main difference is that the <code>setPixel32()</code> method
	 * takes an ARGB color value that contains alpha channel information.
	 *
	 * <p>All pixels in a BitmapData object are stored as premultiplied color
	 * values. A premultiplied image pixel has the red, green, and blue color
	 * channel values already multiplied by the alpha data. For example, if the
	 * alpha value is 0, the values for the RGB channels are also 0, independent
	 * of their unmultiplied values. This loss of data can cause some problems
	 * when you perform operations. All BitmapData methods take and return
	 * unmultiplied values. The internal pixel representation is converted from
	 * premultiplied to unmultiplied before it is returned as a value. During a
	 * set operation, the pixel value is premultiplied before the raw image pixel
	 * is set.</p>
	 *
	 * <p><b>Note:</b> To increase performance, when you use the
	 * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	 * call the <code>lock()</code> method before you call the
	 * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	 * the <code>unlock()</code> method when you have made all pixel changes.
	 * This process prevents objects that reference this BitmapData instance from
	 * updating until you finish making the pixel changes.</p>
	 * 
	 * @param x     The <i>x</i> position of the pixel whose value changes.
	 * @param y     The <i>y</i> position of the pixel whose value changes.
	 * @param color The resulting ARGB color for the pixel. If the bitmap is
	 *              opaque(not transparent), the alpha transparency portion of
	 *              this color value is ignored.]]></haxe_doc>
		</setPixel32>
		<setPixels public="1" set="method" line="1162">
			<f a="rect:byteArray">
				<c path="openfl.geom.Rectangle"/>
				<t path="openfl.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Converts a byte array into a rectangular region of pixel data. For each
	 * pixel, the <code>ByteArray.readUnsignedInt()</code> method is called and
	 * the return value is written into the pixel. If the byte array ends before
	 * the full rectangle is written, the function returns. The data in the byte
	 * array is expected to be 32-bit ARGB pixel values. No seeking is performed
	 * on the byte array before or after the pixels are read.
	 * 
	 * @param rect           Specifies the rectangular region of the BitmapData
	 *                       object.
	 * @param inputByteArray A ByteArray object that consists of 32-bit
	 *                       unmultiplied pixel values to be used in the
	 *                       rectangular region.
	 * @throws EOFError  The <code>inputByteArray</code> object does not include
	 *                   enough data to fill the area of the <code>rect</code>
	 *                   rectangle. The method fills as many pixels as possible
	 *                   before throwing the exception.
	 * @throws TypeError The rect or inputByteArray are null.]]></haxe_doc>
		</setPixels>
		<setVector public="1" set="method" line="1179">
			<f a="rect:inputVector">
				<c path="openfl.geom.Rectangle"/>
				<x path="openfl.Vector"><x path="UInt"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Converts a Vector into a rectangular region of pixel data. For each pixel,
	 * a Vector element is read and written into the BitmapData pixel. The data
	 * in the Vector is expected to be 32-bit ARGB pixel values.
	 * 
	 * @param rect Specifies the rectangular region of the BitmapData object.
	 * @throws RangeError The vector array is not large enough to read all the
	 *                    pixel data.</haxe_doc>
		</setVector>
		<threshold public="1" set="method" line="1248">
			<f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource" v=":::::0:-1:false">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Tests pixel values in an image against a specified threshold and sets
	 * pixels that pass the test to new color values. Using the
	 * <code>threshold()</code> method, you can isolate and replace color ranges
	 * in an image and perform other logical operations on image pixels.
	 *
	 * <p>The <code>threshold()</code> method's test logic is as follows:</p>
	 *
	 * <ol>
	 *   <li>If <code>((pixelValue & mask) operation(threshold & mask))</code>,
	 * then set the pixel to <code>color</code>;</li>
	 *   <li>Otherwise, if <code>copySource == true</code>, then set the pixel to
	 * corresponding pixel value from <code>sourceBitmap</code>.</li>
	 * </ol>
	 *
	 * <p>The <code>operation</code> parameter specifies the comparison operator
	 * to use for the threshold test. For example, by using "==" as the
	 * <code>operation</code> parameter, you can isolate a specific color value
	 * in an image. Or by using <code>{operation: "<", mask: 0xFF000000,
	 * threshold: 0x7F000000, color: 0x00000000}</code>, you can set all
	 * destination pixels to be fully transparent when the source image pixel's
	 * alpha is less than 0x7F. You can use this technique for animated
	 * transitions and other effects.</p>
	 * 
	 * @param sourceBitmapData The input bitmap image to use. The source image
	 *                         can be a different BitmapData object or it can
	 *                         refer to the current BitmapData instance.
	 * @param sourceRect       A rectangle that defines the area of the source
	 *                         image to use as input.
	 * @param destPoint        The point within the destination image(the
	 *                         current BitmapData instance) that corresponds to
	 *                         the upper-left corner of the source rectangle.
	 * @param operation        One of the following comparison operators, passed
	 *                         as a String: "<", "<=", ">", ">=", "==", "!="
	 * @param threshold        The value that each pixel is tested against to see
	 *                         if it meets or exceeds the threshhold.
	 * @param color            The color value that a pixel is set to if the
	 *                         threshold test succeeds. The default value is
	 *                         0x00000000.
	 * @param mask             The mask to use to isolate a color component.
	 * @param copySource       If the value is <code>true</code>, pixel values
	 *                         from the source image are copied to the
	 *                         destination when the threshold test fails. If the
	 *                         value is <code>false</code>, the source image is
	 *                         not copied when the threshold test fails.
	 * @return The number of pixels that were changed.
	 * @throws ArgumentError The operation string is not a valid operation
	 * @throws TypeError     The sourceBitmapData, sourceRect destPoint or
	 *                       operation are null.]]></haxe_doc>
		</threshold>
		<unlock public="1" set="method" line="1415">
			<f a="?changeRect" v="null">
				<c path="openfl.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Unlocks an image so that any objects that reference the BitmapData object,
	 * such as Bitmap objects, are updated when this BitmapData object changes.
	 * To improve performance, use this method along with the <code>lock()</code>
	 * method before and after numerous calls to the <code>setPixel()</code> or
	 * <code>setPixel32()</code> method.
	 * 
	 * @param changeRect The area of the BitmapData object that has changed. If
	 *                   you do not specify a value for this parameter, the
	 *                   entire area of the BitmapData object is considered
	 *                   changed.]]></haxe_doc>
		</unlock>
		<__createUVs set="method" line="1422">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__createUVs>
		<__loadFromBase64 get="inline" set="null" line="1445">
			<f a="base64:type:?onload" v="::null">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="openfl.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__loadFromBase64>
		<__loadFromBytes get="inline" set="null" line="1462">
			<f a="bytes:?rawAlpha:?onload" v=":null:null">
				<t path="openfl.utils.ByteArray"/>
				<t path="openfl.utils.ByteArray"/>
				<f a="">
					<c path="openfl.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__loadFromBytes>
		<__loadFromFile set="method" line="1498">
			<f a="path:onload:onerror">
				<c path="String"/>
				<f a="">
					<c path="openfl.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__loadFromFile>
		<__loadFromImage set="method" line="1515">
			<f a="image">
				<c path="lime.graphics.Image"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__loadFromImage>
		<__renderCanvas public="1" set="method" line="1527">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderCanvas>
		<__renderMask public="1" set="method" line="1557">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__renderMask>
		<__sync set="method" line="1564">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__sync>
		<__updateChildren public="1" set="method" line="1627">
			<f a="transformOnly">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__updateChildren>
		<new public="1" set="method" line="154">
			<f a="width:height:?transparent:?fillColor" v="::true:-1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a BitmapData object with a specified width and height. If you specify a value for 
	 * the <code>fillColor</code> parameter, every pixel in the bitmap is set to that color. 
	 * 
	 * By default, the bitmap is created as transparent, unless you pass the value <code>false</code>
	 * for the transparent parameter. After you create an opaque bitmap, you cannot change it 
	 * to a transparent bitmap. Every pixel in an opaque bitmap uses only 24 bits of color channel 
	 * information. If you define the bitmap as transparent, every pixel uses 32 bits of color 
	 * channel information, including an alpha transparency channel.
	 * 
	 * @param	width		The width of the bitmap image in pixels. 
	 * @param	height		The height of the bitmap image in pixels. 
	 * @param	transparent		Specifies whether the bitmap image supports per-pixel transparency. The default value is <code>true</code>(transparent). To create a fully transparent bitmap, set the value of the <code>transparent</code> parameter to <code>true</code> and the value of the <code>fillColor</code> parameter to 0x00000000(or to 0). Setting the <code>transparent</code> property to <code>false</code> can result in minor improvements in rendering performance.
	 * @param	fillColor		A 32-bit ARGB color value that you use to fill the bitmap image area. The default value is 0xFFFFFFFF(solid white).]]></haxe_doc>
		</new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl.display.TextureUvs" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/BitmapData.hx" module="openfl.display.BitmapData">
		<x0 public="1"><x path="Float"/></x0>
		<x1 public="1"><x path="Float"/></x1>
		<x2 public="1"><x path="Float"/></x2>
		<x3 public="1"><x path="Float"/></x3>
		<y0 public="1"><x path="Float"/></y0>
		<y1 public="1"><x path="Float"/></y1>
		<y2 public="1"><x path="Float"/></y2>
		<y3 public="1"><x path="Float"/></y3>
		<new public="1" set="method" line="1650"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="openfl.display.BitmapDataChannel" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/BitmapDataChannel.hx">
		<ALPHA public="1" get="inline" set="null" line="30" static="1">
			<x path="Int"/>
			<haxe_doc>* The alpha channel.</haxe_doc>
		</ALPHA>
		<BLUE public="1" get="inline" set="null" line="35" static="1">
			<x path="Int"/>
			<haxe_doc>* The blue channel.</haxe_doc>
		</BLUE>
		<GREEN public="1" get="inline" set="null" line="40" static="1">
			<x path="Int"/>
			<haxe_doc>* The green channel.</haxe_doc>
		</GREEN>
		<RED public="1" get="inline" set="null" line="45" static="1">
			<x path="Int"/>
			<haxe_doc>* The red channel.</haxe_doc>
		</RED>
		<haxe_doc><![CDATA[* The BitmapDataChannel class is an enumeration of constant values that
 * indicate which channel to use: red, blue, green, or alpha transparency.
 *
 * <p>When you call some methods, you can use the bitwise OR operator
 * (<code>|</code>) to combine BitmapDataChannel constants to indicate
 * multiple color channels.</p>
 *
 * <p>The BitmapDataChannel constants are provided for use as values in the
 * following:</p>
 *
 * <ul>
 *   <li>The <code>sourceChannel</code> and <code>destChannel</code>
 * parameters of the <code>openfl.display.BitmapData.copyChannel()</code>
 * method</li>
 *   <li>The <code>channelOptions</code> parameter of the
 * <code>openfl.display.BitmapData.noise()</code> method</li>
 *   <li>The <code>openfl.filters.DisplacementMapFilter.componentX</code> and
 * <code>openfl.filters.DisplacementMapFilter.componentY</code> properties</li>
 * </ul>]]></haxe_doc>
	</class>
	<enum path="openfl.display.BlendMode" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/BlendMode.hx">
		<ADD><haxe_doc><![CDATA[* Adds the values of the constituent colors of the display object to the
	 * colors of its background, applying a ceiling of 0xFF. This setting is
	 * commonly used for animating a lightening dissolve between two objects.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the
	 * resulting RGB value for the displayed pixel is 0xFFC833(because 0xAA +
	 * 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33).</p>]]></haxe_doc></ADD>
		<ALPHA><haxe_doc><![CDATA[* Applies the alpha value of each pixel of the display object to the
	 * background. This requires the <code>blendMode</code> property of the
	 * parent display object be set to
	 * <code>openfl.display.BlendMode.LAYER</code>.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></ALPHA>
		<DARKEN><haxe_doc><![CDATA[* Selects the darker of the constituent colors of the display object and the
	 * colors of the background(the colors with the smaller values). This
	 * setting is commonly used for superimposing type.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	 * resulting RGB value for the displayed pixel is 0xDDCC00(because 0xFF >
	 * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></DARKEN>
		<DIFFERENCE><haxe_doc><![CDATA[* Compares the constituent colors of the display object with the colors of
	 * its background, and subtracts the darker of the values of the two
	 * constituent colors from the lighter value. This setting is commonly used
	 * for more vibrant colors.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	 * resulting RGB value for the displayed pixel is 0x222C33(because 0xFF -
	 * 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33).</p>]]></haxe_doc></DIFFERENCE>
		<ERASE><haxe_doc><![CDATA[* Erases the background based on the alpha value of the display object. This
	 * process requires that the <code>blendMode</code> property of the parent
	 * display object be set to <code>openfl.display.BlendMode.LAYER</code>.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></ERASE>
		<HARDLIGHT><haxe_doc><![CDATA[* Adjusts the color of each pixel based on the darkness of the display
	 * object. If the display object is lighter than 50% gray, the display object
	 * and background colors are screened, which results in a lighter color. If
	 * the display object is darker than 50% gray, the colors are multiplied,
	 * which results in a darker color. This setting is commonly used for shading
	 * effects.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></HARDLIGHT>
		<INVERT><haxe_doc>* Inverts the background.</haxe_doc></INVERT>
		<LAYER><haxe_doc><![CDATA[* Forces the creation of a transparency group for the display object. This
	 * means that the display object is precomposed in a temporary buffer before
	 * it is processed further. The precomposition is done automatically if the
	 * display object is precached by means of bitmap caching or if the display
	 * object is a display object container that has at least one child object
	 * with a <code>blendMode</code> setting other than <code>"normal"</code>.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></LAYER>
		<LIGHTEN><haxe_doc><![CDATA[* Selects the lighter of the constituent colors of the display object and
	 * the colors of the background(the colors with the larger values). This
	 * setting is commonly used for superimposing type.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	 * resulting RGB value for the displayed pixel is 0xFFF833(because 0xFF >
	 * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></LIGHTEN>
		<MULTIPLY><haxe_doc><![CDATA[* Multiplies the values of the display object constituent colors by the
	 * constituent colors of the background color, and normalizes by dividing by
	 * 0xFF, resulting in darker colors. This setting is commonly used for
	 * shadows and depth effects.
	 *
	 * <p>For example, if a constituent color(such as red) of one pixel in the
	 * display object and the corresponding color of the pixel in the background
	 * both have the value 0x88, the multiplied result is 0x4840. Dividing by
	 * 0xFF yields a value of 0x48 for that constituent color, which is a darker
	 * shade than the color of the display object or the color of the
	 * background.</p>]]></haxe_doc></MULTIPLY>
		<NORMAL><haxe_doc>* The display object appears in front of the background. Pixel values of the
	 * display object override the pixel values of the background. Where the
	 * display object is transparent, the background is visible.</haxe_doc></NORMAL>
		<OVERLAY><haxe_doc><![CDATA[* Adjusts the color of each pixel based on the darkness of the background.
	 * If the background is lighter than 50% gray, the display object and
	 * background colors are screened, which results in a lighter color. If the
	 * background is darker than 50% gray, the colors are multiplied, which
	 * results in a darker color. This setting is commonly used for shading
	 * effects.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></OVERLAY>
		<SCREEN><haxe_doc>* Multiplies the complement(inverse) of the display object color by the
	 * complement of the background color, resulting in a bleaching effect. This
	 * setting is commonly used for highlights or to remove black areas of the
	 * display object.</haxe_doc></SCREEN>
		<SUBTRACT><haxe_doc><![CDATA[* Subtracts the values of the constituent colors in the display object from
	 * the values of the background color, applying a floor of 0. This setting is
	 * commonly used for animating a darkening dissolve between two objects.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the
	 * resulting RGB value for the displayed pixel is 0x338400(because 0xDD -
	 * 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00).</p>]]></haxe_doc></SUBTRACT>
		<haxe_doc><![CDATA[* A class that provides constant values for visual blend mode effects. These
 * constants are used in the following:
 * <ul>
 *   <li> The <code>blendMode</code> property of the
 * openfl.display.DisplayObject class.</li>
 *   <li> The <code>blendMode</code> parameter of the <code>draw()</code>
 * method of the openfl.display.BitmapData class</li>
 * </ul>]]></haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.display.CapsStyle" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/CapsStyle.hx">
		<NONE><haxe_doc><![CDATA[* Used to specify no caps in the <code>caps</code> parameter of the
	 * <code>openfl.display.Graphics.lineStyle()</code> method.]]></haxe_doc></NONE>
		<ROUND><haxe_doc><![CDATA[* Used to specify round caps in the <code>caps</code> parameter of the
	 * <code>openfl.display.Graphics.lineStyle()</code> method.]]></haxe_doc></ROUND>
		<SQUARE><haxe_doc><![CDATA[* Used to specify square caps in the <code>caps</code> parameter of the
	 * <code>openfl.display.Graphics.lineStyle()</code> method.]]></haxe_doc></SQUARE>
		<haxe_doc><![CDATA[* The CapsStyle class is an enumeration of constant values that specify the
 * caps style to use in drawing lines. The constants are provided for use as
 * values in the <code>caps</code> parameter of the
 * <code>openfl.display.Graphics.lineStyle()</code> method. You can specify the
 * following three types of caps:]]></haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.display.DirectRenderer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/DirectRenderer.hx">
		<extends path="openfl.display.DisplayObject"/>
		<render public="1" get="accessor" set="accessor"><d/></render>
		<__render>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__render>
		<get_render set="method" line="30">
			<f a=""><d/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_render>
		<set_render set="method" line="37">
			<f a="value">
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_render>
		<new public="1" set="method" line="16"><f a="?type" v="'DirectRenderer'">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.text.TextField" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/TextField.hx">
		<extends path="openfl.display.InteractiveObject"/>
		<__defaultTextFormat static="1">
			<c path="openfl.text.TextFormat"/>
			<meta><m n=":noCompletion"/></meta>
		</__defaultTextFormat>
		<antiAliasType public="1"><e path="openfl.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1" set="accessor">
			<e path="openfl.text.TextFieldAutoSize"/>
			<meta><m n=":isVar"/></meta>
		</autoSize>
		<background public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</background>
		<backgroundColor public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</backgroundColor>
		<border public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</border>
		<borderColor public="1" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
		</borderColor>
		<bottomScrollV public="1" get="accessor" set="null"><x path="Int"/></bottomScrollV>
		<caretIndex public="1"><x path="Int"/></caretIndex>
		<caretPos public="1" get="accessor" set="null"><x path="Int"/></caretPos>
		<defaultTextFormat public="1" get="accessor" set="accessor"><c path="openfl.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1"><x path="Bool"/></displayAsPassword>
		<embedFonts public="1"><x path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="openfl.text.GridFitType"/></gridFitType>
		<htmlText public="1" get="accessor" set="accessor"><c path="String"/></htmlText>
		<length public="1" set="null"><x path="Int"/></length>
		<maxChars public="1"><x path="Int"/></maxChars>
		<maxScrollH public="1" get="accessor" set="null"><x path="Int"/></maxScrollH>
		<maxScrollV public="1" get="accessor" set="null"><x path="Int"/></maxScrollV>
		<multiline public="1"><x path="Bool"/></multiline>
		<numLines public="1" get="accessor" set="null"><x path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><x path="Int"/></scrollH>
		<scrollV public="1"><x path="Int"/></scrollV>
		<selectable public="1"><x path="Bool"/></selectable>
		<selectionBeginIndex public="1"><x path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1"><x path="Int"/></selectionEndIndex>
		<sharpness public="1"><x path="Float"/></sharpness>
		<text public="1" get="accessor" set="accessor"><c path="String"/></text>
		<textColor public="1" get="accessor" set="accessor"><x path="Int"/></textColor>
		<textHeight public="1" get="accessor" set="null"><x path="Float"/></textHeight>
		<textWidth public="1" get="accessor" set="null"><x path="Float"/></textWidth>
		<type public="1" set="accessor">
			<e path="openfl.text.TextFieldType"/>
			<meta><m n=":isVar"/></meta>
		</type>
		<wordWrap public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
		</wordWrap>
		<__dirty>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__dirty>
		<__height>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__height>
		<__isHTML>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__isHTML>
		<__measuredHeight>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__measuredHeight>
		<__measuredWidth>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__measuredWidth>
		<__ranges>
			<c path="Array"><c path="openfl.text.TextFormatRange"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__ranges>
		<__text>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__text>
		<__textFormat>
			<c path="openfl.text.TextFormat"/>
			<meta><m n=":noCompletion"/></meta>
		</__textFormat>
		<__texture>
			<c path="lime.graphics.opengl.GLTexture"/>
			<meta><m n=":noCompletion"/></meta>
		</__texture>
		<__width>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__width>
		<appendText public="1" set="method" line="126"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<getCharBoundaries public="1" set="method" line="133"><f a="a">
	<x path="Int"/>
	<c path="openfl.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method" line="142"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getLineIndexAtPoint public="1" set="method" line="151"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getLineMetrics public="1" set="method" line="160"><f a="lineIndex">
	<x path="Int"/>
	<c path="openfl.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method" line="169"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method" line="178"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getTextFormat public="1" set="method" line="187"><f a="?beginIndex:?endIndex" v="0:0">
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.text.TextFormat"/>
</f></getTextFormat>
		<setSelection public="1" set="method" line="194"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method" line="201"><f a="format:?beginIndex:?endIndex" v=":0:0">
	<c path="openfl.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setTextFormat>
		<__getBounds set="method" line="227" override="1">
			<f a="rect:matrix">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getBounds>
		<__getFont set="method" line="237">
			<f a="format">
				<c path="openfl.text.TextFormat"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getFont>
		<__hitTest set="method" line="261" override="1">
			<f a="x:y:shapeFlag:stack:interactiveOnly">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__hitTest>
		<__measureText set="method" line="284">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</__measureText>
		<__measureTextWithDOM set="method" line="317">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__measureTextWithDOM>
		<__renderCanvas public="1" set="method" line="357" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderCanvas>
		<__renderDOM public="1" set="method" line="364" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderDOM>
		<__renderGL public="1" set="method" line="371" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderGL>
		<set_autoSize set="method" line="385">
			<f a="value">
				<e path="openfl.text.TextFieldAutoSize"/>
				<e path="openfl.text.TextFieldAutoSize"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_autoSize>
		<set_background set="method" line="393">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_background>
		<set_backgroundColor set="method" line="401">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_backgroundColor>
		<set_border set="method" line="409">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_border>
		<set_borderColor set="method" line="417">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_borderColor>
		<get_bottomScrollV set="method" line="425">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bottomScrollV>
		<get_caretPos set="method" line="434">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_caretPos>
		<get_defaultTextFormat set="method" line="441">
			<f a=""><c path="openfl.text.TextFormat"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_defaultTextFormat>
		<set_defaultTextFormat set="method" line="448">
			<f a="value">
				<c path="openfl.text.TextFormat"/>
				<c path="openfl.text.TextFormat"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_defaultTextFormat>
		<get_height set="method" line="457" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_height>
		<set_height set="method" line="464" override="1">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_height>
		<get_htmlText set="method" line="479">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_htmlText>
		<set_htmlText set="method" line="488">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_htmlText>
		<get_maxScrollH set="method" line="585">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_maxScrollH>
		<get_maxScrollV set="method" line="586">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_maxScrollV>
		<get_numLines set="method" line="589">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numLines>
		<get_text public="1" set="method" line="610">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_text>
		<set_text public="1" set="method" line="623">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_text>
		<get_textColor public="1" set="method" line="633">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_textColor>
		<set_textColor public="1" set="method" line="640">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_textColor>
		<get_textWidth public="1" set="method" line="659">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_textWidth>
		<get_textHeight public="1" set="method" line="696">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_textHeight>
		<set_type public="1" set="method" line="727">
			<f a="value">
				<e path="openfl.text.TextFieldType"/>
				<e path="openfl.text.TextFieldType"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_type>
		<get_width public="1" set="method" line="735" override="1"><f a=""><x path="Float"/></f></get_width>
		<set_width public="1" set="method" line="751" override="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<get_wordWrap public="1" set="method" line="766">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_wordWrap>
		<set_wordWrap public="1" set="method" line="773">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_wordWrap>
		<new public="1" set="method" line="86"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":access"><e>'???'</e></m>
			<m n=":access"><e>'???'</e></m>
		</meta>
	</class>
	<class path="openfl.display.FPS" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/FPS.hx">
		<extends path="openfl.text.TextField"/>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<cacheCount><x path="Int"/></cacheCount>
		<times><c path="Array"><x path="Float"/></c></times>
		<this_onEnterFrame set="method" line="46">
			<f a="event">
				<c path="openfl.events.Event"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</this_onEnterFrame>
		<new public="1" set="method" line="19"><f a="?x:?y:?color" v="10:10:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.display.FrameLabel" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/FrameLabel.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<frame public="1" get="accessor" set="null"><x path="Int"/></frame>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<__frame>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__frame>
		<__name>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__name>
		<get_frame set="method" line="34">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_frame>
		<get_name set="method" line="35">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_name>
		<new public="1" set="method" line="17"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="openfl.display.GradientType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/GradientType.hx">
		<RADIAL><haxe_doc>* Value used to specify a radial gradient fill.</haxe_doc></RADIAL>
		<LINEAR><haxe_doc>* Value used to specify a linear gradient fill.</haxe_doc></LINEAR>
		<haxe_doc><![CDATA[* The GradientType class provides values for the <code>type</code> parameter
 * in the <code>beginGradientFill()</code> and
 * <code>lineGradientStyle()</code> methods of the openfl.display.Graphics
 * class.]]></haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.display.Graphics" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/Graphics.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></TILE_TRANS_2x2>
		<TILE_RECT public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></TILE_RECT>
		<TILE_ORIGIN public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></TILE_ORIGIN>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></TILE_BLEND_ADD>
		<__bounds>
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__bounds>
		<__commands>
			<c path="Array"><e path="openfl.display.DrawCommand"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__commands>
		<__dirty>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__dirty>
		<__glStack>
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLStack"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__glStack>
		<__drawPaths>
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.DrawPath"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__drawPaths>
		<__halfStrokeWidth>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__halfStrokeWidth>
		<__positionX>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__positionX>
		<__positionY>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__positionY>
		<__visible>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__visible>
		<__cachedTexture>
			<c path="openfl._internal.renderer.opengl.utils.FilterTexture"/>
			<meta><m n=":noCompletion"/></meta>
		</__cachedTexture>
		<beginBitmapFill public="1" set="method" line="111">
			<f a="bitmap:?matrix:?repeat:?smooth" v=":null:true:false">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fills a drawing area with a bitmap image. The bitmap can be repeated or
	 * tiled to fill the area. The fill remains in effect until you call the
	 * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	 * method. Calling the <code>clear()</code> method clears the fill.
	 *
	 * <p>The application renders the fill whenever three or more points are
	 * drawn, or when the <code>endFill()</code> method is called. </p>
	 * 
	 * @param bitmap A transparent or opaque bitmap image that contains the bits
	 *               to be displayed.
	 * @param matrix A matrix object(of the openfl.geom.Matrix class), which you
	 *               can use to define transformations on the bitmap. For
	 *               example, you can use the following matrix to rotate a bitmap
	 *               by 45 degrees(pi/4 radians):
	 * @param repeat If <code>true</code>, the bitmap image repeats in a tiled
	 *               pattern. If <code>false</code>, the bitmap image does not
	 *               repeat, and the edges of the bitmap are used for any fill
	 *               area that extends beyond the bitmap.
	 *
	 *               <p>For example, consider the following bitmap(a 20 x
	 *               20-pixel checkerboard pattern):</p>
	 *
	 *               <p>When <code>repeat</code> is set to <code>true</code>(as
	 *               in the following example), the bitmap fill repeats the
	 *               bitmap:</p>
	 *
	 *               <p>When <code>repeat</code> is set to <code>false</code>,
	 *               the bitmap fill uses the edge pixels for the fill area
	 *               outside the bitmap:</p>
	 * @param smooth If <code>false</code>, upscaled bitmap images are rendered
	 *               by using a nearest-neighbor algorithm and look pixelated. If
	 *               <code>true</code>, upscaled bitmap images are rendered by
	 *               using a bilinear algorithm. Rendering by using the nearest
	 *               neighbor algorithm is faster.]]></haxe_doc>
		</beginBitmapFill>
		<beginFill public="1" set="method" line="134">
			<f a="?color:?alpha" v="0:1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a simple one-color fill that subsequent calls to other Graphics
	 * methods(such as <code>lineTo()</code> or <code>drawCircle()</code>) use
	 * when drawing. The fill remains in effect until you call the
	 * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	 * method. Calling the <code>clear()</code> method clears the fill.
	 *
	 * <p>The application renders the fill whenever three or more points are
	 * drawn, or when the <code>endFill()</code> method is called.</p>
	 * 
	 * @param color The color of the fill(0xRRGGBB).
	 * @param alpha The alpha value of the fill(0.0 to 1.0).]]></haxe_doc>
		</beginFill>
		<beginGradientFill public="1" set="method" line="208">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v="::::null:null:null:null">
				<e path="openfl.display.GradientType"/>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="openfl.geom.Matrix"/>
				<e path="openfl.display.SpreadMethod"/>
				<e path="openfl.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a gradient fill used by subsequent calls to other Graphics
	 * methods(such as <code>lineTo()</code> or <code>drawCircle()</code>) for
	 * the object. The fill remains in effect until you call the
	 * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	 * method. Calling the <code>clear()</code> method clears the fill.
	 *
	 * <p>The application renders the fill whenever three or more points are
	 * drawn, or when the <code>endFill()</code> method is called. </p>
	 * 
	 * @param type                A value from the GradientType class that
	 *                            specifies which gradient type to use:
	 *                            <code>GradientType.LINEAR</code> or
	 *                            <code>GradientType.RADIAL</code>.
	 * @param matrix              A transformation matrix as defined by the
	 *                            openfl.geom.Matrix class. The openfl.geom.Matrix
	 *                            class includes a
	 *                            <code>createGradientBox()</code> method, which
	 *                            lets you conveniently set up the matrix for use
	 *                            with the <code>beginGradientFill()</code>
	 *                            method.
	 * @param spreadMethod        A value from the SpreadMethod class that
	 *                            specifies which spread method to use, either:
	 *                            <code>SpreadMethod.PAD</code>,
	 *                            <code>SpreadMethod.REFLECT</code>, or
	 *                            <code>SpreadMethod.REPEAT</code>.
	 *
	 *                            <p>For example, consider a simple linear
	 *                            gradient between two colors:</p>
	 *
	 *                            <p>This example uses
	 *                            <code>SpreadMethod.PAD</code> for the spread
	 *                            method, and the gradient fill looks like the
	 *                            following:</p>
	 *
	 *                            <p>If you use <code>SpreadMethod.REFLECT</code>
	 *                            for the spread method, the gradient fill looks
	 *                            like the following:</p>
	 *
	 *                            <p>If you use <code>SpreadMethod.REPEAT</code>
	 *                            for the spread method, the gradient fill looks
	 *                            like the following:</p>
	 * @param interpolationMethod A value from the InterpolationMethod class that
	 *                            specifies which value to use:
	 *                            <code>InterpolationMethod.LINEAR_RGB</code> or
	 *                            <code>InterpolationMethod.RGB</code>
	 *
	 *                            <p>For example, consider a simple linear
	 *                            gradient between two colors(with the
	 *                            <code>spreadMethod</code> parameter set to
	 *                            <code>SpreadMethod.REFLECT</code>). The
	 *                            different interpolation methods affect the
	 *                            appearance as follows: </p>
	 * @param focalPointRatio     A number that controls the location of the
	 *                            focal point of the gradient. 0 means that the
	 *                            focal point is in the center. 1 means that the
	 *                            focal point is at one border of the gradient
	 *                            circle. -1 means that the focal point is at the
	 *                            other border of the gradient circle. A value
	 *                            less than -1 or greater than 1 is rounded to -1
	 *                            or 1. For example, the following example shows
	 *                            a <code>focalPointRatio</code> set to 0.75:
	 * @throws ArgumentError If the <code>type</code> parameter is not valid.]]></haxe_doc>
		</beginGradientFill>
		<clear public="1" set="method" line="220">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the graphics that were drawn to this Graphics object, and resets
	 * fill and line style settings.
	 *</haxe_doc>
		</clear>
		<copyFrom public="1" set="method" line="237"><f a="sourceGraphics">
	<c path="openfl.display.Graphics"/>
	<x path="Void"/>
</f></copyFrom>
		<cubicCurveTo public="1" set="method" line="250"><f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></cubicCurveTo>
		<curveTo public="1" set="method" line="303">
			<f a="controlX:controlY:anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws a curve using the current line style from the current drawing
	 * position to(anchorX, anchorY) and using the control point that
	 * (<code>controlX</code>, <code>controlY</code>) specifies. The current
	 * drawing position is then set to(<code>anchorX</code>,
	 * <code>anchorY</code>). If the movie clip in which you are drawing contains
	 * content created with the Flash drawing tools, calls to the
	 * <code>curveTo()</code> method are drawn underneath this content. If you
	 * call the <code>curveTo()</code> method before any calls to the
	 * <code>moveTo()</code> method, the default of the current drawing position
	 * is(0, 0). If any of the parameters are missing, this method fails and the
	 * current drawing position is not changed.
	 *
	 * <p>The curve drawn is a quadratic Bezier curve. Quadratic Bezier curves
	 * consist of two anchor points and one control point. The curve interpolates
	 * the two anchor points and curves toward the control point. </p>
	 * 
	 * @param controlX A number that specifies the horizontal position of the
	 *                 control point relative to the registration point of the
	 *                 parent display object.
	 * @param controlY A number that specifies the vertical position of the
	 *                 control point relative to the registration point of the
	 *                 parent display object.
	 * @param anchorX  A number that specifies the horizontal position of the
	 *                 next anchor point relative to the registration point of
	 *                 the parent display object.
	 * @param anchorY  A number that specifies the vertical position of the next
	 *                 anchor point relative to the registration point of the
	 *                 parent display object.]]></haxe_doc>
		</curveTo>
		<drawCircle public="1" set="method" line="340">
			<f a="x:y:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws a circle. Set the line style, fill, or both before you call the
	 * <code>drawCircle()</code> method, by calling the <code>linestyle()</code>,
	 * <code>lineGradientStyle()</code>, <code>beginFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
	 * method.
	 * 
	 * @param x      The <i>x</i> location of the center of the circle relative
	 *               to the registration point of the parent display object(in
	 *               pixels).
	 * @param y      The <i>y</i> location of the center of the circle relative
	 *               to the registration point of the parent display object(in
	 *               pixels).
	 * @param radius The radius of the circle(in pixels).]]></haxe_doc>
		</drawCircle>
		<drawEllipse public="1" set="method" line="370">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws an ellipse. Set the line style, fill, or both before you call the
	 * <code>drawEllipse()</code> method, by calling the
	 * <code>linestyle()</code>, <code>lineGradientStyle()</code>,
	 * <code>beginFill()</code>, <code>beginGradientFill()</code>, or
	 * <code>beginBitmapFill()</code> method.
	 * 
	 * @param x      The <i>x</i> location of the top-left of the bounding-box of
	 *               the ellipse relative to the registration point of the parent
	 *               display object(in pixels).
	 * @param y      The <i>y</i> location of the top left of the bounding-box of
	 *               the ellipse relative to the registration point of the parent
	 *               display object(in pixels).
	 * @param width  The width of the ellipse(in pixels).
	 * @param height The height of the ellipse(in pixels).]]></haxe_doc>
		</drawEllipse>
		<drawGraphicsData public="1" set="method" line="396">
			<f a="graphicsData">
				<x path="openfl.Vector"><c path="openfl.display.IGraphicsData"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Submits a series of IGraphicsData instances for drawing. This method
	 * accepts a Vector containing objects including paths, fills, and strokes
	 * that implement the IGraphicsData interface. A Vector of IGraphicsData
	 * instances can refer to a part of a shape, or a complex fully defined set
	 * of data for rendering a complete shape.
	 *
	 * <p> Graphics paths can contain other graphics paths. If the
	 * <code>graphicsData</code> Vector includes a path, that path and all its
	 * sub-paths are rendered during this operation. </p>
	 *]]></haxe_doc>
		</drawGraphicsData>
		<drawPath public="1" set="method" line="448">
			<f a="commands:data:?winding" v="::null">
				<x path="openfl.Vector"><x path="Int"/></x>
				<x path="openfl.Vector"><x path="Float"/></x>
				<e path="openfl.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Submits a series of commands for drawing. The <code>drawPath()</code>
	 * method uses vector arrays to consolidate individual <code>moveTo()</code>,
	 * <code>lineTo()</code>, and <code>curveTo()</code> drawing commands into a
	 * single call. The <code>drawPath()</code> method parameters combine drawing
	 * commands with x- and y-coordinate value pairs and a drawing direction. The
	 * drawing commands are values from the GraphicsPathCommand class. The x- and
	 * y-coordinate value pairs are Numbers in an array where each pair defines a
	 * coordinate location. The drawing direction is a value from the
	 * GraphicsPathWinding class.
	 *
	 * <p> Generally, drawings render faster with <code>drawPath()</code> than
	 * with a series of individual <code>lineTo()</code> and
	 * <code>curveTo()</code> methods. </p>
	 *
	 * <p> The <code>drawPath()</code> method uses a uses a floating computation
	 * so rotation and scaling of shapes is more accurate and gives better
	 * results. However, curves submitted using the <code>drawPath()</code>
	 * method can have small sub-pixel alignment errors when used in conjunction
	 * with the <code>lineTo()</code> and <code>curveTo()</code> methods. </p>
	 *
	 * <p> The <code>drawPath()</code> method also uses slightly different rules
	 * for filling and drawing lines. They are: </p>
	 *
	 * <ul>
	 *   <li>When a fill is applied to rendering a path:
	 * <ul>
	 *   <li>A sub-path of less than 3 points is not rendered.(But note that the
	 * stroke rendering will still occur, consistent with the rules for strokes
	 * below.)</li>
	 *   <li>A sub-path that isn't closed(the end point is not equal to the
	 * begin point) is implicitly closed.</li>
	 * </ul>
	 * </li>
	 *   <li>When a stroke is applied to rendering a path:
	 * <ul>
	 *   <li>The sub-paths can be composed of any number of points.</li>
	 *   <li>The sub-path is never implicitly closed.</li>
	 * </ul>
	 * </li>
	 * </ul>
	 * 
	 * @param winding Specifies the winding rule using a value defined in the
	 *                GraphicsPathWinding class.]]></haxe_doc>
		</drawPath>
		<drawRect public="1" set="method" line="472">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws a rectangle. Set the line style, fill, or both before you call the
	 * <code>drawRect()</code> method, by calling the <code>linestyle()</code>,
	 * <code>lineGradientStyle()</code>, <code>beginFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
	 * method.
	 * 
	 * @param x      A number indicating the horizontal position relative to the
	 *               registration point of the parent display object(in pixels).
	 * @param y      A number indicating the vertical position relative to the
	 *               registration point of the parent display object(in pixels).
	 * @param width  The width of the rectangle(in pixels).
	 * @param height The height of the rectangle(in pixels).
	 * @throws ArgumentError If the <code>width</code> or <code>height</code>
	 *                       parameters are not a number
	 *                      (<code>Number.NaN</code>).]]></haxe_doc>
		</drawRect>
		<drawRoundRect public="1" set="method" line="512">
			<f a="x:y:width:height:rx:?ry" v=":::::-1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws a rounded rectangle. Set the line style, fill, or both before you
	 * call the <code>drawRoundRect()</code> method, by calling the
	 * <code>linestyle()</code>, <code>lineGradientStyle()</code>,
	 * <code>beginFill()</code>, <code>beginGradientFill()</code>, or
	 * <code>beginBitmapFill()</code> method.
	 * 
	 * @param x             A number indicating the horizontal position relative
	 *                      to the registration point of the parent display
	 *                      object(in pixels).
	 * @param y             A number indicating the vertical position relative to
	 *                      the registration point of the parent display object
	 *                     (in pixels).
	 * @param width         The width of the round rectangle(in pixels).
	 * @param height        The height of the round rectangle(in pixels).
	 * @param ellipseWidth  The width of the ellipse used to draw the rounded
	 *                      corners(in pixels).
	 * @param ellipseHeight The height of the ellipse used to draw the rounded
	 *                      corners(in pixels). Optional; if no value is
	 *                      specified, the default value matches that provided
	 *                      for the <code>ellipseWidth</code> parameter.
	 * @throws ArgumentError If the <code>width</code>, <code>height</code>,
	 *                       <code>ellipseWidth</code> or
	 *                       <code>ellipseHeight</code> parameters are not a
	 *                       number(<code>Number.NaN</code>).]]></haxe_doc>
		</drawRoundRect>
		<drawRoundRectComplex public="1" set="method" line="529"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawTiles public="1" set="method" line="536"><f a="sheet:tileData:?smooth:?flags:?count" v="::false:0:-1">
	<c path="openfl.display.Tilesheet"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawTiles>
		<drawTriangles public="1" set="method" line="570">
			<f a="vertices:?indices:?uvtData:?culling:?colors:?blendMode" v=":null:null:null:null:0">
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="openfl.Vector"><x path="Int"/></x>
				<x path="openfl.Vector"><x path="Float"/></x>
				<e path="openfl.display.TriangleCulling"/>
				<x path="openfl.Vector"><x path="Int"/></x>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Renders a set of triangles, typically to distort bitmaps and give them a
	 * three-dimensional appearance. The <code>drawTriangles()</code> method maps
	 * either the current fill, or a bitmap fill, to the triangle faces using a
	 * set of(u,v) coordinates.
	 *
	 * <p> Any type of fill can be used, but if the fill has a transform matrix
	 * that transform matrix is ignored. </p>
	 *
	 * <p> A <code>uvtData</code> parameter improves texture mapping when a
	 * bitmap fill is used. </p>
	 * 
	 * @param culling Specifies whether to render triangles that face in a
	 *                specified direction. This parameter prevents the rendering
	 *                of triangles that cannot be seen in the current view. This
	 *                parameter can be set to any value defined by the
	 *                TriangleCulling class.]]></haxe_doc>
		</drawTriangles>
		<endFill public="1" set="method" line="622">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Applies a fill to the lines and curves that were added since the last call
	 * to the <code>beginFill()</code>, <code>beginGradientFill()</code>, or
	 * <code>beginBitmapFill()</code> method. Flash uses the fill that was
	 * specified in the previous call to the <code>beginFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
	 * method. If the current drawing position does not equal the previous
	 * position specified in a <code>moveTo()</code> method and a fill is
	 * defined, the path is closed with a line and then filled.
	 *]]></haxe_doc>
		</endFill>
		<lineBitmapStyle public="1" set="method" line="658">
			<f a="bitmap:?matrix:?repeat:?smooth" v=":null:true:false">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a bitmap to use for the line stroke when drawing lines.
	 *
	 * <p>The bitmap line style is used for subsequent calls to Graphics methods
	 * such as the <code>lineTo()</code> method or the <code>drawCircle()</code>
	 * method. The line style remains in effect until you call the
	 * <code>lineStyle()</code> or <code>lineGradientStyle()</code> methods, or
	 * the <code>lineBitmapStyle()</code> method again with different parameters.
	 * </p>
	 *
	 * <p>You can call the <code>lineBitmapStyle()</code> method in the middle of
	 * drawing a path to specify different styles for different line segments
	 * within a path. </p>
	 *
	 * <p>Call the <code>lineStyle()</code> method before you call the
	 * <code>lineBitmapStyle()</code> method to enable a stroke, or else the
	 * value of the line style is <code>undefined</code>.</p>
	 *
	 * <p>Calls to the <code>clear()</code> method set the line style back to
	 * <code>undefined</code>. </p>
	 * 
	 * @param bitmap The bitmap to use for the line stroke.
	 * @param matrix An optional transformation matrix as defined by the
	 *               openfl.geom.Matrix class. The matrix can be used to scale or
	 *               otherwise manipulate the bitmap before applying it to the
	 *               line style.
	 * @param repeat Whether to repeat the bitmap in a tiled fashion.
	 * @param smooth Whether smoothing should be applied to the bitmap.]]></haxe_doc>
		</lineBitmapStyle>
		<lineGradientStyle public="1" set="method" line="717">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v="::::null:null:null:null">
				<e path="openfl.display.GradientType"/>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="openfl.geom.Matrix"/>
				<e path="openfl.display.SpreadMethod"/>
				<e path="openfl.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a gradient to use for the stroke when drawing lines.
	 *
	 * <p>The gradient line style is used for subsequent calls to Graphics
	 * methods such as the <code>lineTo()</code> methods or the
	 * <code>drawCircle()</code> method. The line style remains in effect until
	 * you call the <code>lineStyle()</code> or <code>lineBitmapStyle()</code>
	 * methods, or the <code>lineGradientStyle()</code> method again with
	 * different parameters. </p>
	 *
	 * <p>You can call the <code>lineGradientStyle()</code> method in the middle
	 * of drawing a path to specify different styles for different line segments
	 * within a path. </p>
	 *
	 * <p>Call the <code>lineStyle()</code> method before you call the
	 * <code>lineGradientStyle()</code> method to enable a stroke, or else the
	 * value of the line style is <code>undefined</code>.</p>
	 *
	 * <p>Calls to the <code>clear()</code> method set the line style back to
	 * <code>undefined</code>. </p>
	 * 
	 * @param type                A value from the GradientType class that
	 *                            specifies which gradient type to use, either
	 *                            GradientType.LINEAR or GradientType.RADIAL.
	 * @param matrix              A transformation matrix as defined by the
	 *                            openfl.geom.Matrix class. The openfl.geom.Matrix
	 *                            class includes a
	 *                            <code>createGradientBox()</code> method, which
	 *                            lets you conveniently set up the matrix for use
	 *                            with the <code>lineGradientStyle()</code>
	 *                            method.
	 * @param spreadMethod        A value from the SpreadMethod class that
	 *                            specifies which spread method to use:
	 * @param interpolationMethod A value from the InterpolationMethod class that
	 *                            specifies which value to use. For example,
	 *                            consider a simple linear gradient between two
	 *                            colors(with the <code>spreadMethod</code>
	 *                            parameter set to
	 *                            <code>SpreadMethod.REFLECT</code>). The
	 *                            different interpolation methods affect the
	 *                            appearance as follows:
	 * @param focalPointRatio     A number that controls the location of the
	 *                            focal point of the gradient. The value 0 means
	 *                            the focal point is in the center. The value 1
	 *                            means the focal point is at one border of the
	 *                            gradient circle. The value -1 means that the
	 *                            focal point is at the other border of the
	 *                            gradient circle. Values less than -1 or greater
	 *                            than 1 are rounded to -1 or 1. The following
	 *                            image shows a gradient with a
	 *                            <code>focalPointRatio</code> of -0.75:]]></haxe_doc>
		</lineGradientStyle>
		<lineStyle public="1" set="method" line="863">
			<f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit" v="null:null:null:null:null:null:null:null">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<e path="openfl.display.LineScaleMode"/>
				<e path="openfl.display.CapsStyle"/>
				<e path="openfl.display.JointStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a line style used for subsequent calls to Graphics methods such
	 * as the <code>lineTo()</code> method or the <code>drawCircle()</code>
	 * method. The line style remains in effect until you call the
	 * <code>lineGradientStyle()</code> method, the
	 * <code>lineBitmapStyle()</code> method, or the <code>lineStyle()</code>
	 * method with different parameters.
	 *
	 * <p>You can call the <code>lineStyle()</code> method in the middle of
	 * drawing a path to specify different styles for different line segments
	 * within the path.</p>
	 *
	 * <p><b>Note: </b>Calls to the <code>clear()</code> method set the line
	 * style back to <code>undefined</code>.</p>
	 *
	 * <p><b>Note: </b>Flash Lite 4 supports only the first three parameters
	 * (<code>thickness</code>, <code>color</code>, and <code>alpha</code>).</p>
	 * 
	 * @param thickness    An integer that indicates the thickness of the line in
	 *                     points; valid values are 0-255. If a number is not
	 *                     specified, or if the parameter is undefined, a line is
	 *                     not drawn. If a value of less than 0 is passed, the
	 *                     default is 0. The value 0 indicates hairline
	 *                     thickness; the maximum thickness is 255. If a value
	 *                     greater than 255 is passed, the default is 255.
	 * @param color        A hexadecimal color value of the line; for example,
	 *                     red is 0xFF0000, blue is 0x0000FF, and so on. If a
	 *                     value is not indicated, the default is 0x000000
	 *                    (black). Optional.
	 * @param alpha        A number that indicates the alpha value of the color
	 *                     of the line; valid values are 0 to 1. If a value is
	 *                     not indicated, the default is 1(solid). If the value
	 *                     is less than 0, the default is 0. If the value is
	 *                     greater than 1, the default is 1.
	 * @param pixelHinting(Not supported in Flash Lite 4) A Boolean value that
	 *                     specifies whether to hint strokes to full pixels. This
	 *                     affects both the position of anchors of a curve and
	 *                     the line stroke size itself. With
	 *                     <code>pixelHinting</code> set to <code>true</code>,
	 *                     line widths are adjusted to full pixel widths. With
	 *                     <code>pixelHinting</code> set to <code>false</code>,
	 *                     disjoints can appear for curves and straight lines.
	 *                     For example, the following illustrations show how
	 *                     Flash Player or Adobe AIR renders two rounded
	 *                     rectangles that are identical, except that the
	 *                     <code>pixelHinting</code> parameter used in the
	 *                     <code>lineStyle()</code> method is set differently
	 *                    (the images are scaled by 200%, to emphasize the
	 *                     difference):
	 *
	 *                     <p>If a value is not supplied, the line does not use
	 *                     pixel hinting.</p>
	 * @param scaleMode   (Not supported in Flash Lite 4) A value from the
	 *                     LineScaleMode class that specifies which scale mode to
	 *                     use:
	 *                     <ul>
	 *                       <li> <code>LineScaleMode.NORMAL</code> - Always
	 *                     scale the line thickness when the object is scaled
	 *                    (the default). </li>
	 *                       <li> <code>LineScaleMode.NONE</code> - Never scale
	 *                     the line thickness. </li>
	 *                       <li> <code>LineScaleMode.VERTICAL</code> - Do not
	 *                     scale the line thickness if the object is scaled
	 *                     vertically <i>only</i>. For example, consider the
	 *                     following circles, drawn with a one-pixel line, and
	 *                     each with the <code>scaleMode</code> parameter set to
	 *                     <code>LineScaleMode.VERTICAL</code>. The circle on the
	 *                     left is scaled vertically only, and the circle on the
	 *                     right is scaled both vertically and horizontally:
	 *                     </li>
	 *                       <li> <code>LineScaleMode.HORIZONTAL</code> - Do not
	 *                     scale the line thickness if the object is scaled
	 *                     horizontally <i>only</i>. For example, consider the
	 *                     following circles, drawn with a one-pixel line, and
	 *                     each with the <code>scaleMode</code> parameter set to
	 *                     <code>LineScaleMode.HORIZONTAL</code>. The circle on
	 *                     the left is scaled horizontally only, and the circle
	 *                     on the right is scaled both vertically and
	 *                     horizontally:   </li>
	 *                     </ul>
	 * @param caps        (Not supported in Flash Lite 4) A value from the
	 *                     CapsStyle class that specifies the type of caps at the
	 *                     end of lines. Valid values are:
	 *                     <code>CapsStyle.NONE</code>,
	 *                     <code>CapsStyle.ROUND</code>, and
	 *                     <code>CapsStyle.SQUARE</code>. If a value is not
	 *                     indicated, Flash uses round caps.
	 *
	 *                     <p>For example, the following illustrations show the
	 *                     different <code>capsStyle</code> settings. For each
	 *                     setting, the illustration shows a blue line with a
	 *                     thickness of 30(for which the <code>capsStyle</code>
	 *                     applies), and a superimposed black line with a
	 *                     thickness of 1(for which no <code>capsStyle</code>
	 *                     applies): </p>
	 * @param joints      (Not supported in Flash Lite 4) A value from the
	 *                     JointStyle class that specifies the type of joint
	 *                     appearance used at angles. Valid values are:
	 *                     <code>JointStyle.BEVEL</code>,
	 *                     <code>JointStyle.MITER</code>, and
	 *                     <code>JointStyle.ROUND</code>. If a value is not
	 *                     indicated, Flash uses round joints.
	 *
	 *                     <p>For example, the following illustrations show the
	 *                     different <code>joints</code> settings. For each
	 *                     setting, the illustration shows an angled blue line
	 *                     with a thickness of 30(for which the
	 *                     <code>jointStyle</code> applies), and a superimposed
	 *                     angled black line with a thickness of 1(for which no
	 *                     <code>jointStyle</code> applies): </p>
	 *
	 *                     <p><b>Note:</b> For <code>joints</code> set to
	 *                     <code>JointStyle.MITER</code>, you can use the
	 *                     <code>miterLimit</code> parameter to limit the length
	 *                     of the miter.</p>
	 * @param miterLimit  (Not supported in Flash Lite 4) A number that
	 *                     indicates the limit at which a miter is cut off. Valid
	 *                     values range from 1 to 255(and values outside that
	 *                     range are rounded to 1 or 255). This value is only
	 *                     used if the <code>jointStyle</code> is set to
	 *                     <code>"miter"</code>. The <code>miterLimit</code>
	 *                     value represents the length that a miter can extend
	 *                     beyond the point at which the lines meet to form a
	 *                     joint. The value expresses a factor of the line
	 *                     <code>thickness</code>. For example, with a
	 *                     <code>miterLimit</code> factor of 2.5 and a
	 *                     <code>thickness</code> of 10 pixels, the miter is cut
	 *                     off at 25 pixels.
	 *
	 *                     <p>For example, consider the following angled lines,
	 *                     each drawn with a <code>thickness</code> of 20, but
	 *                     with <code>miterLimit</code> set to 1, 2, and 4.
	 *                     Superimposed are black reference lines showing the
	 *                     meeting points of the joints:</p>
	 *
	 *                     <p>Notice that a given <code>miterLimit</code> value
	 *                     has a specific maximum angle for which the miter is
	 *                     cut off. The following table lists some examples:</p>]]></haxe_doc>
		</lineStyle>
		<lineTo public="1" set="method" line="889">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws a line using the current line style from the current drawing
	 * position to(<code>x</code>, <code>y</code>); the current drawing position
	 * is then set to(<code>x</code>, <code>y</code>). If the display object in
	 * which you are drawing contains content that was created with the Flash
	 * drawing tools, calls to the <code>lineTo()</code> method are drawn
	 * underneath the content. If you call <code>lineTo()</code> before any calls
	 * to the <code>moveTo()</code> method, the default position for the current
	 * drawing is(<i>0, 0</i>). If any of the parameters are missing, this
	 * method fails and the current drawing position is not changed.
	 * 
	 * @param x A number that indicates the horizontal position relative to the
	 *          registration point of the parent display object(in pixels).
	 * @param y A number that indicates the vertical position relative to the
	 *          registration point of the parent display object(in pixels).]]></haxe_doc>
		</lineTo>
		<moveTo public="1" set="method" line="919">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Moves the current drawing position to(<code>x</code>, <code>y</code>). If
	 * any of the parameters are missing, this method fails and the current
	 * drawing position is not changed.
	 * 
	 * @param x A number that indicates the horizontal position relative to the
	 *          registration point of the parent display object(in pixels).
	 * @param y A number that indicates the vertical position relative to the
	 *          registration point of the parent display object(in pixels).]]></haxe_doc>
		</moveTo>
		<__getBounds set="method" line="929">
			<f a="rect:matrix">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getBounds>
		<__hitTest set="method" line="939">
			<f a="x:y:shapeFlag:matrix">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__hitTest>
		<__inflateBounds set="method" line="951">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__inflateBounds>
		<new public="1" set="method" line="64"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The Graphics class contains a set of methods that you can use to create a
 * vector shape. Display objects that support drawing include Sprite and Shape
 * objects. Each of these classes includes a <code>graphics</code> property
 * that is a Graphics object. The following are among those helper functions
 * provided for ease of use: <code>drawRect()</code>,
 * <code>drawRoundRect()</code>, <code>drawCircle()</code>, and
 * <code>drawEllipse()</code>.
 *
 * <p>You cannot create a Graphics object directly from ActionScript code. If
 * you call <code>new Graphics()</code>, an exception is thrown.</p>
 *
 * <p>The Graphics class is final; it cannot be subclassed.</p>]]></haxe_doc>
	</class>
	<enum path="openfl.display.DrawCommand" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/Graphics.hx" module="openfl.display.Graphics">
		<BeginBitmapFill a="bitmap:matrix:repeat:smooth">
			<c path="openfl.display.BitmapData"/>
			<c path="openfl.geom.Matrix"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</BeginBitmapFill>
		<BeginFill a="color:alpha">
			<x path="Int"/>
			<x path="Float"/>
		</BeginFill>
		<CubicCurveTo a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</CubicCurveTo>
		<CurveTo a="controlX:controlY:anchorX:anchorY">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</CurveTo>
		<DrawCircle a="x:y:radius">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</DrawCircle>
		<DrawEllipse a="x:y:width:height">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</DrawEllipse>
		<DrawRect a="x:y:width:height">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</DrawRect>
		<DrawRoundRect a="x:y:width:height:rx:ry">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
		</DrawRoundRect>
		<DrawTiles a="sheet:tileData:smooth:flags:count">
			<c path="openfl.display.Tilesheet"/>
			<c path="Array"><x path="Float"/></c>
			<x path="Bool"/>
			<x path="Int"/>
			<x path="Int"/>
		</DrawTiles>
		<DrawTriangles a="vertices:indices:uvtData:culling:colors:blendMode">
			<x path="openfl.Vector"><x path="Float"/></x>
			<x path="openfl.Vector"><x path="Int"/></x>
			<x path="openfl.Vector"><x path="Float"/></x>
			<e path="openfl.display.TriangleCulling"/>
			<x path="openfl.Vector"><x path="Int"/></x>
			<x path="Int"/>
		</DrawTriangles>
		<EndFill/>
		<LineStyle a="thickness:color:alpha:pixelHinting:scaleMode:caps:joints:miterLimit">
			<t path="Null"><x path="Float"/></t>
			<t path="Null"><x path="Int"/></t>
			<t path="Null"><x path="Float"/></t>
			<t path="Null"><x path="Bool"/></t>
			<e path="openfl.display.LineScaleMode"/>
			<e path="openfl.display.CapsStyle"/>
			<e path="openfl.display.JointStyle"/>
			<t path="Null"><x path="Float"/></t>
		</LineStyle>
		<LineTo a="x:y">
			<x path="Float"/>
			<x path="Float"/>
		</LineTo>
		<MoveTo a="x:y">
			<x path="Float"/>
			<x path="Float"/>
		</MoveTo>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</enum>
	<class path="openfl.display.IGraphicsFill" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/IGraphicsFill.hx" interface="1"><__graphicsFillType public="1" set="null"><e path="openfl.display.GraphicsFillType"/></__graphicsFillType></class>
	<class path="openfl.display.IGraphicsData" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/IGraphicsData.hx" interface="1"><__graphicsDataType public="1" set="null"><e path="openfl.display.GraphicsDataType"/></__graphicsDataType></class>
	<class path="openfl.display.GraphicsBitmapFill" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/GraphicsBitmapFill.hx">
		<implements path="openfl.display.IGraphicsFill"/>
		<implements path="openfl.display.IGraphicsData"/>
		<bitmapData public="1"><c path="openfl.display.BitmapData"/></bitmapData>
		<matrix public="1"><c path="openfl.geom.Matrix"/></matrix>
		<repeat public="1"><x path="Bool"/></repeat>
		<smooth public="1"><x path="Bool"/></smooth>
		<__graphicsDataType public="1" set="null">
			<e path="openfl.display.GraphicsDataType"/>
			<meta><m n=":noCompletion"/></meta>
		</__graphicsDataType>
		<__graphicsFillType public="1" set="null">
			<e path="openfl.display.GraphicsFillType"/>
			<meta><m n=":noCompletion"/></meta>
		</__graphicsFillType>
		<new public="1" set="method" line="22"><f a="?bitmapData:?matrix:?repeat:?smooth" v="null:null:true:false">
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.display.GraphicsEndFill" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/GraphicsEndFill.hx">
		<implements path="openfl.display.IGraphicsFill"/>
		<implements path="openfl.display.IGraphicsData"/>
		<__graphicsDataType public="1" set="null">
			<e path="openfl.display.GraphicsDataType"/>
			<meta><m n=":noCompletion"/></meta>
		</__graphicsDataType>
		<__graphicsFillType public="1" set="null">
			<e path="openfl.display.GraphicsFillType"/>
			<meta><m n=":noCompletion"/></meta>
		</__graphicsFillType>
		<new public="1" set="method" line="26">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Creates an object to use with the <code>Graphics.drawGraphicsData()</code>
	 * method to end the fill, explicitly.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Indicates the end of a graphics fill. Use a GraphicsEndFill object with the
 * <code>Graphics.drawGraphicsData()</code> method.
 *
 * <p> Drawing a GraphicsEndFill object is the equivalent of calling the
 * <code>Graphics.endFill()</code> method. </p>]]></haxe_doc>
	</class>
	<class path="openfl.display.GraphicsGradientFill" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/GraphicsGradientFill.hx">
		<implements path="openfl.display.IGraphicsFill"/>
		<implements path="openfl.display.IGraphicsData"/>
		<alphas public="1"><c path="Array"><x path="Float"/></c></alphas>
		<colors public="1"><c path="Array"><x path="Int"/></c></colors>
		<focalPointRatio public="1"><x path="Float"/></focalPointRatio>
		<interpolationMethod public="1"><e path="openfl.display.InterpolationMethod"/></interpolationMethod>
		<matrix public="1"><c path="openfl.geom.Matrix"/></matrix>
		<ratios public="1"><c path="Array"><x path="Float"/></c></ratios>
		<spreadMethod public="1"><e path="openfl.display.SpreadMethod"/></spreadMethod>
		<type public="1"><e path="openfl.display.GradientType"/></type>
		<__graphicsDataType public="1" set="null"><e path="openfl.display.GraphicsDataType"/></__graphicsDataType>
		<__graphicsFillType public="1" set="null"><e path="openfl.display.GraphicsFillType"/></__graphicsFillType>
		<new public="1" set="method" line="25"><f a="?type:?colors:?alphas:?ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v="null:null:null:null:null:null:null:0">
	<e path="openfl.display.GradientType"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="openfl.geom.Matrix"/>
	<e path="openfl.display.SpreadMethod"/>
	<e path="openfl.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.display.IGraphicsPath" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/IGraphicsPath.hx" interface="1"/>
	<class path="openfl.display.GraphicsPath" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/GraphicsPath.hx">
		<implements path="openfl.display.IGraphicsPath"/>
		<implements path="openfl.display.IGraphicsData"/>
		<commands public="1">
			<x path="openfl.Vector"><x path="Int"/></x>
			<haxe_doc>* The Vector of drawing commands as integers representing the path. Each
	 * command can be one of the values defined by the GraphicsPathCommand class.</haxe_doc>
		</commands>
		<data public="1">
			<x path="openfl.Vector"><x path="Float"/></x>
			<haxe_doc>* The Vector of Numbers containing the parameters used with the drawing
	 * commands.</haxe_doc>
		</data>
		<winding public="1">
			<e path="openfl.display.GraphicsPathWinding"/>
			<haxe_doc>* Specifies the winding rule using a value defined in the
	 * GraphicsPathWinding class.</haxe_doc>
		</winding>
		<__graphicsDataType public="1" set="null">
			<e path="openfl.display.GraphicsDataType"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__graphicsDataType>
		<curveTo public="1" set="method" line="87">
			<f a="controlX:controlY:anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new "curveTo" command to the <code>commands</code> vector and new
	 * coordinates to the <code>data</code> vector.
	 * 
	 * @param controlX A number that specifies the horizontal position of the
	 *                 control point relative to the registration point of the
	 *                 parent display object.
	 * @param controlY A number that specifies the vertical position of the
	 *                 control point relative to the registration point of the
	 *                 parent display object.
	 * @param anchorX  A number that specifies the horizontal position of the
	 *                 next anchor point relative to the registration point of
	 *                 the parent display object.
	 * @param anchorY  A number that specifies the vertical position of the next
	 *                 anchor point relative to the registration point of the
	 *                 parent display object.]]></haxe_doc>
		</curveTo>
		<lineTo public="1" set="method" line="109">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new "lineTo" command to the <code>commands</code> vector and new
	 * coordinates to the <code>data</code> vector.
	 * 
	 * @param x The x coordinate of the destination point for the line.
	 * @param y The y coordinate of the destination point for the line.]]></haxe_doc>
		</lineTo>
		<moveTo public="1" set="method" line="129">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new "moveTo" command to the <code>commands</code> vector and new
	 * coordinates to the <code>data</code> vector.
	 * 
	 * @param x The x coordinate of the destination point.
	 * @param y The y coordinate of the destination point.]]></haxe_doc>
		</moveTo>
		<wideLineTo public="1" set="method" line="149">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new "wideLineTo" command to the <code>commands</code> vector and
	 * new coordinates to the <code>data</code> vector.
	 * 
	 * @param x The x-coordinate of the destination point for the line.
	 * @param y The y-coordinate of the destination point for the line.]]></haxe_doc>
		</wideLineTo>
		<wideMoveTo public="1" set="method" line="169">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new "wideMoveTo" command to the <code>commands</code> vector and
	 * new coordinates to the <code>data</code> vector.
	 * 
	 * @param x The x-coordinate of the destination point.
	 * @param y The y-coordinate of the destination point.]]></haxe_doc>
		</wideMoveTo>
		<new public="1" set="method" line="54">
			<f a="?commands:?data:?winding" v="null:null:null">
				<x path="openfl.Vector"><x path="Int"/></x>
				<x path="openfl.Vector"><x path="Float"/></x>
				<e path="openfl.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new GraphicsPath object.
	 * 
	 * @param winding Specifies the winding rule using a value defined in the
	 *                GraphicsPathWinding class.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A collection of drawing commands and the coordinate parameters for those
 * commands.
 *
 * <p> Use a GraphicsPath object with the
 * <code>Graphics.drawGraphicsData()</code> method. Drawing a GraphicsPath
 * object is the equivalent of calling the <code>Graphics.drawPath()</code>
 * method. </p>
 *
 * <p>The GraphicsPath class also has its own set of methods
 * (<code>curveTo()</code>, <code>lineTo()</code>, <code>moveTo()</code>
 * <code>wideLineTo()</code> and <code>wideMoveTo()</code>) similar to those
 * in the Graphics class for making adjustments to the
 * <code>GraphicsPath.commands</code> and <code>GraphicsPath.data</code>
 * vector arrays.</p>]]></haxe_doc>
	</class>
	<class path="openfl.display.GraphicsPathCommand" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/GraphicsPathCommand.hx">
		<LINE_TO public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></LINE_TO>
		<MOVE_TO public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></MOVE_TO>
		<CURVE_TO public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></CURVE_TO>
		<WIDE_LINE_TO public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></WIDE_LINE_TO>
		<WIDE_MOVE_TO public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></WIDE_MOVE_TO>
		<NO_OP public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></NO_OP>
		<CUBIC_CURVE_TO public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></CUBIC_CURVE_TO>
		<haxe_doc><![CDATA[* Defines the values to use for specifying path-drawing commands.
 *
 * <p>The values in this class are used by the
 * <code>Graphics.drawPath()</code> method, or stored in the
 * <code>commands</code> vector of a GraphicsPath object.</p>]]></haxe_doc>
	</class>
	<enum path="openfl.display.GraphicsPathWinding" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/GraphicsPathWinding.hx">
		<EVEN_ODD/>
		<NON_ZERO/>
		<haxe_doc><![CDATA[* The GraphicsPathWinding class provides values for the
 * <code>openfl.display.GraphicsPath.winding</code> property and the
 * <code>openfl.display.Graphics.drawPath()</code> method to determine the
 * direction to draw a path. A clockwise path is positively wound, and a
 * counter-clockwise path is negatively wound:
 *
 * <p> When paths intersect or overlap, the winding direction determines the
 * rules for filling the areas created by the intersection or overlap:</p>]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="openfl.display.GraphicsSolidFill" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/GraphicsSolidFill.hx">
		<implements path="openfl.display.IGraphicsFill"/>
		<implements path="openfl.display.IGraphicsData"/>
		<alpha public="1">
			<x path="Float"/>
			<haxe_doc>* Indicates the alpha transparency value of the fill. Valid values are 0
	 * (fully transparent) to 1(fully opaque). The default value is 1. Display
	 * objects with alpha set to 0 are active, even though they are invisible.</haxe_doc>
		</alpha>
		<color public="1">
			<x path="UInt"/>
			<haxe_doc>* The color of the fill. Valid values are in the hexadecimal format
	 * 0xRRGGBB. The default value is 0xFF0000(or the uint 0).</haxe_doc>
		</color>
		<__graphicsDataType public="1" set="null">
			<e path="openfl.display.GraphicsDataType"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__graphicsDataType>
		<__graphicsFillType public="1" set="null">
			<e path="openfl.display.GraphicsFillType"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__graphicsFillType>
		<new public="1" set="method" line="44">
			<f a="?color:?alpha" v="0:1">
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new GraphicsSolidFill object.
	 * 
	 * @param color The color value. Valid values are in the hexadecimal format
	 *              0xRRGGBB.
	 * @param alpha The alpha transparency value. Valid values are 0(fully
	 *              transparent) to 1(fully opaque).</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Defines a solid fill.
 *
 * <p> Use a GraphicsSolidFill object with the
 * <code>Graphics.drawGraphicsData()</code> method. Drawing a
 * GraphicsSolidFill object is the equivalent of calling the
 * <code>Graphics.beginFill()</code> method. </p>]]></haxe_doc>
	</class>
	<class path="openfl.display.IGraphicsStroke" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/IGraphicsStroke.hx" interface="1"/>
	<class path="openfl.display.GraphicsStroke" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/GraphicsStroke.hx">
		<implements path="openfl.display.IGraphicsStroke"/>
		<implements path="openfl.display.IGraphicsData"/>
		<caps public="1">
			<e path="openfl.display.CapsStyle"/>
			<haxe_doc><![CDATA[* Specifies the type of caps at the end of lines. Valid values are:
	 * <code>CapsStyle.NONE</code>, <code>CapsStyle.ROUND</code>, and
	 * <code>CapsStyle.SQUARE</code>. If a value is not indicated, Flash uses
	 * round caps.
	 *
	 * <p>For example, the following illustrations show the different
	 * <code>capsStyle</code> settings. For each setting, the illustration shows
	 * a blue line with a thickness of 30(for which the <code>capsStyle</code>
	 * applies), and a superimposed black line with a thickness of 1(for which
	 * no <code>capsStyle</code> applies): </p>]]></haxe_doc>
		</caps>
		<fill public="1">
			<c path="openfl.display.IGraphicsFill"/>
			<haxe_doc>* Specifies the instance containing data for filling a stroke. An
	 * IGraphicsFill instance can represent a series of fill commands.</haxe_doc>
		</fill>
		<joints public="1">
			<e path="openfl.display.JointStyle"/>
			<haxe_doc><![CDATA[* Specifies the type of joint appearance used at angles. Valid values are:
	 * <code>JointStyle.BEVEL</code>, <code>JointStyle.MITER</code>, and
	 * <code>JointStyle.ROUND</code>. If a value is not indicated, Flash uses
	 * round joints.
	 *
	 * <p>For example, the following illustrations show the different
	 * <code>joints</code> settings. For each setting, the illustration shows an
	 * angled blue line with a thickness of 30(for which the
	 * <code>jointStyle</code> applies), and a superimposed angled black line
	 * with a thickness of 1(for which no <code>jointStyle</code> applies): </p>
	 *
	 * <p><b>Note:</b> For <code>joints</code> set to
	 * <code>JointStyle.MITER</code>, you can use the <code>miterLimit</code>
	 * parameter to limit the length of the miter.</p>]]></haxe_doc>
		</joints>
		<miterLimit public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the limit at which a miter is cut off. Valid values range from 1
	 * to 255(and values outside that range are rounded to 1 or 255). This value
	 * is only used if the <code>jointStyle</code> is set to
	 * <code>"miter"</code>. The <code>miterLimit</code> value represents the
	 * length that a miter can extend beyond the point at which the lines meet to
	 * form a joint. The value expresses a factor of the line
	 * <code>thickness</code>. For example, with a <code>miterLimit</code> factor
	 * of 2.5 and a <code>thickness</code> of 10 pixels, the miter is cut off at
	 * 25 pixels.
	 *
	 * <p>For example, consider the following angled lines, each drawn with a
	 * <code>thickness</code> of 20, but with <code>miterLimit</code> set to 1,
	 * 2, and 4. Superimposed are black reference lines showing the meeting
	 * points of the joints:</p>
	 *
	 * <p>Notice that a given <code>miterLimit</code> value has a specific
	 * maximum angle for which the miter is cut off. The following table lists
	 * some examples:</p>]]></haxe_doc>
		</miterLimit>
		<pixelHinting public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether to hint strokes to full pixels. This affects both the
	 * position of anchors of a curve and the line stroke size itself. With
	 * <code>pixelHinting</code> set to <code>true</code>, Flash Player hints
	 * line widths to full pixel widths. With <code>pixelHinting</code> set to
	 * <code>false</code>, disjoints can appear for curves and straight lines.
	 * For example, the following illustrations show how Flash Player renders two
	 * rounded rectangles that are identical, except that the
	 * <code>pixelHinting</code> parameter used in the <code>lineStyle()</code>
	 * method is set differently(the images are scaled by 200%, to emphasize the
	 * difference):]]></haxe_doc>
		</pixelHinting>
		<scaleMode public="1">
			<e path="openfl.display.LineScaleMode"/>
			<haxe_doc><![CDATA[* Specifies the stroke thickness scaling. Valid values are:
	 * <ul>
	 *   <li> <code>LineScaleMode.NORMAL</code> - Always scale the line thickness
	 * when the object is scaled(the default). </li>
	 *   <li> <code>LineScaleMode.NONE</code> - Never scale the line thickness.
	 * </li>
	 *   <li> <code>LineScaleMode.VERTICAL</code> - Do not scale the line
	 * thickness if the object is scaled vertically <i>only</i>. For example,
	 * consider the following circles, drawn with a one-pixel line, and each with
	 * the <code>scaleMode</code> parameter set to
	 * <code>LineScaleMode.VERTICAL</code>. The circle on the left is scaled
	 * vertically only, and the circle on the right is scaled both vertically and
	 * horizontally:   </li>
	 *   <li> <code>LineScaleMode.HORIZONTAL</code> - Do not scale the line
	 * thickness if the object is scaled horizontally <i>only</i>. For example,
	 * consider the following circles, drawn with a one-pixel line, and each with
	 * the <code>scaleMode</code> parameter set to
	 * <code>LineScaleMode.HORIZONTAL</code>. The circle on the left is scaled
	 * horizontally only, and the circle on the right is scaled both vertically
	 * and horizontally:   </li>
	 * </ul>]]></haxe_doc>
		</scaleMode>
		<thickness public="1">
			<x path="Float"/>
			<haxe_doc>* Indicates the thickness of the line in points; valid values are 0-255. If
	 * a number is not specified, or if the parameter is undefined, a line is not
	 * drawn. If a value of less than 0 is passed, the default is 0. The value 0
	 * indicates hairline thickness; the maximum thickness is 255. If a value
	 * greater than 255 is passed, the default is 255.</haxe_doc>
		</thickness>
		<__graphicsDataType public="1" set="null">
			<e path="openfl.display.GraphicsDataType"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__graphicsDataType>
		<new public="1" set="method" line="213">
			<f a="?thickness:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit:?fill" v="0.0f:false:null:null:null:3:null">
				<x path="Float"/>
				<x path="Bool"/>
				<e path="openfl.display.LineScaleMode"/>
				<e path="openfl.display.CapsStyle"/>
				<e path="openfl.display.JointStyle"/>
				<x path="Float"/>
				<c path="openfl.display.IGraphicsFill"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new GraphicsStroke object.
	 * 
	 * @param pixelHinting A Boolean value that specifies whether to hint strokes
	 *                     to full pixels. This affects both the position of
	 *                     anchors of a curve and the line stroke size itself.
	 *                     With <code>pixelHinting</code> set to
	 *                     <code>true</code>, Flash Player hints line widths to
	 *                     full pixel widths. With <code>pixelHinting</code> set
	 *                     to <code>false</code>, disjoints can appear for curves
	 *                     and straight lines. For example, the following
	 *                     illustrations show how Flash Player renders two
	 *                     rounded rectangles that are identical, except that the
	 *                     <code>pixelHinting</code> parameter used in the
	 *                     <code>lineStyle()</code> method is set differently
	 *                    (the images are scaled by 200%, to emphasize the
	 *                     difference):
	 *
	 *                     <p>If a value is not supplied, the line does not use
	 *                     pixel hinting.</p>
	 * @param scaleMode    A value from the LineScaleMode class that specifies
	 *                     which scale mode to use:
	 *                     <ul>
	 *                       <li> <code>LineScaleMode.NORMAL</code> - Always
	 *                     scale the line thickness when the object is scaled
	 *                    (the default). </li>
	 *                       <li> <code>LineScaleMode.NONE</code> - Never scale
	 *                     the line thickness. </li>
	 *                       <li> <code>LineScaleMode.VERTICAL</code> - Do not
	 *                     scale the line thickness if the object is scaled
	 *                     vertically <i>only</i>. For example, consider the
	 *                     following circles, drawn with a one-pixel line, and
	 *                     each with the <code>scaleMode</code> parameter set to
	 *                     <code>LineScaleMode.VERTICAL</code>. The circle on the
	 *                     left is scaled vertically only, and the circle on the
	 *                     right is scaled both vertically and horizontally:
	 *                     </li>
	 *                       <li> <code>LineScaleMode.HORIZONTAL</code> - Do not
	 *                     scale the line thickness if the object is scaled
	 *                     horizontally <i>only</i>. For example, consider the
	 *                     following circles, drawn with a one-pixel line, and
	 *                     each with the <code>scaleMode</code> parameter set to
	 *                     <code>LineScaleMode.HORIZONTAL</code>. The circle on
	 *                     the left is scaled horizontally only, and the circle
	 *                     on the right is scaled both vertically and
	 *                     horizontally:   </li>
	 *                     </ul>
	 * @param caps         A value from the CapsStyle class that specifies the
	 *                     type of caps at the end of lines. Valid values are:
	 *                     <code>CapsStyle.NONE</code>,
	 *                     <code>CapsStyle.ROUND</code>, and
	 *                     <code>CapsStyle.SQUARE</code>. If a value is not
	 *                     indicated, Flash uses round caps.
	 *
	 *                     <p>For example, the following illustrations show the
	 *                     different <code>capsStyle</code> settings. For each
	 *                     setting, the illustration shows a blue line with a
	 *                     thickness of 30(for which the <code>capsStyle</code>
	 *                     applies), and a superimposed black line with a
	 *                     thickness of 1(for which no <code>capsStyle</code>
	 *                     applies): </p>
	 * @param joints       A value from the JointStyle class that specifies the
	 *                     type of joint appearance used at angles. Valid values
	 *                     are: <code>JointStyle.BEVEL</code>,
	 *                     <code>JointStyle.MITER</code>, and
	 *                     <code>JointStyle.ROUND</code>. If a value is not
	 *                     indicated, Flash uses round joints.
	 *
	 *                     <p>For example, the following illustrations show the
	 *                     different <code>joints</code> settings. For each
	 *                     setting, the illustration shows an angled blue line
	 *                     with a thickness of 30(for which the
	 *                     <code>jointStyle</code> applies), and a superimposed
	 *                     angled black line with a thickness of 1(for which no
	 *                     <code>jointStyle</code> applies): </p>
	 *
	 *                     <p><b>Note:</b> For <code>joints</code> set to
	 *                     <code>JointStyle.MITER</code>, you can use the
	 *                     <code>miterLimit</code> parameter to limit the length
	 *                     of the miter.</p>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Defines a line style or stroke.
 *
 * <p> Use a GraphicsStroke object with the
 * <code>Graphics.drawGraphicsData()</code> method. Drawing a GraphicsStroke
 * object is the equivalent of calling one of the methods of the Graphics
 * class that sets the line style, such as the
 * <code>Graphics.lineStyle()</code> method, the
 * <code>Graphics.lineBitmapStyle()</code> method, or the
 * <code>Graphics.lineGradientStyle()</code> method. </p>]]></haxe_doc>
	</class>
	<enum path="openfl.display.GraphicsDataType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/IGraphicsData.hx" module="openfl.display.IGraphicsData">
		<STROKE/>
		<SOLID/>
		<GRADIENT/>
		<PATH/>
		<BITMAP/>
		<END/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>Int</e></m>
		</meta>
	</enum>
	<enum path="openfl.display.GraphicsFillType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/IGraphicsFill.hx" module="openfl.display.IGraphicsFill">
		<SOLID_FILL/>
		<GRADIENT_FILL/>
		<BITMAP_FILL/>
		<END_FILL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>Int</e></m>
		</meta>
	</enum>
	<enum path="openfl.display.InterpolationMethod" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/InterpolationMethod.hx">
		<RGB><haxe_doc><![CDATA[* Specifies that the RGB interpolation method should be used. This means
	 * that the gradient is rendered with exponential sRGB(standard RGB) space.
	 * The sRGB space is a W3C-endorsed standard that defines a non-linear
	 * conversion between red, green, and blue component values and the actual
	 * intensity of the visible component color.
	 *
	 * <p>For example, consider a simple linear gradient between two colors(with
	 * the <code>spreadMethod</code> parameter set to
	 * <code>SpreadMethod.REFLECT</code>). The different interpolation methods
	 * affect the appearance as follows: </p>]]></haxe_doc></RGB>
		<LINEAR_RGB><haxe_doc><![CDATA[* Specifies that the RGB interpolation method should be used. This means
	 * that the gradient is rendered with exponential sRGB(standard RGB) space.
	 * The sRGB space is a W3C-endorsed standard that defines a non-linear
	 * conversion between red, green, and blue component values and the actual
	 * intensity of the visible component color.
	 *
	 * <p>For example, consider a simple linear gradient between two colors(with
	 * the <code>spreadMethod</code> parameter set to
	 * <code>SpreadMethod.REFLECT</code>). The different interpolation methods
	 * affect the appearance as follows: </p>]]></haxe_doc></LINEAR_RGB>
		<haxe_doc><![CDATA[* The InterpolationMethod class provides values for the
 * <code>interpolationMethod</code> parameter in the
 * <code>Graphics.beginGradientFill()</code> and
 * <code>Graphics.lineGradientStyle()</code> methods. This parameter
 * determines the RGB space to use when rendering the gradient.]]></haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.display.JointStyle" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/JointStyle.hx">
		<MITER><haxe_doc><![CDATA[* Specifies mitered joints in the <code>joints</code> parameter of the
	 * <code>openfl.display.Graphics.lineStyle()</code> method.]]></haxe_doc></MITER>
		<ROUND><haxe_doc><![CDATA[* Specifies round joints in the <code>joints</code> parameter of the
	 * <code>openfl.display.Graphics.lineStyle()</code> method.]]></haxe_doc></ROUND>
		<BEVEL><haxe_doc><![CDATA[* Specifies beveled joints in the <code>joints</code> parameter of the
	 * <code>openfl.display.Graphics.lineStyle()</code> method.]]></haxe_doc></BEVEL>
		<haxe_doc><![CDATA[* The JointStyle class is an enumeration of constant values that specify the
 * joint style to use in drawing lines. These constants are provided for use
 * as values in the <code>joints</code> parameter of the
 * <code>openfl.display.Graphics.lineStyle()</code> method. The method supports
 * three types of joints: miter, round, and bevel, as the following example
 * shows:]]></haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.display.LineScaleMode" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/LineScaleMode.hx">
		<HORIZONTAL><haxe_doc><![CDATA[* With this setting used as the <code>scaleMode</code> parameter of the
	 * <code>lineStyle()</code> method, the thickness of the line scales
	 * <i>only</i> vertically. For example, consider the following circles, drawn
	 * with a one-pixel line, and each with the <code>scaleMode</code> parameter
	 * set to <code>LineScaleMode.VERTICAL</code>. The circle on the left is
	 * scaled only vertically, and the circle on the right is scaled both
	 * vertically and horizontally.]]></haxe_doc></HORIZONTAL>
		<NONE><haxe_doc><![CDATA[* With this setting used as the <code>scaleMode</code> parameter of the
	 * <code>lineStyle()</code> method, the thickness of the line never scales.]]></haxe_doc></NONE>
		<NORMAL><haxe_doc><![CDATA[* With this setting used as the <code>scaleMode</code> parameter of the
	 * <code>lineStyle()</code> method, the thickness of the line always scales
	 * when the object is scaled(the default).]]></haxe_doc></NORMAL>
		<VERTICAL><haxe_doc><![CDATA[* With this setting used as the <code>scaleMode</code> parameter of the
	 * <code>lineStyle()</code> method, the thickness of the line scales
	 * <i>only</i> horizontally. For example, consider the following circles,
	 * drawn with a one-pixel line, and each with the <code>scaleMode</code>
	 * parameter set to <code>LineScaleMode.HORIZONTAL</code>. The circle on the
	 * left is scaled only horizontally, and the circle on the right is scaled
	 * both vertically and horizontally.]]></haxe_doc></VERTICAL>
		<haxe_doc><![CDATA[* The LineScaleMode class provides values for the <code>scaleMode</code>
 * parameter in the <code>Graphics.lineStyle()</code> method.]]></haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.display.Loader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/Loader.hx">
		<extends path="openfl.display.Sprite"/>
		<content public="1" set="null">
			<c path="openfl.display.DisplayObject"/>
			<haxe_doc><![CDATA[* Contains the root display object of the SWF file or image(JPG, PNG, or
	 * GIF) file that was loaded by using the <code>load()</code> or
	 * <code>loadBytes()</code> methods.
	 * 
	 * @throws SecurityError The loaded SWF file or image file belongs to a
	 *                       security sandbox to which you do not have access.
	 *                       For a loaded SWF file, you can avoid this situation
	 *                       by having the file call the
	 *                       <code>Security.allowDomain()</code> method or by
	 *                       having the loading file specify a
	 *                       <code>loaderContext</code> parameter with its
	 *                       <code>securityDomain</code> property set to
	 *                       <code>SecurityDomain.currentDomain</code> when you
	 *                       call the <code>load()</code> or
	 *                       <code>loadBytes()</code> method.]]></haxe_doc>
		</content>
		<contentLoaderInfo public="1" set="null">
			<c path="openfl.display.LoaderInfo"/>
			<haxe_doc><![CDATA[* Returns a LoaderInfo object corresponding to the object being loaded.
	 * LoaderInfo objects are shared between the Loader object and the loaded
	 * content object. The LoaderInfo object supplies loading progress
	 * information and statistics about the loaded file.
	 *
	 * <p>Events related to the load are dispatched by the LoaderInfo object
	 * referenced by the <code>contentLoaderInfo</code> property of the Loader
	 * object. The <code>contentLoaderInfo</code> property is set to a valid
	 * LoaderInfo object, even before the content is loaded, so that you can add
	 * event listeners to the object prior to the load.</p>
	 *
	 * <p>To detect uncaught errors that happen in a loaded SWF, use the
	 * <code>Loader.uncaughtErrorEvents</code> property, not the
	 * <code>Loader.contentLoaderInfo.uncaughtErrorEvents</code> property.</p>]]></haxe_doc>
		</contentLoaderInfo>
		<mImage><c path="openfl.display.BitmapData"/></mImage>
		<mShape><c path="openfl.display.Shape"/></mShape>
		<close public="1" set="method" line="189">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Cancels a <code>load()</code> method operation that is currently in
	 * progress for the Loader instance.
	 *]]></haxe_doc>
		</close>
		<load public="1" set="method" line="357">
			<f a="request:?context" v=":null">
				<c path="openfl.net.URLRequest"/>
				<c path="openfl.system.LoaderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Loads a SWF, JPEG, progressive JPEG, unanimated GIF, or PNG file into an
	 * object that is a child of this Loader object. If you load an animated GIF
	 * file, only the first frame is displayed. As the Loader object can contain
	 * only a single child, issuing a subsequent <code>load()</code> request
	 * terminates the previous request, if still pending, and commences a new
	 * load.
	 *
	 * <p><b>Note</b>: In AIR 1.5 and Flash Player 10, the maximum size for a
	 * loaded image is 8,191 pixels in width or height, and the total number of
	 * pixels cannot exceed 16,777,215 pixels.(So, if an loaded image is 8,191
	 * pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and
	 * earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height
	 * and 2,880 pixels in width.</p>
	 *
	 * <p>A SWF file or image loaded into a Loader object inherits the position,
	 * rotation, and scale properties of the parent display objects of the Loader
	 * object. </p>
	 *
	 * <p>Use the <code>unload()</code> method to remove movies or images loaded
	 * with this method, or to cancel a load operation that is in progress.</p>
	 *
	 * <p>You can prevent a SWF file from using this method by setting the
	 * <code>allowNetworking</code> parameter of the the <code>object</code> and
	 * <code>embed</code> tags in the HTML page that contains the SWF
	 * content.</p>
	 *
	 * <p>When you use this method, consider the Flash Player security model,
	 * which is described in the Loader class description. </p>
	 *
	 * <p> In Flash Player 10 and later, if you use a multipart Content-Type(for
	 * example "multipart/form-data") that contains an upload(indicated by a
	 * "filename" parameter in a "content-disposition" header within the POST
	 * body), the POST operation is subject to the security rules applied to
	 * uploads:</p>
	 *
	 * <ul>
	 *   <li>The POST operation must be performed in response to a user-initiated
	 * action, such as a mouse click or key press.</li>
	 *   <li>If the POST operation is cross-domain(the POST target is not on the
	 * same server as the SWF file that is sending the POST request), the target
	 * server must provide a URL policy file that permits cross-domain
	 * access.</li>
	 * </ul>
	 *
	 * <p>Also, for any multipart Content-Type, the syntax must be valid
	 * (according to the RFC2046 standard). If the syntax appears to be invalid,
	 * the POST operation is subject to the security rules applied to
	 * uploads.</p>
	 *
	 * <p>For more information related to security, see the Flash Player
	 * Developer Center Topic: <a
	 * href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>
	 * 
	 * @param request The absolute or relative URL of the SWF, JPEG, GIF, or PNG
	 *                file to be loaded. A relative path must be relative to the
	 *                main SWF file. Absolute URLs must include the protocol
	 *                reference, such as http:// or file:///. Filenames cannot
	 *                include disk drive specifications.
	 * @param context A LoaderContext object, which has properties that define
	 *                the following:
	 *                <ul>
	 *                  <li>Whether or not to check for the existence of a policy
	 *                file upon loading the object</li>
	 *                  <li>The ApplicationDomain for the loaded object</li>
	 *                  <li>The SecurityDomain for the loaded object</li>
	 *                  <li>The ImageDecodingPolicy for the loaded image
	 *                object</li>
	 *                </ul>
	 *
	 *                <p>If the <code>context</code> parameter is not specified
	 *                or refers to a null object, the loaded content remains in
	 *                its own security domain.</p>
	 *
	 *                <p>For complete details, see the description of the
	 *                properties in the <a
	 *                href="../system/LoaderContext.html">LoaderContext</a>
	 *                class.</p>
	 * @throws IOError               The <code>digest</code> property of the
	 *                               <code>request</code> object is not
	 *                               <code>null</code>. You should only set the
	 *                               <code>digest</code> property of a URLRequest
	 *                               object when calling the
	 *                               <code>URLLoader.load()</code> method when
	 *                               loading a SWZ file(an Adobe platform
	 *                               component).
	 * @throws IllegalOperationError If the <code>requestedContentParent</code>
	 *                               property of the <code>context</code>
	 *                               parameter is a <code>Loader</code>.
	 * @throws IllegalOperationError If the <code>LoaderContext.parameters</code>
	 *                               parameter is set to non-null and has some
	 *                               values which are not Strings.
	 * @throws SecurityError         The value of
	 *                               <code>LoaderContext.securityDomain</code>
	 *                               must be either <code>null</code> or
	 *                               <code>SecurityDomain.currentDomain</code>.
	 *                               This reflects the fact that you can only
	 *                               place the loaded media in its natural
	 *                               security sandbox or your own(the latter
	 *                               requires a policy file).
	 * @throws SecurityError         Local SWF files may not set
	 *                               LoaderContext.securityDomain to anything
	 *                               other than <code>null</code>. It is not
	 *                               permitted to import non-local media into a
	 *                               local sandbox, or to place other local media
	 *                               in anything other than its natural sandbox.
	 * @throws SecurityError         You cannot connect to commonly reserved
	 *                               ports. For a complete list of blocked ports,
	 *                               see "Restricting Networking APIs" in the
	 *                               <i>ActionScript 3.0 Developer's Guide</i>.
	 * @throws SecurityError         If the <code>applicationDomain</code> or
	 *                               <code>securityDomain</code> properties of
	 *                               the <code>context</code> parameter are from
	 *                               a disallowed domain.
	 * @throws SecurityError         If a local SWF file is attempting to use the
	 *                               <code>securityDomain</code> property of the
	 *                               <code>context</code> parameter.
	 * @event asyncError    Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      property has been specified and it is not possible to
	 *                      add the loaded content as a child to the specified
	 *                      DisplayObjectContainer. This could happen if the
	 *                      loaded content is a
	 *                      <code>openfl.display.AVM1Movie</code> or if the
	 *                      <code>addChild()</code> call to the
	 *                      requestedContentParent throws an error.
	 * @event complete      Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the file has completed loading. The
	 *                      <code>complete</code> event is always dispatched
	 *                      after the <code>init</code> event.
	 * @event httpStatus    Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when a network request is made over HTTP and
	 *                      Flash Player can detect the HTTP status code.
	 * @event init          Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the properties and methods of the loaded
	 *                      SWF file are accessible. The <code>init</code> event
	 *                      always precedes the <code>complete</code> event.
	 * @event ioError       Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when an input or output error occurs that
	 *                      causes a load operation to fail.
	 * @event open          Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the loading operation starts.
	 * @event progress      Dispatched by the <code>contentLoaderInfo</code>
	 *                      object as data is received while load operation
	 *                      progresses.
	 * @event securityError Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if a SWF file in the local-with-filesystem
	 *                      sandbox attempts to load content in the
	 *                      local-with-networking sandbox, or vice versa.
	 * @event securityError Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      property has been specified and the security sandbox
	 *                      of the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      does not have access to the loaded SWF.
	 * @event unload        Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when a loaded object is removed.]]></haxe_doc>
		</load>
		<loadBytes public="1" set="method" line="491">
			<f a="buffer">
				<t path="openfl.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Loads from binary data stored in a ByteArray object.
	 *
	 * <p>The <code>loadBytes()</code> method is asynchronous. You must wait for
	 * the "init" event before accessing the properties of a loaded object.</p>
	 *
	 * <p>When you use this method, consider the Flash Player security model,
	 * which is described in the Loader class description. </p>
	 * 
	 * @param bytes   A ByteArray object. The contents of the ByteArray can be
	 *                any of the file formats supported by the Loader class: SWF,
	 *                GIF, JPEG, or PNG.
	 * @param context A LoaderContext object. Only the
	 *                <code>applicationDomain</code> property of the
	 *                LoaderContext object applies; the
	 *                <code>checkPolicyFile</code> and
	 *                <code>securityDomain</code> properties of the LoaderContext
	 *                object do not apply.
	 *
	 *                <p>If the <code>context</code> parameter is not specified
	 *                or refers to a null object, the content is loaded into the
	 *                current security domain -  a process referred to as "import
	 *                loading" in Flash Player security documentation.
	 *                Specifically, if the loading SWF file trusts the remote SWF
	 *                by incorporating the remote SWF into its code, then the
	 *                loading SWF can import it directly into its own security
	 *                domain.</p>
	 *
	 *                <p>For more information related to security, see the Flash
	 *                Player Developer Center Topic: <a
	 *                href="http://www.adobe.com/go/devnet_security_en"
	 *                scope="external">Security</a>.</p>
	 * @throws ArgumentError         If the <code>length</code> property of the
	 *                               ByteArray object is not greater than 0.
	 * @throws IllegalOperationError If the <code>checkPolicyFile</code> or
	 *                               <code>securityDomain</code> property of the
	 *                               <code>context</code> parameter are non-null.
	 * @throws IllegalOperationError If the <code>requestedContentParent</code>
	 *                               property of the <code>context</code>
	 *                               parameter is a <code>Loader</code>.
	 * @throws IllegalOperationError If the <code>LoaderContext.parameters</code>
	 *                               parameter is set to non-null and has some
	 *                               values which are not Strings.
	 * @throws SecurityError         If the provided
	 *                               <code>applicationDomain</code> property of
	 *                               the <code>context</code> property is from a
	 *                               disallowed domain.
	 * @throws SecurityError         You cannot connect to commonly reserved
	 *                               ports. For a complete list of blocked ports,
	 *                               see "Restricting Networking APIs" in the
	 *                               <i>ActionScript 3.0 Developer's Guide</i>.
	 * @event asyncError    Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      property has been specified and it is not possible to
	 *                      add the loaded content as a child to the specified
	 *                      DisplayObjectContainer. This could happen if the
	 *                      loaded content is a
	 *                      <code>openfl.display.AVM1Movie</code> or if the
	 *                      <code>addChild()</code> call to the
	 *                      requestedContentParent throws an error.
	 * @event complete      Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the operation is complete. The
	 *                      <code>complete</code> event is always dispatched
	 *                      after the <code>init</code> event.
	 * @event init          Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the properties and methods of the loaded
	 *                      data are accessible. The <code>init</code> event
	 *                      always precedes the <code>complete</code> event.
	 * @event ioError       Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the runtime cannot parse the data in the
	 *                      byte array.
	 * @event open          Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the operation starts.
	 * @event progress      Dispatched by the <code>contentLoaderInfo</code>
	 *                      object as data is transfered in memory.
	 * @event securityError Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      property has been specified and the security sandbox
	 *                      of the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      does not have access to the loaded SWF.
	 * @event unload        Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when a loaded object is removed.]]></haxe_doc>
		</loadBytes>
		<unload public="1" set="method" line="521">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Removes a child of this Loader object that was loaded by using the
	 * <code>load()</code> method. The <code>property</code> of the associated
	 * LoaderInfo object is reset to <code>null</code>. The child is not
	 * necessarily destroyed because other objects might have references to it;
	 * however, it is no longer a child of the Loader object.
	 *
	 * <p>As a best practice, before you unload a child SWF file, you should
	 * explicitly close any streams in the child SWF file's objects, such as
	 * LocalConnection, NetConnection, NetStream, and Sound objects. Otherwise,
	 * audio in the child SWF file might continue to play, even though the child
	 * SWF file was unloaded. To close streams in the child SWF file, add an
	 * event listener to the child that listens for the <code>unload</code>
	 * event. When the parent calls <code>Loader.unload()</code>, the
	 * <code>unload</code> event is dispatched to the child. The following code
	 * shows how you might do this:</p>
	 * <pre xml:space="preserve"> function closeAllStreams(evt:Event) {
	 * myNetStream.close(); mySound.close(); myNetConnection.close();
	 * myLocalConnection.close(); }
	 * myMovieClip.loaderInfo.addEventListener(Event.UNLOAD,
	 * closeAllStreams);</pre>
	 *]]></haxe_doc>
		</unload>
		<unloadAndStop public="1" set="method" line="577">
			<f a="?gc" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Attempts to unload child SWF file contents and stops the execution of
	 * commands from loaded SWF files. This method attempts to unload SWF files
	 * that were loaded using <code>Loader.load()</code> or
	 * <code>Loader.loadBytes()</code> by removing references to EventDispatcher,
	 * NetConnection, Timer, Sound, or Video objects of the child SWF file. As a
	 * result, the following occurs for the child SWF file and the child SWF
	 * file's display list:
	 * <ul>
	 *   <li>Sounds are stopped.</li>
	 *   <li>Stage event listeners are removed.</li>
	 *   <li>Event listeners for <code>enterFrame</code>,
	 * <code>frameConstructed</code>, <code>exitFrame</code>,
	 * <code>activate</code> and <code>deactivate</code> are removed.</li>
	 *   <li>Timers are stopped.</li>
	 *   <li>Camera and Microphone instances are detached</li>
	 *   <li>Movie clips are stopped.</li>
	 * </ul>
	 * 
	 * @param gc Provides a hint to the garbage collector to run on the child SWF
	 *           objects(<code>true</code>) or not(<code>false</code>). If you
	 *           are unloading many objects asynchronously, setting the
	 *           <code>gc</code> paramter to <code>false</code> might improve
	 *           application performance. However, if the parameter is set to
	 *           <code>false</code>, media and display objects of the child SWF
	 *           file might persist in memory after running the
	 *           <code>unloadAndStop()</code> command.]]></haxe_doc>
		</unloadAndStop>
		<BitmapData_onLoad set="method" line="591">
			<f a="bitmapData">
				<c path="openfl.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</BitmapData_onLoad>
		<BitmapData_onError set="method" line="605">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</BitmapData_onError>
		<new public="1" set="method" line="175">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Creates a Loader object that you can use to load files, such as SWF, JPEG,
	 * GIF, or PNG files. Call the <code>load()</code> method to load the asset
	 * as a child of the Loader instance. You can then add the Loader object to
	 * the display list(for instance, by using the <code>addChild()</code>
	 * method of a DisplayObjectContainer instance). The asset appears on the
	 * Stage as it loads.
	 *
	 * <p>You can also use a Loader instance "offlist," that is without adding it
	 * to a display object container on the display list. In this mode, the
	 * Loader instance might be used to load a SWF file that contains additional
	 * modules of an application. </p>
	 *
	 * <p>To detect when the SWF file is finished loading, you can use the events
	 * of the LoaderInfo object associated with the
	 * <code>contentLoaderInfo</code> property of the Loader object. At that
	 * point, the code in the module SWF file can be executed to initialize and
	 * start the module. In the offlist mode, a Loader instance might also be
	 * used to load a SWF file that contains components or media assets. Again,
	 * you can use the LoaderInfo object event notifications to detect when the
	 * components are finished loading. At that point, the application can start
	 * using the components and media assets in the library of the SWF file by
	 * instantiating the ActionScript 3.0 classes that represent those components
	 * and assets.</p>
	 *
	 * <p>To determine the status of a Loader object, monitor the following
	 * events that the LoaderInfo object associated with the
	 * <code>contentLoaderInfo</code> property of the Loader object:</p>
	 *
	 * <ul>
	 *   <li>The <code>open</code> event is dispatched when loading begins.</li>
	 *   <li>The <code>ioError</code> or <code>securityError</code> event is
	 * dispatched if the file cannot be loaded or if an error occured during the
	 * load process. </li>
	 *   <li>The <code>progress</code> event fires continuously while the file is
	 * being loaded.</li>
	 *   <li>The <code>complete</code> event is dispatched when a file completes
	 * downloading, but before the loaded movie clip's methods and properties are
	 * available. </li>
	 *   <li>The <code>init</code> event is dispatched after the properties and
	 * methods of the loaded SWF file are accessible, so you can begin
	 * manipulating the loaded SWF file. This event is dispatched before the
	 * <code>complete</code> handler. In streaming SWF files, the
	 * <code>init</code> event can occur significantly earlier than the
	 * <code>complete</code> event. For most purposes, use the <code>init</code>
	 * handler.</li>
	 * </ul>]]></haxe_doc>
		</new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl.display.OpenGLView" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/OpenGLView.hx">
		<extends path="openfl.display.DirectRenderer"/>
		<CONTEXT_LOST public="1" get="inline" set="null" line="24" static="1"><c path="String"/></CONTEXT_LOST>
		<CONTEXT_RESTORED public="1" get="inline" set="null" line="25" static="1"><c path="String"/></CONTEXT_RESTORED>
		<isSupported public="1" get="accessor" set="null" static="1"><x path="Bool"/></isSupported>
		<get_isSupported set="method" line="199" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isSupported>
		<__added>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__added>
		<__initialized>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__initialized>
		<__renderCanvas public="1" set="method" line="77" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderCanvas>
		<__renderDOM public="1" set="method" line="93" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderDOM>
		<__renderGL public="1" set="method" line="169" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderGL>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<enum path="openfl.display.PixelSnapping" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.display.Shape" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/Shape.hx">
		<extends path="openfl.display.DisplayObject"/>
		<graphics public="1" get="accessor" set="null"><c path="openfl.display.Graphics"/></graphics>
		<__getBounds set="method" line="27" override="1">
			<f a="rect:matrix">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getBounds>
		<__hitTest set="method" line="38" override="1">
			<f a="x:y:shapeFlag:stack:interactiveOnly">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__hitTest>
		<__renderCanvas public="1" set="method" line="57" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderCanvas>
		<__renderDOM public="1" set="method" line="64" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderDOM>
		<__renderGL public="1" set="method" line="71" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__renderGL>
		<get_graphics set="method" line="91">
			<f a=""><c path="openfl.display.Graphics"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_graphics>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl.display.SimpleButton" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/SimpleButton.hx">
		<extends path="openfl.display.DisplayObjectContainer"/>
		<downState public="1" set="accessor"><c path="openfl.display.DisplayObject"/></downState>
		<enabled public="1"><x path="Bool"/></enabled>
		<hitTestState public="1" set="accessor"><c path="openfl.display.DisplayObject"/></hitTestState>
		<overState public="1" set="accessor"><c path="openfl.display.DisplayObject"/></overState>
		<soundTransform public="1" get="accessor" set="accessor"><c path="openfl.media.SoundTransform"/></soundTransform>
		<trackAsMenu public="1"><x path="Bool"/></trackAsMenu>
		<upState public="1" set="accessor"><c path="openfl.display.DisplayObject"/></upState>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<__currentState set="accessor">
			<c path="openfl.display.DisplayObject"/>
			<meta><m n=":noCompletion"/></meta>
		</__currentState>
		<__soundTransform>
			<c path="openfl.media.SoundTransform"/>
			<meta><m n=":noCompletion"/></meta>
		</__soundTransform>
		<switchState set="method" line="44">
			<f a="state">
				<c path="openfl.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</switchState>
		<__generateDefaultState set="method" line="61">
			<f a=""><c path="openfl.display.DisplayObject"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__generateDefaultState>
		<set_downState set="method" line="75">
			<f a="downState">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_downState>
		<set_hitTestState set="method" line="83">
			<f a="hitTestState">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_hitTestState>
		<set_overState set="method" line="117">
			<f a="overState">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_overState>
		<get_soundTransform set="method" line="125">
			<f a=""><c path="openfl.media.SoundTransform"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_soundTransform>
		<set_soundTransform set="method" line="138">
			<f a="value">
				<c path="openfl.media.SoundTransform"/>
				<c path="openfl.media.SoundTransform"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_soundTransform>
		<set_upState set="method" line="146">
			<f a="upState">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_upState>
		<set___currentState set="method" line="154">
			<f a="state">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.DisplayObject"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set___currentState>
		<__this_onMouseDown set="method" line="171">
			<f a="event">
				<c path="openfl.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__this_onMouseDown>
		<__this_onMouseOut set="method" line="178">
			<f a="event">
				<c path="openfl.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__this_onMouseOut>
		<__this_onMouseOver set="method" line="189">
			<f a="event">
				<c path="openfl.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__this_onMouseOver>
		<__this_onMouseUp set="method" line="200">
			<f a="event">
				<c path="openfl.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__this_onMouseUp>
		<new public="1" set="method" line="26"><f a="?upState:?overState:?downState:?hitTestState" v="null:null:null:null">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="openfl.display.SpreadMethod" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.display.Stage" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/Stage.hx">
		<extends path="openfl.display.Sprite"/>
		<align public="1"><e path="openfl.display.StageAlign"/></align>
		<allowsFullScreen public="1"><x path="Bool"/></allowsFullScreen>
		<color public="1" get="accessor" set="accessor"><x path="Int"/></color>
		<displayState public="1" set="accessor"><e path="openfl.display.StageDisplayState"/></displayState>
		<focus public="1" get="accessor" set="accessor"><c path="openfl.display.InteractiveObject"/></focus>
		<frameRate public="1"><x path="Float"/></frameRate>
		<quality public="1"><e path="openfl.display.StageQuality"/></quality>
		<stageFocusRect public="1"><x path="Bool"/></stageFocusRect>
		<scaleMode public="1"><e path="openfl.display.StageScaleMode"/></scaleMode>
		<stageHeight public="1" set="null"><x path="Int"/></stageHeight>
		<stageWidth public="1" set="null"><x path="Int"/></stageWidth>
		<__clearBeforeRender>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__clearBeforeRender>
		<__color>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__color>
		<__colorSplit>
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__colorSplit>
		<__colorString>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__colorString>
		<__cursor>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__cursor>
		<__cursorHidden>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__cursorHidden>
		<__dirty>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__dirty>
		<__dragBounds>
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__dragBounds>
		<__dragObject>
			<c path="openfl.display.Sprite"/>
			<meta><m n=":noCompletion"/></meta>
		</__dragObject>
		<__dragOffsetX>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__dragOffsetX>
		<__dragOffsetY>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__dragOffsetY>
		<__focus>
			<c path="openfl.display.InteractiveObject"/>
			<meta><m n=":noCompletion"/></meta>
		</__focus>
		<__fullscreen>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__fullscreen>
		<__invalidated>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__invalidated>
		<__mouseX>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__mouseX>
		<__mouseY>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__mouseY>
		<__originalWidth>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__originalWidth>
		<__originalHeight>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__originalHeight>
		<__renderer>
			<c path="openfl._internal.renderer.AbstractRenderer"/>
			<meta><m n=":noCompletion"/></meta>
		</__renderer>
		<__stack>
			<c path="Array"><c path="openfl.display.DisplayObject"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__stack>
		<__transparent>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__transparent>
		<__wasDirty>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__wasDirty>
		<globalToLocal public="1" set="method" line="126" override="1"><f a="pos">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></globalToLocal>
		<invalidate public="1" set="method" line="133"><f a=""><x path="Void"/></f></invalidate>
		<localToGlobal public="1" set="method" line="140" override="1"><f a="pos">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></localToGlobal>
		<__drag set="method" line="147">
			<f a="mouse">
				<c path="openfl.geom.Point"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__drag>
		<__fireEvent set="method" line="189">
			<f a="event:stack">
				<c path="openfl.events.Event"/>
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fireEvent>
		<__getInteractive set="method" line="250" override="1">
			<f a="stack">
				<c path="Array"><c path="openfl.display.DisplayObject"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__getInteractive>
		<__render set="method" line="257">
			<f a="context">
				<e path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__render>
		<__resize set="method" line="310">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__resize>
		<__setCursor set="method" line="371">
			<f a="cursor">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setCursor>
		<__setCursorHidden set="method" line="389">
			<f a="value">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setCursorHidden>
		<__startDrag set="method" line="403">
			<f a="sprite:lockCenter:bounds">
				<c path="openfl.display.Sprite"/>
				<x path="Bool"/>
				<c path="openfl.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__startDrag>
		<__stopDrag set="method" line="436">
			<f a="sprite">
				<c path="openfl.display.Sprite"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__stopDrag>
		<__update public="1" set="method" line="444" override="1">
			<f a="transformOnly:updateChildren">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__update>
		<get_mouseX set="method" line="506" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mouseX>
		<get_mouseY set="method" line="513" override="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_mouseY>
		<get_color set="method" line="550">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color set="method" line="557">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<get_focus set="method" line="571">
			<f a=""><c path="openfl.display.InteractiveObject"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_focus>
		<set_focus set="method" line="578">
			<f a="value">
				<c path="openfl.display.InteractiveObject"/>
				<c path="openfl.display.InteractiveObject"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_focus>
		<set_displayState set="method" line="611">
			<f a="value">
				<e path="openfl.display.StageDisplayState"/>
				<e path="openfl.display.StageDisplayState"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_displayState>
		<new public="1" set="method" line="87"><f a="width:height:?color" v="::null">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<enum path="openfl.display.StageAlign" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.display.StageDisplayState" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN/>
		<FULL_SCREEN_INTERACTIVE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.display.StageQuality" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/StageQuality.hx">
		<BEST/>
		<HIGH/>
		<MEDIUM/>
		<LOW/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.display.StageScaleMode" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.display.Tilesheet" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></TILE_TRANS_2x2>
		<TILE_RECT public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></TILE_RECT>
		<TILE_ORIGIN public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></TILE_ORIGIN>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></TILE_BLEND_ADD>
		<TILE_BLEND_MULTIPLY public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></TILE_BLEND_MULTIPLY>
		<TILE_BLEND_SCREEN public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></TILE_BLEND_SCREEN>
		<__defaultPoint line="29" static="1">
			<c path="openfl.geom.Point"/>
			<meta><m n=":noCompletion"/></meta>
		</__defaultPoint>
		<__bitmap>
			<c path="openfl.display.BitmapData"/>
			<meta><m n=":noCompletion"/></meta>
		</__bitmap>
		<__centerPoints>
			<c path="Array"><c path="openfl.geom.Point"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__centerPoints>
		<__tileRects>
			<c path="Array"><c path="openfl.geom.Rectangle"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__tileRects>
		<__tileUVs>
			<c path="Array"><c path="openfl.geom.Rectangle"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__tileUVs>
		<__rectTile>
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__rectTile>
		<__rectUV>
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__rectUV>
		<__point>
			<c path="openfl.geom.Point"/>
			<meta><m n=":noCompletion"/></meta>
		</__point>
		<addTileRect public="1" set="method" line="81">
			<f a="rectangle:?centerPoint" v=":null">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Adds an single tile to this TileSheet
	 * @param	rectangle a rectangle defining the dimensions and positioning of a new tile
	 * @param	centerPoint if set, will act as the translation point of the tile, default: top-left corner
	 * @return an Int representing the id of a single tile rect</haxe_doc>
		</addTileRect>
		<drawTiles public="1" set="method" line="185">
			<f a="graphics:tileData:?smooth:?flags:?count" v="::false:0:-1">
				<c path="openfl.display.Graphics"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws tiles to a give Graphic Object
	 * @param	graphics the "Graphics" object to draw tiles to
	 * @param	tileData an Array<Float>(3) denoting the X position, Y position, and tile to render repsectively
	 * @param	smooth whether to smooth the tile or not
	 * @param	flags
	 * @param	count]]></haxe_doc>
		</drawTiles>
		<getTileCenter public="1" get="inline" set="null" line="191"><f a="index">
	<x path="Int"/>
	<c path="openfl.geom.Point"/>
</f></getTileCenter>
		<getTileRect public="1" get="inline" set="null" line="198"><f a="index">
	<x path="Int"/>
	<c path="openfl.geom.Rectangle"/>
</f></getTileRect>
		<getTileUVs public="1" get="inline" set="null" line="205"><f a="index">
	<x path="Int"/>
	<c path="openfl.geom.Rectangle"/>
</f></getTileUVs>
		<new public="1" set="method" line="53">
			<f a="image">
				<c path="openfl.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>*Creates new TileSheet Object
	 * @param	image a bitmap data to create tiles from</haxe_doc>
		</new>
		<meta><m n=":allow"><e>'???'</e></m></meta>
	</class>
	<enum path="openfl.display.TriangleCulling" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/display/TriangleCulling.hx">
		<NEGATIVE/>
		<NONE/>
		<POSITIVE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.errors.Error" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/errors/Error.hx">
		<DEFAULT_TO_STRING get="inline" set="null" line="10" static="1"><c path="String"/></DEFAULT_TO_STRING>
		<errorID public="1"><x path="Int"/></errorID>
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<getStackTrace public="1" set="method" line="26"><f a=""><c path="String"/></f></getStackTrace>
		<toString public="1" set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="17"><f a="?message:?id" v="'':0">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.errors.ArgumentError" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/errors/ArgumentError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7"><f a="?inMessage" v="''">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.errors.EOFError" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/errors/EOFError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.errors.IOError" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/errors/IOError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7"><f a="?message" v="''">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.errors.IllegalOperationError" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/errors/IllegalOperationError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7"><f a="?inMessage" v="''">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.errors.RangeError" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/errors/RangeError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7"><f a="?inMessage" v="''">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.errors.SecurityError" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/errors/SecurityError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7"><f a="?inMessage" v="''">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.errors.TypeError" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/errors/TypeError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7"><f a="?inMessage" v="''">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.Event" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/Event.hx">
		<ACTIVATE public="1" line="10" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" line="11" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" line="12" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" line="13" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" line="14" static="1"><c path="String"/></CHANGE>
		<CLOSE public="1" line="15" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" line="16" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" line="17" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" line="18" static="1"><c path="String"/></CONTEXT3D_CREATE>
		<DEACTIVATE public="1" line="19" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" line="20" static="1"><c path="String"/></ENTER_FRAME>
		<ID3 public="1" line="21" static="1"><c path="String"/></ID3>
		<INIT public="1" line="22" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" line="23" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" line="24" static="1"><c path="String"/></OPEN>
		<REMOVED public="1" line="25" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" line="26" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" line="27" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" line="28" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" line="29" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" line="30" static="1"><c path="String"/></SELECT>
		<SOUND_COMPLETE public="1" line="31" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" line="32" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" line="33" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" line="34" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<UNLOAD public="1" line="35" static="1"><c path="String"/></UNLOAD>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<currentTarget public="1"><d/></currentTarget>
		<eventPhase public="1" set="null"><e path="openfl.events.EventPhase"/></eventPhase>
		<target public="1"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<__isCancelled>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__isCancelled>
		<__isCancelledNow>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__isCancelledNow>
		<clone public="1" set="method" line="58"><f a=""><c path="openfl.events.Event"/></f></clone>
		<isDefaultPrevented public="1" set="method" line="69"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<stopImmediatePropagation public="1" set="method" line="76"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method" line="84"><f a=""><x path="Void"/></f></stopPropagation>
		<toString public="1" set="method" line="91"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="48"><f a="type:?bubbles:?cancelable" v=":false:false">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.AccelerometerEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/AccelerometerEvent.hx">
		<extends path="openfl.events.Event"/>
		<UPDATE public="1" static="1"><c path="String"/></UPDATE>
		<accelerationX public="1"><x path="Float"/></accelerationX>
		<accelerationY public="1"><x path="Float"/></accelerationY>
		<accelerationZ public="1"><x path="Float"/></accelerationZ>
		<timestamp public="1"><x path="Float"/></timestamp>
		<clone public="1" set="method" line="30" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="37" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="18"><f a="type:?bubbles:?cancelable:?timestamp:?accelerationX:?accelerationY:?accelerationZ" v=":false:false:0:0:0:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.TextEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/TextEvent.hx">
		<extends path="openfl.events.Event"/>
		<LINK public="1" line="7" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" line="8" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<clone public="1" set="method" line="22" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="29" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="13"><f a="type:?bubbles:?cancelable:?text" v=":false:false:''">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.ErrorEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/ErrorEvent.hx">
		<extends path="openfl.events.TextEvent"/>
		<ERROR public="1" line="7" static="1"><c path="String"/></ERROR>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<clone public="1" set="method" line="20" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="27" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12"><f a="type:?bubbles:?cancelable:?text:?id" v=":false:false:'':0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events._EventDispatcher.Listener" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/EventDispatcher.hx" private="1" module="openfl.events.EventDispatcher">
		<callback public="1"><f a="">
	<d/>
	<x path="Void"/>
</f></callback>
		<priority public="1"><x path="Int"/></priority>
		<useCapture public="1"><x path="Bool"/></useCapture>
		<match public="1" set="method" line="196"><f a="callback:useCapture">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Bool"/>
</f></match>
		<new public="1" set="method" line="187"><f a="callback:useCapture:priority">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="openfl.events.EventPhase" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<AT_TARGET/>
		<BUBBLING_PHASE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.events.FocusEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/FocusEvent.hx">
		<extends path="openfl.events.Event"/>
		<FOCUS_IN public="1" line="10" static="1"><c path="String"/></FOCUS_IN>
		<FOCUS_OUT public="1" line="11" static="1"><c path="String"/></FOCUS_OUT>
		<KEY_FOCUS_CHANGE public="1" line="12" static="1"><c path="String"/></KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE public="1" line="13" static="1"><c path="String"/></MOUSE_FOCUS_CHANGE>
		<keyCode public="1"><x path="Int"/></keyCode>
		<relatedObject public="1"><c path="openfl.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<clone public="1" set="method" line="31" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="44" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="20"><f a="type:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode" v=":false:false:null:false:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="openfl.display.InteractiveObject"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.HTTPStatusEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/HTTPStatusEvent.hx">
		<extends path="openfl.events.Event"/>
		<HTTP_RESPONSE_STATUS public="1" line="7" static="1"><c path="String"/></HTTP_RESPONSE_STATUS>
		<HTTP_STATUS public="1" line="8" static="1"><c path="String"/></HTTP_STATUS>
		<responseHeaders public="1"><c path="Array"><d/></c></responseHeaders>
		<responseURL public="1"><c path="String"/></responseURL>
		<status public="1" set="null"><x path="Int"/></status>
		<new public="1" set="method" line="15"><f a="type:?bubbles:?cancelable:?status" v=":false:false:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.IOErrorEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/IOErrorEvent.hx">
		<extends path="openfl.events.ErrorEvent"/>
		<IO_ERROR public="1" line="7" static="1"><c path="String"/></IO_ERROR>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="24" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="10"><f a="type:?bubbles:?cancelable:?text:?id" v=":true:false:'':0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.JoystickEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/JoystickEvent.hx">
		<extends path="openfl.events.Event"/>
		<AXIS_MOVE public="1" get="inline" set="null" line="10" static="1"><c path="String"/></AXIS_MOVE>
		<BALL_MOVE public="1" get="inline" set="null" line="11" static="1"><c path="String"/></BALL_MOVE>
		<BUTTON_DOWN public="1" get="inline" set="null" line="12" static="1"><c path="String"/></BUTTON_DOWN>
		<BUTTON_UP public="1" get="inline" set="null" line="13" static="1"><c path="String"/></BUTTON_UP>
		<HAT_MOVE public="1" get="inline" set="null" line="14" static="1"><c path="String"/></HAT_MOVE>
		<DEVICE_ADDED public="1" get="inline" set="null" line="15" static="1"><c path="String"/></DEVICE_ADDED>
		<DEVICE_REMOVED public="1" get="inline" set="null" line="16" static="1"><c path="String"/></DEVICE_REMOVED>
		<axis public="1"><c path="Array"><x path="Float"/></c></axis>
		<device public="1"><x path="Int"/></device>
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<clone public="1" set="method" line="40" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="47" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="25"><f a="type:?bubbles:?cancelable:?device:?id:?x:?y:?z" v=":false:false:0:0:0:0:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.KeyboardEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/KeyboardEvent.hx">
		<extends path="openfl.events.Event"/>
		<KEY_DOWN public="1" line="10" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" line="11" static="1"><c path="String"/></KEY_UP>
		<altKey public="1"><x path="Bool"/></altKey>
		<charCode public="1"><x path="Int"/></charCode>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<controlKey public="1"><x path="Bool"/></controlKey>
		<keyCode public="1"><x path="Int"/></keyCode>
		<keyLocation public="1"><x path="openfl.ui.KeyLocation"/></keyLocation>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<clone public="1" set="method" line="41" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="48" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="23"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue:?controlKeyValue:?commandKeyValue" v=":false:false:0:0:null:false:false:false:false:false">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="openfl.ui.KeyLocation"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.MouseEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/MouseEvent.hx">
		<extends path="openfl.events.Event"/>
		<CLICK public="1" line="11" static="1"><c path="String"/></CLICK>
		<DOUBLE_CLICK public="1" line="12" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" line="13" static="1"><c path="String"/></MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" line="14" static="1"><c path="String"/></MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" line="15" static="1"><c path="String"/></MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" line="16" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" line="17" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" line="18" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" line="19" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" line="20" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" line="21" static="1"><c path="String"/></MOUSE_WHEEL>
		<RIGHT_CLICK public="1" line="22" static="1"><c path="String"/></RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" line="23" static="1"><c path="String"/></RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" line="24" static="1"><c path="String"/></RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" line="25" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" line="26" static="1"><c path="String"/></ROLL_OVER>
		<__buttonDown static="1">
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__buttonDown>
		<__create public="1" set="method" line="63" static="1">
			<f a="type:local:target">
				<c path="String"/>
				<c path="openfl.geom.Point"/>
				<c path="openfl.display.InteractiveObject"/>
				<c path="openfl.events.MouseEvent"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__create>
		<altKey public="1"><x path="Bool"/></altKey>
		<buttonDown public="1"><x path="Bool"/></buttonDown>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<clickCount public="1"><x path="Int"/></clickCount>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<delta public="1"><x path="Int"/></delta>
		<localX public="1"><x path="Float"/></localX>
		<localY public="1"><x path="Float"/></localY>
		<relatedObject public="1"><c path="openfl.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<stageX public="1"><x path="Float"/></stageX>
		<stageY public="1"><x path="Float"/></stageY>
		<clone public="1" set="method" line="106" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="113" override="1"><f a=""><c path="String"/></f></toString>
		<updateAfterEvent public="1" set="method" line="120"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method" line="44"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta:?commandKey:?clickCount" v=":true:false:0:0:null:false:false:false:false:0:false:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.display.InteractiveObject"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.ProgressEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/ProgressEvent.hx">
		<extends path="openfl.events.Event"/>
		<PROGRESS public="1" line="7" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA public="1" line="8" static="1"><c path="String"/></SOCKET_DATA>
		<bytesLoaded public="1"><x path="Float"/></bytesLoaded>
		<bytesTotal public="1"><x path="Float"/></bytesTotal>
		<clone public="1" set="method" line="24" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="31" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="14"><f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal" v=":false:false:0:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.SampleDataEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/SampleDataEvent.hx">
		<extends path="openfl.events.Event"/>
		<SAMPLE_DATA public="1" line="10" static="1"><c path="String"/></SAMPLE_DATA>
		<data public="1"><t path="openfl.utils.ByteArray"/></data>
		<position public="1"><x path="Float"/></position>
		<clone public="1" set="method" line="27" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="34" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="16"><f a="type:?bubbles:?cancelable" v=":false:false">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.SecurityErrorEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/SecurityErrorEvent.hx">
		<extends path="openfl.events.ErrorEvent"/>
		<SECURITY_ERROR public="1" line="7" static="1"><c path="String"/></SECURITY_ERROR>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="24" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="10"><f a="type:?bubbles:?cancelable:?text:?id" v=":false:false:'':0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.TimerEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/TimerEvent.hx">
		<extends path="openfl.events.Event"/>
		<TIMER public="1" line="7" static="1"><c path="String"/></TIMER>
		<TIMER_COMPLETE public="1" line="8" static="1"><c path="String"/></TIMER_COMPLETE>
		<clone public="1" set="method" line="18" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="25" override="1"><f a=""><c path="String"/></f></toString>
		<updateAfterEvent public="1" set="method" line="32"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method" line="11"><f a="type:?bubbles:?cancelable" v=":false:false">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.events.TouchEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/events/TouchEvent.hx">
		<extends path="openfl.events.Event"/>
		<TOUCH_BEGIN public="1" get="inline" set="null" line="11" static="1"><c path="String"/></TOUCH_BEGIN>
		<TOUCH_END public="1" get="inline" set="null" line="12" static="1"><c path="String"/></TOUCH_END>
		<TOUCH_MOVE public="1" get="inline" set="null" line="13" static="1"><c path="String"/></TOUCH_MOVE>
		<TOUCH_OUT public="1" get="inline" set="null" line="14" static="1"><c path="String"/></TOUCH_OUT>
		<TOUCH_OVER public="1" get="inline" set="null" line="15" static="1"><c path="String"/></TOUCH_OVER>
		<TOUCH_ROLL_OUT public="1" get="inline" set="null" line="16" static="1"><c path="String"/></TOUCH_ROLL_OUT>
		<TOUCH_ROLL_OVER public="1" get="inline" set="null" line="17" static="1"><c path="String"/></TOUCH_ROLL_OVER>
		<TOUCH_TAP public="1" get="inline" set="null" line="18" static="1"><c path="String"/></TOUCH_TAP>
		<__create public="1" set="method" line="69" static="1">
			<f a="type:touch:local:target">
				<c path="String"/>
				<d/>
				<c path="openfl.geom.Point"/>
				<c path="openfl.display.InteractiveObject"/>
				<c path="openfl.events.TouchEvent"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__create>
		<altKey public="1"><x path="Bool"/></altKey>
		<buttonDown public="1"><x path="Bool"/></buttonDown>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<delta public="1"><x path="Int"/></delta>
		<isPrimaryTouchPoint public="1"><x path="Bool"/></isPrimaryTouchPoint>
		<localX public="1"><x path="Float"/></localX>
		<localY public="1"><x path="Float"/></localY>
		<pressure public="1"><x path="Float"/></pressure>
		<relatedObject public="1"><c path="openfl.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<sizeX public="1"><x path="Float"/></sizeX>
		<sizeY public="1"><x path="Float"/></sizeY>
		<stageX public="1"><x path="Float"/></stageX>
		<stageY public="1"><x path="Float"/></stageY>
		<touchPointID public="1"><x path="Int"/></touchPointID>
		<updateAfterEvent public="1" set="method" line="62"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method" line="38"><f a="type:?bubbles:?cancelable:?localX:?localY:?sizeX:?sizeY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta:?commandKey:?clickCount" v=":true:false:0:0:1:1:null:false:false:false:false:0:false:0">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.display.InteractiveObject"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.external.ExternalInterface" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/external/ExternalInterface.hx">
		<available public="1" line="11" static="1"><x path="Bool"/></available>
		<marshallExceptions public="1" line="12" static="1"><x path="Bool"/></marshallExceptions>
		<objectID public="1" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" line="16" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></addCallback>
		<call public="1" set="method" line="29" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5" v=":null:null:null:null:null">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl.filters.BitmapFilter" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/filters/BitmapFilter.hx">
		<clone public="1" set="method" line="22"><f a=""><c path="openfl.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.filters.BitmapFilterQuality" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/filters/BitmapFilterQuality.hx">
		<HIGH public="1" line="6" static="1"><x path="Int"/></HIGH>
		<MEDIUM public="1" line="7" static="1"><x path="Int"/></MEDIUM>
		<LOW public="1" line="8" static="1"><x path="Int"/></LOW>
	</class>
	<class path="openfl.filters.BitmapFilterType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/filters/BitmapFilterType.hx">
		<FULL public="1" line="6" static="1"><c path="String"/></FULL>
		<INNER public="1" line="7" static="1"><c path="String"/></INNER>
		<OUTER public="1" line="8" static="1"><c path="String"/></OUTER>
	</class>
	<class path="openfl.filters.BlurFilter" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/filters/BlurFilter.hx">
		<extends path="openfl.filters.BitmapFilter"/>
		<blurX public="1"><x path="Float"/></blurX>
		<blurY public="1"><x path="Float"/></blurY>
		<quality public="1"><x path="Int"/></quality>
		<clone public="1" set="method" line="23" override="1"><f a=""><c path="openfl.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method" line="12"><f a="?blurX:?blurY:?quality" v="4:4:1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.filters.ColorMatrixFilter" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/filters/ColorMatrixFilter.hx">
		<extends path="openfl.filters.BitmapFilter"/>
		<matrix public="1"><c path="Array"><x path="Float"/></c></matrix>
		<clone public="1" set="method" line="34" override="1"><f a=""><c path="openfl.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method" line="19"><f a="?matrix" v="null">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.filters.DropShadowFilter" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/filters/DropShadowFilter.hx">
		<extends path="openfl.filters.BitmapFilter"/>
		<alpha public="1"><x path="Float"/></alpha>
		<angle public="1"><x path="Float"/></angle>
		<blurX public="1"><x path="Float"/></blurX>
		<blurY public="1"><x path="Float"/></blurY>
		<color public="1"><x path="Int"/></color>
		<distance public="1"><x path="Float"/></distance>
		<hideObject public="1"><x path="Bool"/></hideObject>
		<inner public="1"><x path="Bool"/></inner>
		<knockout public="1"><x path="Bool"/></knockout>
		<quality public="1"><x path="Int"/></quality>
		<strength public="1"><x path="Float"/></strength>
		<clone public="1" set="method" line="39" override="1"><f a=""><c path="openfl.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method" line="20"><f a="?distance:?angle:?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout:?hideObject" v="4:45:0:1:4:4:1:1:false:false:false">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.filters.GlowFilter" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/filters/GlowFilter.hx">
		<extends path="openfl.filters.BitmapFilter"/>
		<alpha public="1"><x path="Float"/></alpha>
		<blurX public="1"><x path="Float"/></blurX>
		<blurY public="1"><x path="Float"/></blurY>
		<color public="1"><x path="Int"/></color>
		<inner public="1"><x path="Bool"/></inner>
		<knockout public="1"><x path="Bool"/></knockout>
		<quality public="1"><x path="Int"/></quality>
		<strength public="1"><x path="Float"/></strength>
		<clone public="1" set="method" line="33" override="1"><f a=""><c path="openfl.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method" line="17"><f a="?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout" v="0:1:6:6:2:1:false:false">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.geom.ColorTransform" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/geom/ColorTransform.hx">
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<color public="1" get="accessor" set="accessor"><x path="Int"/></color>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<redOffset public="1"><x path="Float"/></redOffset>
		<concat public="1" set="method" line="36"><f a="second">
	<c path="openfl.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<get_color set="method" line="53">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_color>
		<set_color set="method" line="60">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<__toLimeColorMatrix set="method" line="75">
			<f a=""><x path="lime.math.ColorMatrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__toLimeColorMatrix>
		<new public="1" set="method" line="22"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset" v="1:1:1:1:0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.geom.Matrix3D" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/geom/Matrix3D.hx">
		<create2D public="1" set="method" line="239" static="1"><f a="x:y:?scale:?rotation" v="::1:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Matrix3D"/>
</f></create2D>
		<createABCD public="1" set="method" line="255" static="1"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Matrix3D"/>
</f></createABCD>
		<createOrtho public="1" set="method" line="267" static="1"><f a="x0:x1:y0:y1:zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Matrix3D"/>
</f></createOrtho>
		<interpolate public="1" set="method" line="454" static="1"><f a="thisMat:toMat:percent">
	<c path="openfl.geom.Matrix3D"/>
	<c path="openfl.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="openfl.geom.Matrix3D"/>
</f></interpolate>
		<getAxisRotation set="method" line="785" static="1"><f a="x:y:z:degrees">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Matrix3D"/>
</f></getAxisRotation>
		<determinant public="1" get="accessor" set="null"><x path="Float"/></determinant>
		<position public="1" get="accessor" set="accessor"><c path="openfl.geom.Vector3D"/></position>
		<rawData public="1"><x path="openfl.Vector"><x path="Float"/></x></rawData>
		<append public="1" get="inline" set="null" line="33"><f a="lhs">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<appendRotation public="1" get="inline" set="null" line="67"><f a="degrees:axis:?pivotPoint" v="::null">
	<x path="Float"/>
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<appendScale public="1" get="inline" set="null" line="83"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendTranslation public="1" get="inline" set="null" line="90"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<clone public="1" get="inline" set="null" line="99"><f a=""><c path="openfl.geom.Matrix3D"/></f></clone>
		<copyColumnFrom public="1" set="method" line="106"><f a="column:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1" set="method" line="137"><f a="column:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1" set="method" line="168"><f a="other">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Void"/>
</f></copyFrom>
		<copyRawDataFrom public="1" set="method" line="174"><f a="vector:?index:?transpose" v=":0:false">
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyRawDataFrom>
		<copyRawDataTo public="1" set="method" line="189"><f a="vector:?index:?transpose" v=":0:false">
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyRawDataTo>
		<copyRowFrom public="1" set="method" line="204"><f a="row:vector3D">
	<x path="UInt"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1" set="method" line="283"><f a="row:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowTo>
		<copyToMatrix3D public="1" set="method" line="318"><f a="other">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Void"/>
</f></copyToMatrix3D>
		<decompose public="1" set="method" line="328">
			<f a="?orientationStyle" v="null">
				<e path="openfl.geom.Orientation3D"/>
				<x path="openfl.Vector"><c path="openfl.geom.Vector3D"/></x>
			</f>
			<haxe_doc>* Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector3D objects.</haxe_doc>
		</decompose>
		<deltaTransformVector public="1" set="method" line="434"><f a="v">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" set="method" line="447"><f a=""><x path="Void"/></f></identity>
		<interpolateTo public="1" get="inline" set="null" line="469"><f a="toMat:percent">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<invert public="1" get="inline" set="null" line="480"><f a=""><x path="Bool"/></f></invert>
		<pointAt public="1" set="method" line="518"><f a="pos:?at:?up" v=":null:null">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<prepend public="1" get="inline" set="null" line="585"><f a="rhs">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<prependRotation public="1" get="inline" set="null" line="619"><f a="degrees:axis:?pivotPoint" v="::null">
	<x path="Float"/>
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prependScale public="1" get="inline" set="null" line="635"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependTranslation public="1" get="inline" set="null" line="642"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method" line="651"><f a="components:?orientationStyle" v=":null">
	<x path="openfl.Vector"><c path="openfl.geom.Vector3D"/></x>
	<e path="openfl.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<transformVector public="1" get="inline" set="null" line="735"><f a="v">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method" line="748"><f a="vin:vout">
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></transformVectors>
		<transpose public="1" get="inline" set="null" line="767"><f a=""><x path="Void"/></f></transpose>
		<get_determinant public="1" get="inline" set="null" line="824">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_determinant>
		<get_position public="1" get="inline" set="null" line="836">
			<f a=""><c path="openfl.geom.Vector3D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_position>
		<set_position public="1" get="inline" set="null" line="843">
			<f a="val">
				<c path="openfl.geom.Vector3D"/>
				<c path="openfl.geom.Vector3D"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_position>
		<new public="1" set="method" line="18"><f a="?v" v="null">
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="openfl.geom.Orientation3D" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/geom/Orientation3D.hx">
		<AXIS_ANGLE/>
		<EULER_ANGLES/>
		<QUATERNION/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.geom.Transform" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/geom/Transform.hx">
		<colorTransform public="1"><c path="openfl.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1"><c path="openfl.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1"><c path="openfl.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1" get="accessor" set="accessor"><c path="openfl.geom.Matrix"/></matrix>
		<pixelBounds public="1"><c path="openfl.geom.Rectangle"/></pixelBounds>
		<__displayObject>
			<c path="openfl.display.DisplayObject"/>
			<meta><m n=":noCompletion"/></meta>
		</__displayObject>
		<__matrix>
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":noCompletion"/></meta>
		</__matrix>
		<get_matrix set="method" line="40">
			<f a=""><c path="openfl.geom.Matrix"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_matrix>
		<set_matrix set="method" line="58">
			<f a="value">
				<c path="openfl.geom.Matrix"/>
				<c path="openfl.geom.Matrix"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_matrix>
		<new public="1" set="method" line="20"><f a="displayObject">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.geom.Vector3D" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/geom/Vector3D.hx">
		<X_AXIS public="1" get="accessor" set="null" static="1"><c path="openfl.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" get="accessor" set="null" static="1"><c path="openfl.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" get="accessor" set="null" static="1"><c path="openfl.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" get="inline" set="null" line="36" static="1"><f a="a:b">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" get="inline" set="null" line="80" static="1"><f a="pt1:pt2">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<get_X_AXIS get="inline" set="null" line="209" static="1">
			<f a=""><c path="openfl.geom.Vector3D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_X_AXIS>
		<get_Y_AXIS get="inline" set="null" line="216" static="1">
			<f a=""><c path="openfl.geom.Vector3D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_Y_AXIS>
		<get_Z_AXIS get="inline" set="null" line="223" static="1">
			<f a=""><c path="openfl.geom.Vector3D"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_Z_AXIS>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<lengthSquared public="1" get="accessor" set="null"><x path="Float"/></lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" get="inline" set="null" line="29"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></add>
		<clone public="1" get="inline" set="null" line="48"><f a=""><c path="openfl.geom.Vector3D"/></f></clone>
		<copyFrom public="1" get="inline" set="null" line="55"><f a="sourceVector3D">
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyFrom>
		<crossProduct public="1" get="inline" set="null" line="64"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" get="inline" set="null" line="71"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" get="inline" set="null" line="91"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" get="inline" set="null" line="98"><f a="toCompare:?allFour" v=":false">
	<c path="openfl.geom.Vector3D"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<incrementBy public="1" get="inline" set="null" line="105"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" get="inline" set="null" line="114"><f a="toCompare:tolerance:?allFour" v="::false">
	<c path="openfl.geom.Vector3D"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<negate public="1" get="inline" set="null" line="121"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" get="inline" set="null" line="130"><f a=""><x path="Float"/></f></normalize>
		<project public="1" get="inline" set="null" line="147"><f a=""><x path="Void"/></f></project>
		<scaleBy public="1" get="inline" set="null" line="156"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<setTo public="1" get="inline" set="null" line="165"><f a="xa:ya:za">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<subtract public="1" get="inline" set="null" line="174"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></subtract>
		<toString public="1" get="inline" set="null" line="181"><f a=""><c path="String"/></f></toString>
		<get_length get="inline" set="null" line="195">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_length>
		<get_lengthSquared get="inline" set="null" line="202">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lengthSquared>
		<new public="1" set="method" line="19"><f a="?x:?y:?z:?w" v="0:0:0:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="openfl.gl.GL" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GL.hx"><c path="lime.graphics.opengl.GL"/></typedef>
	<typedef path="openfl.gl.GLActiveInfo" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLActiveInfo.hx"><t path="lime.graphics.opengl.GLActiveInfo"/></typedef>
	<typedef path="openfl.gl.GLBuffer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLBuffer.hx"><c path="lime.graphics.opengl.GLBuffer"/></typedef>
	<typedef path="openfl.gl.GLContextAttributes" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLContextAttributes.hx"><t path="lime.graphics.opengl.GLContextAttributes"/></typedef>
	<typedef path="openfl.gl.GLFramebuffer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLFramebuffer.hx"><c path="lime.graphics.opengl.GLFramebuffer"/></typedef>
	<typedef path="openfl.gl.GLObject" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLObject.hx"><c path="lime.graphics.opengl.GLObject"/></typedef>
	<typedef path="openfl.gl.GLProgram" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLProgram.hx"><c path="lime.graphics.opengl.GLProgram"/></typedef>
	<typedef path="openfl.gl.GLRenderbuffer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLRenderbuffer.hx"><c path="lime.graphics.opengl.GLRenderbuffer"/></typedef>
	<typedef path="openfl.gl.GLShader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLShader.hx"><c path="lime.graphics.opengl.GLShader"/></typedef>
	<typedef path="openfl.gl.GLTexture" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLTexture.hx"><c path="lime.graphics.opengl.GLTexture"/></typedef>
	<typedef path="openfl.gl.GLUniformLocation" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/gl/GLUniformLocation.hx"><t path="lime.graphics.opengl.GLUniformLocation"/></typedef>
	<class path="openfl.media.ID3Info" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/media/ID3Info.hx">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.media.Sound" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/media/Sound.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<fromAudioBuffer public="1" set="method" line="76" static="1"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="openfl.media.Sound"/>
</f></fromAudioBuffer>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<id3 public="1" get="accessor" set="null"><c path="openfl.media.ID3Info"/></id3>
		<isBuffering public="1" set="null"><x path="Bool"/></isBuffering>
		<length public="1" set="null"><x path="Float"/></length>
		<url public="1" set="null"><c path="String"/></url>
		<__buffer>
			<c path="lime.audio.AudioBuffer"/>
			<meta><m n=":noCompletion"/></meta>
		</__buffer>
		<close public="1" set="method" line="57"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="85"><f a="stream:?context" v=":null">
	<c path="openfl.net.URLRequest"/>
	<c path="openfl.media.SoundLoaderContext"/>
	<x path="Void"/>
</f></load>
		<loadCompressedDataFromByteArray public="1" set="method" line="109"><f a="bytes:bytesLength:?forcePlayAsMusic" v="::false">
	<t path="openfl.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method" line="122"><f a="bytes:samples:?format:?stereo:?sampleRate" v="::null:true:44100">
	<t path="openfl.utils.ByteArray"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Float"/>
	<x path="Void"/>
</f></loadPCMFromByteArray>
		<play public="1" set="method" line="135"><f a="?startTime:?loops:?sndTransform" v="0.0f:0:null">
	<x path="Float"/>
	<x path="Int"/>
	<c path="openfl.media.SoundTransform"/>
	<c path="openfl.media.SoundChannel"/>
</f></play>
		<get_id3 set="method" line="176">
			<f a=""><c path="openfl.media.ID3Info"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_id3>
		<AudioBuffer_onURLLoad set="method" line="190">
			<f a="buffer">
				<c path="lime.audio.AudioBuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</AudioBuffer_onURLLoad>
		<new public="1" set="method" line="37"><f a="?stream:?context" v="null:null">
	<c path="openfl.net.URLRequest"/>
	<c path="openfl.media.SoundLoaderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":autoBuild"><e>'???'</e></m></meta>
	</class>
	<class path="openfl.media.SoundChannel" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/media/SoundChannel.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<leftPeak public="1" set="null"><x path="Float"/></leftPeak>
		<position public="1" get="accessor" set="accessor"><x path="Float"/></position>
		<rightPeak public="1" set="null"><x path="Float"/></rightPeak>
		<soundTransform public="1" get="accessor" set="accessor"><c path="openfl.media.SoundTransform"/></soundTransform>
		<__source>
			<c path="lime.audio.AudioSource"/>
			<meta><m n=":noCompletion"/></meta>
		</__source>
		<stop public="1" set="method" line="41"><f a=""><x path="Void"/></f></stop>
		<get_position set="method" line="69">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_position>
		<set_position set="method" line="80">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_position>
		<get_soundTransform set="method" line="93">
			<f a=""><c path="openfl.media.SoundTransform"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_soundTransform>
		<set_soundTransform set="method" line="106">
			<f a="value">
				<c path="openfl.media.SoundTransform"/>
				<c path="openfl.media.SoundTransform"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_soundTransform>
		<source_onComplete set="method" line="140">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</source_onComplete>
		<new set="method" line="25"><f a="source">
	<c path="lime.audio.AudioSource"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.media.SoundLoaderContext" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/media/SoundLoaderContext.hx">
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<new public="1" set="method" line="11"><f a="?bufferTime:?checkPolicyFile" v="0:false">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.media.SoundTransform" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/media/SoundTransform.hx">
		<leftToLeft public="1"><x path="Float"/></leftToLeft>
		<leftToRight public="1"><x path="Float"/></leftToRight>
		<pan public="1"><x path="Float"/></pan>
		<rightToLeft public="1"><x path="Float"/></rightToLeft>
		<rightToRight public="1"><x path="Float"/></rightToRight>
		<volume public="1"><x path="Float"/></volume>
		<clone public="1" set="method" line="27"><f a=""><c path="openfl.media.SoundTransform"/></f></clone>
		<new public="1" set="method" line="15"><f a="?vol:?panning" v="1:0">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.net.SharedObject" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/SharedObject.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<getLocal public="1" set="method" line="74" static="1"><f a="name:?localPath:?secure" v=":null:false">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<c path="openfl.net.SharedObject"/>
</f></getLocal>
		<resolveClass set="method" line="129" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</resolveClass>
		<data public="1" set="null"><d/></data>
		<size public="1" get="accessor" set="null"><x path="Int"/></size>
		<__key>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__key>
		<clear public="1" set="method" line="34"><f a=""><x path="Void"/></f></clear>
		<flush public="1" set="method" line="51"><f a="?minDiskSpace" v="0">
	<x path="Int"/>
	<e path="openfl.net.SharedObjectFlushStatus"/>
</f></flush>
		<setProperty public="1" set="method" line="142"><f a="propertyName:?value" v=":null">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></setProperty>
		<get_size set="method" line="159">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_size>
		<new set="method" line="27"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="openfl.net.SharedObjectFlushStatus" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/SharedObjectFlushStatus.hx">
		<FLUSHED/>
		<PENDING/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="openfl.net.Socket" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/Socket.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<_stamp><x path="Float"/></_stamp>
		<_buf><c path="haxe.io.Bytes"/></_buf>
		<_socket><c path="sys.net.Socket"/></_socket>
		<_connected><x path="Bool"/></_connected>
		<_host><c path="String"/></_host>
		<_port><x path="Int"/></_port>
		<_inputBuffer><t path="openfl.utils.ByteArray"/></_inputBuffer>
		<_input><t path="openfl.utils.ByteArray"/></_input>
		<_output><t path="openfl.utils.ByteArray"/></_output>
		<bytesAvailable public="1" get="accessor" set="null"><x path="Int"/></bytesAvailable>
		<bytesPending public="1" get="accessor" set="null"><x path="Int"/></bytesPending>
		<timeout public="1"><x path="Int"/></timeout>
		<objectEncoding public="1"><x path="Int"/></objectEncoding>
		<endian public="1" get="accessor" set="accessor">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
		</endian>
		<connected public="1" get="accessor" set="null"><x path="Bool"/></connected>
		<get_connected set="method" line="49">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_connected>
		<get_endian set="method" line="53">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_endian>
		<set_endian set="method" line="57">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_endian>
		<get_bytesAvailable set="method" line="65">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bytesAvailable>
		<get_bytesPending set="method" line="69">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bytesPending>
		<connect public="1" set="method" line="82"><f a="?host:?port" v="null:0">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
		<onFrame set="method" line="136">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onFrame>
		<cleanSocket set="method" line="218">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</cleanSocket>
		<close public="1" set="method" line="227"><f a=""><x path="Void"/></f></close>
		<readBoolean public="1" set="method" line="237"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method" line="242"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="247"><f a="bytes:?offset:?length" v=":0:0">
	<t path="openfl.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method" line="252"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="257"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method" line="262"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method" line="267"><f a="length:charSet">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readShort public="1" set="method" line="273"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" set="method" line="278"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method" line="283"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method" line="288"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method" line="293"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method" line="298"><f a="length">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<writeBoolean public="1" set="method" line="306"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method" line="311"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="316"><f a="bytes:?offset:?length" v=":0:0">
	<t path="openfl.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method" line="321"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method" line="326"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method" line="331"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method" line="336"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeShort public="1" set="method" line="341"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method" line="346"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method" line="351"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method" line="356"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<flush public="1" set="method" line="388"><f a=""><x path="Void"/></f></flush>
		<new public="1" set="method" line="73"><f a="?host:?port" v="null:0">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.net.URLLoader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/URLLoader.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<bytesLoaded public="1"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1"><x path="Int"/></bytesTotal>
		<data public="1"><d/></data>
		<dataFormat public="1" set="accessor"><e path="openfl.net.URLLoaderDataFormat"/></dataFormat>
		<close public="1" set="method" line="47"><f a=""><x path="Void"/></f></close>
		<getData set="dynamic" line="54"><f a=""><d/></f></getData>
		<load public="1" set="method" line="61"><f a="request">
	<c path="openfl.net.URLRequest"/>
	<x path="Void"/>
</f></load>
		<onData set="method" line="242">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onData>
		<onError set="method" line="262">
			<f a="msg">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onError>
		<onOpen set="method" line="272">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</onOpen>
		<onProgress set="method" line="281">
			<f a="event">
				<t path="openfl.net.XMLHttpRequestProgressEvent"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onProgress>
		<onSecurityError set="method" line="292">
			<f a="msg">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onSecurityError>
		<onStatus set="method" line="302">
			<f a="status">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</onStatus>
		<set_dataFormat set="method" line="318">
			<f a="inputVal">
				<e path="openfl.net.URLLoaderDataFormat"/>
				<e path="openfl.net.URLLoaderDataFormat"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_dataFormat>
		<new public="1" set="method" line="30"><f a="?request" v="null">
	<c path="openfl.net.URLRequest"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="openfl.net.XMLHttpRequestProgressEvent" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/URLLoader.hx" module="openfl.net.URLLoader"><d/></typedef>
	<enum path="openfl.net.URLLoaderDataFormat" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/URLLoaderDataFormat.hx">
		<BINARY/>
		<TEXT/>
		<VARIABLES/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.net.URLRequest" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/URLRequest.hx">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="openfl.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<userAgent public="1"><c path="String"/></userAgent>
		<formatRequestHeaders public="1" set="method" line="33"><f a=""><c path="Array"><c path="openfl.net.URLRequestHeader"/></c></f></formatRequestHeaders>
		<new public="1" set="method" line="18"><f a="?inURL" v="null">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.net.URLRequestHeader" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/URLRequestHeader.hx">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method" line="11"><f a="?name:?value" v="'':''">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.net.URLRequestMethod" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/URLRequestMethod.hx">
		<DELETE public="1" line="6" static="1"><c path="String"/></DELETE>
		<GET public="1" line="7" static="1"><c path="String"/></GET>
		<HEAD public="1" line="8" static="1"><c path="String"/></HEAD>
		<OPTIONS public="1" line="9" static="1"><c path="String"/></OPTIONS>
		<POST public="1" line="10" static="1"><c path="String"/></POST>
		<PUT public="1" line="11" static="1"><c path="String"/></PUT>
	</class>
	<class path="openfl.net.URLVariables" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/net/URLVariables.hx">
		<decode public="1" set="method" line="18"><f a="inVars">
	<c path="String"/>
	<x path="Void"/>
</f></decode>
		<toString public="1" set="method" line="49"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="7"><f a="?inEncoded" v="null">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="openfl.sensors.Accelerometer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/sensors/Accelerometer.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<isSupported public="1" get="accessor" set="null" static="1"><x path="Bool"/></isSupported>
		<defaultInterval line="25" static="1"><x path="Int"/></defaultInterval>
		<get_isSupported set="method" line="101" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_isSupported>
		<muted public="1" set="accessor"><x path="Bool"/></muted>
		<_interval><x path="Int"/></_interval>
		<timer><c path="haxe.Timer"/></timer>
		<addEventListener public="1" set="method" line="39" override="1"><f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<setRequestedUpdateInterval public="1" set="method" line="47"><f a="interval">
	<x path="Int"/>
	<x path="Void"/>
</f></setRequestedUpdateInterval>
		<update set="method" line="78"><f a=""><x path="Void"/></f></update>
		<set_muted set="method" line="110">
			<f a="inVal">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_muted>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.system.Capabilities" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/system/Capabilities.hx">
		<hasAccessibility public="1" line="15" static="1"><x path="Bool"/></hasAccessibility>
		<pixelAspectRatio public="1" get="accessor" set="null" static="1"><x path="Float"/></pixelAspectRatio>
		<screenDPI public="1" get="accessor" set="null" static="1"><x path="Float"/></screenDPI>
		<screenResolutionX public="1" get="accessor" set="null" static="1"><x path="Float"/></screenResolutionX>
		<screenResolutionY public="1" get="accessor" set="null" static="1"><x path="Float"/></screenResolutionY>
		<language public="1" get="accessor" set="null" static="1"><c path="String"/></language>
		<get_pixelAspectRatio set="method" line="30" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pixelAspectRatio>
		<get_screenDPI set="method" line="31" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_screenDPI>
		<get_screenResolutionX set="method" line="60" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_screenResolutionX>
		<get_screenResolutionY set="method" line="75" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_screenResolutionY>
		<get_language set="method" line="90" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_language>
	</class>
	<class path="openfl.system.LoaderContext" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/system/LoaderContext.hx">
		<allowCodeImport public="1"><x path="Bool"/></allowCodeImport>
		<allowLoadBytesCodeExecution public="1"><x path="Bool"/></allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="openfl.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<securityDomain public="1"><c path="openfl.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method" line="14"><f a="?checkPolicyFile:?applicationDomain:?securityDomain" v="false:null:null">
	<x path="Bool"/>
	<c path="openfl.system.ApplicationDomain"/>
	<c path="openfl.system.SecurityDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl.system.SecurityDomain" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/system/SecurityDomain.hx">
		<currentDomain public="1" set="null" line="7" static="1"><c path="openfl.system.SecurityDomain"/></currentDomain>
		<new set="method" line="10"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.system.System" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/system/System.hx">
		<totalMemory public="1" get="accessor" set="null" static="1"><x path="Int"/></totalMemory>
		<useCodePage public="1" line="8" static="1"><x path="Bool"/></useCodePage>
		<vmVersion public="1" get="accessor" set="null" static="1"><c path="String"/></vmVersion>
		<exit public="1" set="method" line="12" static="1"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></exit>
		<gc public="1" set="method" line="19" static="1"><f a=""><x path="Void"/></f></gc>
		<pause public="1" set="method" line="26" static="1"><f a=""><x path="Void"/></f></pause>
		<resume public="1" set="method" line="33" static="1"><f a=""><x path="Void"/></f></resume>
		<setClipboard public="1" set="method" line="40" static="1"><f a="string">
	<c path="String"/>
	<x path="Void"/>
</f></setClipboard>
		<get_totalMemory set="method" line="54" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_totalMemory>
		<get_vmVersion set="method" line="61" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_vmVersion>
	</class>
	<enum path="openfl.text.AntiAliasType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/AntiAliasType.hx">
		<ADVANCED/>
		<NORMAL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.text.Font" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/Font.hx">
		<extends path="lime.graphics.Font"/>
		<__registeredFonts line="14" static="1">
			<c path="Array"><c path="openfl.text.Font"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__registeredFonts>
		<enumerateFonts public="1" set="method" line="24" static="1"><f a="?enumerateDeviceFonts" v="false">
	<x path="Bool"/>
	<c path="Array"><c path="openfl.text.Font"/></c>
</f></enumerateFonts>
		<fromBytes public="1" set="method" line="31" static="1"><f a="bytes">
	<t path="openfl.utils.ByteArray"/>
	<c path="openfl.text.Font"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="40" static="1"><f a="path">
	<c path="String"/>
	<c path="openfl.text.Font"/>
</f></fromFile>
		<registerFont public="1" set="method" line="49" static="1"><f a="font">
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></registerFont>
		<fontStyle public="1"><e path="openfl.text.FontStyle"/></fontStyle>
		<fontType public="1"><e path="openfl.text.FontType"/></fontType>
		<new public="1" set="method" line="17"><f a="?name" v="null">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="openfl.text.FontStyle" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.text.FontType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/FontType.hx">
		<DEVICE/>
		<EMBEDDED/>
		<EMBEDDED_CFF/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.text.GridFitType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/GridFitType.hx">
		<NONE/>
		<PIXEL/>
		<SUBPIXEL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.text.TextFormatRange" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/TextField.hx" module="openfl.text.TextField">
		<end public="1"><x path="Int"/></end>
		<format public="1"><c path="openfl.text.TextFormat"/></format>
		<start public="1"><x path="Int"/></start>
		<new public="1" set="method" line="792"><f a="format:start:end">
	<c path="openfl.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<enum path="openfl.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/TextFieldAutoSize.hx">
		<CENTER/>
		<LEFT/>
		<NONE/>
		<RIGHT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.text.TextFieldType" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/TextFieldType.hx">
		<DYNAMIC/>
		<INPUT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.text.TextFormat" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/TextFormat.hx">
		<align public="1"><e path="openfl.text.TextFormatAlign"/></align>
		<blockIndent public="1"><t path="Null"><x path="Float"/></t></blockIndent>
		<bold public="1"><t path="Null"><x path="Bool"/></t></bold>
		<bullet public="1"><t path="Null"><x path="Bool"/></t></bullet>
		<color public="1"><t path="Null"><x path="Int"/></t></color>
		<font public="1"><c path="String"/></font>
		<indent public="1"><t path="Null"><x path="Float"/></t></indent>
		<italic public="1"><t path="Null"><x path="Bool"/></t></italic>
		<kerning public="1"><t path="Null"><x path="Bool"/></t></kerning>
		<leading public="1"><t path="Null"><x path="Float"/></t></leading>
		<leftMargin public="1"><t path="Null"><x path="Float"/></t></leftMargin>
		<letterSpacing public="1"><t path="Null"><x path="Float"/></t></letterSpacing>
		<rightMargin public="1"><t path="Null"><x path="Float"/></t></rightMargin>
		<size public="1"><t path="Null"><x path="Float"/></t></size>
		<tabStops public="1"><c path="Array"><x path="Int"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><t path="Null"><x path="Bool"/></t></underline>
		<url public="1"><c path="String"/></url>
		<clone public="1" set="method" line="46"><f a=""><c path="openfl.text.TextFormat"/></f></clone>
		<__merge set="method" line="67">
			<f a="format">
				<c path="openfl.text.TextFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__merge>
		<new public="1" set="method" line="27"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading" v="null:null:null:null:null:null:null:null:null:null:null:null:null">
	<c path="String"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="openfl.text.TextFormatAlign"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="openfl.text.TextFormatAlign" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/TextFormatAlign.hx">
		<LEFT/>
		<RIGHT/>
		<JUSTIFY/>
		<CENTER/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="openfl.text.TextLineMetrics" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/text/TextLineMetrics.hx">
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<height public="1"><x path="Float"/></height>
		<leading public="1"><x path="Float"/></leading>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method" line="15"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="openfl.ui.KeyLocation" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/ui/KeyLocation.hx">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.ui._KeyLocation.KeyLocation_Impl_" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/ui/KeyLocation.hx" private="1" module="openfl.ui.KeyLocation">
	<STANDARD public="1" get="inline" set="null" line="8" static="1">
		<x path="openfl.ui.KeyLocation"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STANDARD>
	<LEFT public="1" get="inline" set="null" line="9" static="1">
		<x path="openfl.ui.KeyLocation"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<RIGHT public="1" get="inline" set="null" line="10" static="1">
		<x path="openfl.ui.KeyLocation"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<NUM_PAD public="1" get="inline" set="null" line="11" static="1">
		<x path="openfl.ui.KeyLocation"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUM_PAD>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="openfl.ui._KeyLocation.KeyLocation_Impl_" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/ui/KeyLocation.hx" private="1" module="openfl.ui.KeyLocation">
		<STANDARD public="1" get="inline" set="null" line="8" static="1">
			<x path="openfl.ui.KeyLocation"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STANDARD>
		<LEFT public="1" get="inline" set="null" line="9" static="1">
			<x path="openfl.ui.KeyLocation"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" line="10" static="1">
			<x path="openfl.ui.KeyLocation"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<NUM_PAD public="1" get="inline" set="null" line="11" static="1">
			<x path="openfl.ui.KeyLocation"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUM_PAD>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="openfl.ui.Keyboard" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/ui/Keyboard.hx">
		<NUMBER_0 public="1" get="inline" set="null" line="7" static="1"><x path="Int"/></NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" line="8" static="1"><x path="Int"/></NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" line="16" static="1"><x path="Int"/></NUMBER_9>
		<A public="1" get="inline" set="null" line="17" static="1"><x path="Int"/></A>
		<B public="1" get="inline" set="null" line="18" static="1"><x path="Int"/></B>
		<C public="1" get="inline" set="null" line="19" static="1"><x path="Int"/></C>
		<D public="1" get="inline" set="null" line="20" static="1"><x path="Int"/></D>
		<E public="1" get="inline" set="null" line="21" static="1"><x path="Int"/></E>
		<F public="1" get="inline" set="null" line="22" static="1"><x path="Int"/></F>
		<G public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></G>
		<H public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></H>
		<I public="1" get="inline" set="null" line="25" static="1"><x path="Int"/></I>
		<J public="1" get="inline" set="null" line="26" static="1"><x path="Int"/></J>
		<K public="1" get="inline" set="null" line="27" static="1"><x path="Int"/></K>
		<L public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></L>
		<M public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></M>
		<N public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></N>
		<O public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></O>
		<P public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></P>
		<Q public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></Q>
		<R public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></R>
		<S public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></S>
		<T public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></T>
		<U public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></U>
		<V public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></V>
		<W public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></W>
		<X public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></X>
		<Y public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></Y>
		<Z public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></Z>
		<NUMPAD_0 public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></NUMPAD_0>
		<NUMPAD_1 public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" line="47" static="1"><x path="Int"/></NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" line="48" static="1"><x path="Int"/></NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" line="49" static="1"><x path="Int"/></NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" line="50" static="1"><x path="Int"/></NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" line="51" static="1"><x path="Int"/></NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" line="52" static="1"><x path="Int"/></NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" line="53" static="1"><x path="Int"/></NUMPAD_9>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" line="54" static="1"><x path="Int"/></NUMPAD_MULTIPLY>
		<NUMPAD_ADD public="1" get="inline" set="null" line="55" static="1"><x path="Int"/></NUMPAD_ADD>
		<NUMPAD_ENTER public="1" get="inline" set="null" line="56" static="1"><x path="Int"/></NUMPAD_ENTER>
		<NUMPAD_SUBTRACT public="1" get="inline" set="null" line="57" static="1"><x path="Int"/></NUMPAD_SUBTRACT>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" line="58" static="1"><x path="Int"/></NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" line="59" static="1"><x path="Int"/></NUMPAD_DIVIDE>
		<F1 public="1" get="inline" set="null" line="61" static="1"><x path="Int"/></F1>
		<F2 public="1" get="inline" set="null" line="62" static="1"><x path="Int"/></F2>
		<F3 public="1" get="inline" set="null" line="63" static="1"><x path="Int"/></F3>
		<F4 public="1" get="inline" set="null" line="64" static="1"><x path="Int"/></F4>
		<F5 public="1" get="inline" set="null" line="65" static="1"><x path="Int"/></F5>
		<F6 public="1" get="inline" set="null" line="66" static="1"><x path="Int"/></F6>
		<F7 public="1" get="inline" set="null" line="67" static="1"><x path="Int"/></F7>
		<F8 public="1" get="inline" set="null" line="68" static="1"><x path="Int"/></F8>
		<F9 public="1" get="inline" set="null" line="69" static="1"><x path="Int"/></F9>
		<F10 public="1" get="inline" set="null" line="70" static="1"><x path="Int"/></F10>
		<F11 public="1" get="inline" set="null" line="71" static="1"><x path="Int"/></F11>
		<F12 public="1" get="inline" set="null" line="72" static="1"><x path="Int"/></F12>
		<F13 public="1" get="inline" set="null" line="73" static="1"><x path="Int"/></F13>
		<F14 public="1" get="inline" set="null" line="74" static="1"><x path="Int"/></F14>
		<F15 public="1" get="inline" set="null" line="75" static="1"><x path="Int"/></F15>
		<BACKSPACE public="1" get="inline" set="null" line="77" static="1"><x path="Int"/></BACKSPACE>
		<TAB public="1" get="inline" set="null" line="78" static="1"><x path="Int"/></TAB>
		<ALTERNATE public="1" get="inline" set="null" line="79" static="1"><x path="Int"/></ALTERNATE>
		<ENTER public="1" get="inline" set="null" line="80" static="1"><x path="Int"/></ENTER>
		<COMMAND public="1" get="inline" set="null" line="81" static="1"><x path="Int"/></COMMAND>
		<SHIFT public="1" get="inline" set="null" line="82" static="1"><x path="Int"/></SHIFT>
		<CONTROL public="1" get="inline" set="null" line="83" static="1"><x path="Int"/></CONTROL>
		<CAPS_LOCK public="1" get="inline" set="null" line="84" static="1"><x path="Int"/></CAPS_LOCK>
		<NUMPAD public="1" get="inline" set="null" line="85" static="1"><x path="Int"/></NUMPAD>
		<ESCAPE public="1" get="inline" set="null" line="86" static="1"><x path="Int"/></ESCAPE>
		<SPACE public="1" get="inline" set="null" line="87" static="1"><x path="Int"/></SPACE>
		<PAGE_UP public="1" get="inline" set="null" line="88" static="1"><x path="Int"/></PAGE_UP>
		<PAGE_DOWN public="1" get="inline" set="null" line="89" static="1"><x path="Int"/></PAGE_DOWN>
		<END public="1" get="inline" set="null" line="90" static="1"><x path="Int"/></END>
		<HOME public="1" get="inline" set="null" line="91" static="1"><x path="Int"/></HOME>
		<LEFT public="1" get="inline" set="null" line="92" static="1"><x path="Int"/></LEFT>
		<RIGHT public="1" get="inline" set="null" line="93" static="1"><x path="Int"/></RIGHT>
		<UP public="1" get="inline" set="null" line="94" static="1"><x path="Int"/></UP>
		<DOWN public="1" get="inline" set="null" line="95" static="1"><x path="Int"/></DOWN>
		<INSERT public="1" get="inline" set="null" line="96" static="1"><x path="Int"/></INSERT>
		<DELETE public="1" get="inline" set="null" line="97" static="1"><x path="Int"/></DELETE>
		<NUMLOCK public="1" get="inline" set="null" line="98" static="1"><x path="Int"/></NUMLOCK>
		<BREAK public="1" get="inline" set="null" line="99" static="1"><x path="Int"/></BREAK>
		<SEMICOLON public="1" get="inline" set="null" line="101" static="1"><x path="Int"/></SEMICOLON>
		<EQUAL public="1" get="inline" set="null" line="102" static="1"><x path="Int"/></EQUAL>
		<COMMA public="1" get="inline" set="null" line="103" static="1"><x path="Int"/></COMMA>
		<MINUS public="1" get="inline" set="null" line="104" static="1"><x path="Int"/></MINUS>
		<PERIOD public="1" get="inline" set="null" line="105" static="1"><x path="Int"/></PERIOD>
		<SLASH public="1" get="inline" set="null" line="106" static="1"><x path="Int"/></SLASH>
		<BACKQUOTE public="1" get="inline" set="null" line="107" static="1"><x path="Int"/></BACKQUOTE>
		<LEFTBRACKET public="1" get="inline" set="null" line="108" static="1"><x path="Int"/></LEFTBRACKET>
		<BACKSLASH public="1" get="inline" set="null" line="109" static="1"><x path="Int"/></BACKSLASH>
		<RIGHTBRACKET public="1" get="inline" set="null" line="110" static="1"><x path="Int"/></RIGHTBRACKET>
		<QUOTE public="1" get="inline" set="null" line="111" static="1"><x path="Int"/></QUOTE>
		<DOM_VK_CANCEL get="inline" set="null" line="115" static="1"><x path="Int"/></DOM_VK_CANCEL>
		<DOM_VK_HELP get="inline" set="null" line="116" static="1"><x path="Int"/></DOM_VK_HELP>
		<DOM_VK_BACK_SPACE get="inline" set="null" line="117" static="1"><x path="Int"/></DOM_VK_BACK_SPACE>
		<DOM_VK_TAB get="inline" set="null" line="118" static="1"><x path="Int"/></DOM_VK_TAB>
		<DOM_VK_CLEAR get="inline" set="null" line="119" static="1"><x path="Int"/></DOM_VK_CLEAR>
		<DOM_VK_RETURN get="inline" set="null" line="120" static="1"><x path="Int"/></DOM_VK_RETURN>
		<DOM_VK_ENTER get="inline" set="null" line="121" static="1"><x path="Int"/></DOM_VK_ENTER>
		<DOM_VK_SHIFT get="inline" set="null" line="122" static="1"><x path="Int"/></DOM_VK_SHIFT>
		<DOM_VK_CONTROL get="inline" set="null" line="123" static="1"><x path="Int"/></DOM_VK_CONTROL>
		<DOM_VK_ALT get="inline" set="null" line="124" static="1"><x path="Int"/></DOM_VK_ALT>
		<DOM_VK_PAUSE get="inline" set="null" line="125" static="1"><x path="Int"/></DOM_VK_PAUSE>
		<DOM_VK_CAPS_LOCK get="inline" set="null" line="126" static="1"><x path="Int"/></DOM_VK_CAPS_LOCK>
		<DOM_VK_ESCAPE get="inline" set="null" line="127" static="1"><x path="Int"/></DOM_VK_ESCAPE>
		<DOM_VK_SPACE get="inline" set="null" line="128" static="1"><x path="Int"/></DOM_VK_SPACE>
		<DOM_VK_PAGE_UP get="inline" set="null" line="129" static="1"><x path="Int"/></DOM_VK_PAGE_UP>
		<DOM_VK_PAGE_DOWN get="inline" set="null" line="130" static="1"><x path="Int"/></DOM_VK_PAGE_DOWN>
		<DOM_VK_END get="inline" set="null" line="131" static="1"><x path="Int"/></DOM_VK_END>
		<DOM_VK_HOME get="inline" set="null" line="132" static="1"><x path="Int"/></DOM_VK_HOME>
		<DOM_VK_LEFT get="inline" set="null" line="133" static="1"><x path="Int"/></DOM_VK_LEFT>
		<DOM_VK_UP get="inline" set="null" line="134" static="1"><x path="Int"/></DOM_VK_UP>
		<DOM_VK_RIGHT get="inline" set="null" line="135" static="1"><x path="Int"/></DOM_VK_RIGHT>
		<DOM_VK_DOWN get="inline" set="null" line="136" static="1"><x path="Int"/></DOM_VK_DOWN>
		<DOM_VK_PRINTSCREEN get="inline" set="null" line="137" static="1"><x path="Int"/></DOM_VK_PRINTSCREEN>
		<DOM_VK_INSERT get="inline" set="null" line="138" static="1"><x path="Int"/></DOM_VK_INSERT>
		<DOM_VK_DELETE get="inline" set="null" line="139" static="1"><x path="Int"/></DOM_VK_DELETE>
		<DOM_VK_0 get="inline" set="null" line="140" static="1"><x path="Int"/></DOM_VK_0>
		<DOM_VK_1 get="inline" set="null" line="141" static="1"><x path="Int"/></DOM_VK_1>
		<DOM_VK_2 get="inline" set="null" line="142" static="1"><x path="Int"/></DOM_VK_2>
		<DOM_VK_3 get="inline" set="null" line="143" static="1"><x path="Int"/></DOM_VK_3>
		<DOM_VK_4 get="inline" set="null" line="144" static="1"><x path="Int"/></DOM_VK_4>
		<DOM_VK_5 get="inline" set="null" line="145" static="1"><x path="Int"/></DOM_VK_5>
		<DOM_VK_6 get="inline" set="null" line="146" static="1"><x path="Int"/></DOM_VK_6>
		<DOM_VK_7 get="inline" set="null" line="147" static="1"><x path="Int"/></DOM_VK_7>
		<DOM_VK_8 get="inline" set="null" line="148" static="1"><x path="Int"/></DOM_VK_8>
		<DOM_VK_9 get="inline" set="null" line="149" static="1"><x path="Int"/></DOM_VK_9>
		<DOM_VK_SEMICOLON get="inline" set="null" line="150" static="1"><x path="Int"/></DOM_VK_SEMICOLON>
		<DOM_VK_EQUALS get="inline" set="null" line="151" static="1"><x path="Int"/></DOM_VK_EQUALS>
		<DOM_VK_A get="inline" set="null" line="152" static="1"><x path="Int"/></DOM_VK_A>
		<DOM_VK_B get="inline" set="null" line="153" static="1"><x path="Int"/></DOM_VK_B>
		<DOM_VK_C get="inline" set="null" line="154" static="1"><x path="Int"/></DOM_VK_C>
		<DOM_VK_D get="inline" set="null" line="155" static="1"><x path="Int"/></DOM_VK_D>
		<DOM_VK_E get="inline" set="null" line="156" static="1"><x path="Int"/></DOM_VK_E>
		<DOM_VK_F get="inline" set="null" line="157" static="1"><x path="Int"/></DOM_VK_F>
		<DOM_VK_G get="inline" set="null" line="158" static="1"><x path="Int"/></DOM_VK_G>
		<DOM_VK_H get="inline" set="null" line="159" static="1"><x path="Int"/></DOM_VK_H>
		<DOM_VK_I get="inline" set="null" line="160" static="1"><x path="Int"/></DOM_VK_I>
		<DOM_VK_J get="inline" set="null" line="161" static="1"><x path="Int"/></DOM_VK_J>
		<DOM_VK_K get="inline" set="null" line="162" static="1"><x path="Int"/></DOM_VK_K>
		<DOM_VK_L get="inline" set="null" line="163" static="1"><x path="Int"/></DOM_VK_L>
		<DOM_VK_M get="inline" set="null" line="164" static="1"><x path="Int"/></DOM_VK_M>
		<DOM_VK_N get="inline" set="null" line="165" static="1"><x path="Int"/></DOM_VK_N>
		<DOM_VK_O get="inline" set="null" line="166" static="1"><x path="Int"/></DOM_VK_O>
		<DOM_VK_P get="inline" set="null" line="167" static="1"><x path="Int"/></DOM_VK_P>
		<DOM_VK_Q get="inline" set="null" line="168" static="1"><x path="Int"/></DOM_VK_Q>
		<DOM_VK_R get="inline" set="null" line="169" static="1"><x path="Int"/></DOM_VK_R>
		<DOM_VK_S get="inline" set="null" line="170" static="1"><x path="Int"/></DOM_VK_S>
		<DOM_VK_T get="inline" set="null" line="171" static="1"><x path="Int"/></DOM_VK_T>
		<DOM_VK_U get="inline" set="null" line="172" static="1"><x path="Int"/></DOM_VK_U>
		<DOM_VK_V get="inline" set="null" line="173" static="1"><x path="Int"/></DOM_VK_V>
		<DOM_VK_W get="inline" set="null" line="174" static="1"><x path="Int"/></DOM_VK_W>
		<DOM_VK_X get="inline" set="null" line="175" static="1"><x path="Int"/></DOM_VK_X>
		<DOM_VK_Y get="inline" set="null" line="176" static="1"><x path="Int"/></DOM_VK_Y>
		<DOM_VK_Z get="inline" set="null" line="177" static="1"><x path="Int"/></DOM_VK_Z>
		<DOM_VK_CONTEXT_MENU get="inline" set="null" line="178" static="1"><x path="Int"/></DOM_VK_CONTEXT_MENU>
		<DOM_VK_NUMPAD0 get="inline" set="null" line="179" static="1"><x path="Int"/></DOM_VK_NUMPAD0>
		<DOM_VK_NUMPAD1 get="inline" set="null" line="180" static="1"><x path="Int"/></DOM_VK_NUMPAD1>
		<DOM_VK_NUMPAD2 get="inline" set="null" line="181" static="1"><x path="Int"/></DOM_VK_NUMPAD2>
		<DOM_VK_NUMPAD3 get="inline" set="null" line="182" static="1"><x path="Int"/></DOM_VK_NUMPAD3>
		<DOM_VK_NUMPAD4 get="inline" set="null" line="183" static="1"><x path="Int"/></DOM_VK_NUMPAD4>
		<DOM_VK_NUMPAD5 get="inline" set="null" line="184" static="1"><x path="Int"/></DOM_VK_NUMPAD5>
		<DOM_VK_NUMPAD6 get="inline" set="null" line="185" static="1"><x path="Int"/></DOM_VK_NUMPAD6>
		<DOM_VK_NUMPAD7 get="inline" set="null" line="186" static="1"><x path="Int"/></DOM_VK_NUMPAD7>
		<DOM_VK_NUMPAD8 get="inline" set="null" line="187" static="1"><x path="Int"/></DOM_VK_NUMPAD8>
		<DOM_VK_NUMPAD9 get="inline" set="null" line="188" static="1"><x path="Int"/></DOM_VK_NUMPAD9>
		<DOM_VK_MULTIPLY get="inline" set="null" line="189" static="1"><x path="Int"/></DOM_VK_MULTIPLY>
		<DOM_VK_ADD get="inline" set="null" line="190" static="1"><x path="Int"/></DOM_VK_ADD>
		<DOM_VK_SEPARATOR get="inline" set="null" line="191" static="1"><x path="Int"/></DOM_VK_SEPARATOR>
		<DOM_VK_SUBTRACT get="inline" set="null" line="192" static="1"><x path="Int"/></DOM_VK_SUBTRACT>
		<DOM_VK_DECIMAL get="inline" set="null" line="193" static="1"><x path="Int"/></DOM_VK_DECIMAL>
		<DOM_VK_DIVIDE get="inline" set="null" line="194" static="1"><x path="Int"/></DOM_VK_DIVIDE>
		<DOM_VK_F1 get="inline" set="null" line="195" static="1"><x path="Int"/></DOM_VK_F1>
		<DOM_VK_F2 get="inline" set="null" line="196" static="1"><x path="Int"/></DOM_VK_F2>
		<DOM_VK_F3 get="inline" set="null" line="197" static="1"><x path="Int"/></DOM_VK_F3>
		<DOM_VK_F4 get="inline" set="null" line="198" static="1"><x path="Int"/></DOM_VK_F4>
		<DOM_VK_F5 get="inline" set="null" line="199" static="1"><x path="Int"/></DOM_VK_F5>
		<DOM_VK_F6 get="inline" set="null" line="200" static="1"><x path="Int"/></DOM_VK_F6>
		<DOM_VK_F7 get="inline" set="null" line="201" static="1"><x path="Int"/></DOM_VK_F7>
		<DOM_VK_F8 get="inline" set="null" line="202" static="1"><x path="Int"/></DOM_VK_F8>
		<DOM_VK_F9 get="inline" set="null" line="203" static="1"><x path="Int"/></DOM_VK_F9>
		<DOM_VK_F10 get="inline" set="null" line="204" static="1"><x path="Int"/></DOM_VK_F10>
		<DOM_VK_F11 get="inline" set="null" line="205" static="1"><x path="Int"/></DOM_VK_F11>
		<DOM_VK_F12 get="inline" set="null" line="206" static="1"><x path="Int"/></DOM_VK_F12>
		<DOM_VK_F13 get="inline" set="null" line="207" static="1"><x path="Int"/></DOM_VK_F13>
		<DOM_VK_F14 get="inline" set="null" line="208" static="1"><x path="Int"/></DOM_VK_F14>
		<DOM_VK_F15 get="inline" set="null" line="209" static="1"><x path="Int"/></DOM_VK_F15>
		<DOM_VK_F16 get="inline" set="null" line="210" static="1"><x path="Int"/></DOM_VK_F16>
		<DOM_VK_F17 get="inline" set="null" line="211" static="1"><x path="Int"/></DOM_VK_F17>
		<DOM_VK_F18 get="inline" set="null" line="212" static="1"><x path="Int"/></DOM_VK_F18>
		<DOM_VK_F19 get="inline" set="null" line="213" static="1"><x path="Int"/></DOM_VK_F19>
		<DOM_VK_F20 get="inline" set="null" line="214" static="1"><x path="Int"/></DOM_VK_F20>
		<DOM_VK_F21 get="inline" set="null" line="215" static="1"><x path="Int"/></DOM_VK_F21>
		<DOM_VK_F22 get="inline" set="null" line="216" static="1"><x path="Int"/></DOM_VK_F22>
		<DOM_VK_F23 get="inline" set="null" line="217" static="1"><x path="Int"/></DOM_VK_F23>
		<DOM_VK_F24 get="inline" set="null" line="218" static="1"><x path="Int"/></DOM_VK_F24>
		<DOM_VK_NUM_LOCK get="inline" set="null" line="219" static="1"><x path="Int"/></DOM_VK_NUM_LOCK>
		<DOM_VK_SCROLL_LOCK get="inline" set="null" line="220" static="1"><x path="Int"/></DOM_VK_SCROLL_LOCK>
		<DOM_VK_COMMA get="inline" set="null" line="221" static="1"><x path="Int"/></DOM_VK_COMMA>
		<DOM_VK_PERIOD get="inline" set="null" line="222" static="1"><x path="Int"/></DOM_VK_PERIOD>
		<DOM_VK_SLASH get="inline" set="null" line="223" static="1"><x path="Int"/></DOM_VK_SLASH>
		<DOM_VK_BACK_QUOTE get="inline" set="null" line="224" static="1"><x path="Int"/></DOM_VK_BACK_QUOTE>
		<DOM_VK_OPEN_BRACKET get="inline" set="null" line="225" static="1"><x path="Int"/></DOM_VK_OPEN_BRACKET>
		<DOM_VK_BACK_SLASH get="inline" set="null" line="226" static="1"><x path="Int"/></DOM_VK_BACK_SLASH>
		<DOM_VK_CLOSE_BRACKET get="inline" set="null" line="227" static="1"><x path="Int"/></DOM_VK_CLOSE_BRACKET>
		<DOM_VK_QUOTE get="inline" set="null" line="228" static="1"><x path="Int"/></DOM_VK_QUOTE>
		<DOM_VK_META get="inline" set="null" line="229" static="1"><x path="Int"/></DOM_VK_META>
		<DOM_VK_KANA get="inline" set="null" line="231" static="1"><x path="Int"/></DOM_VK_KANA>
		<DOM_VK_HANGUL get="inline" set="null" line="232" static="1"><x path="Int"/></DOM_VK_HANGUL>
		<DOM_VK_JUNJA get="inline" set="null" line="233" static="1"><x path="Int"/></DOM_VK_JUNJA>
		<DOM_VK_FINAL get="inline" set="null" line="234" static="1"><x path="Int"/></DOM_VK_FINAL>
		<DOM_VK_HANJA get="inline" set="null" line="235" static="1"><x path="Int"/></DOM_VK_HANJA>
		<DOM_VK_KANJI get="inline" set="null" line="236" static="1"><x path="Int"/></DOM_VK_KANJI>
		<DOM_VK_CONVERT get="inline" set="null" line="237" static="1"><x path="Int"/></DOM_VK_CONVERT>
		<DOM_VK_NONCONVERT get="inline" set="null" line="238" static="1"><x path="Int"/></DOM_VK_NONCONVERT>
		<DOM_VK_ACEPT get="inline" set="null" line="239" static="1"><x path="Int"/></DOM_VK_ACEPT>
		<DOM_VK_MODECHANGE get="inline" set="null" line="240" static="1"><x path="Int"/></DOM_VK_MODECHANGE>
		<DOM_VK_SELECT get="inline" set="null" line="241" static="1"><x path="Int"/></DOM_VK_SELECT>
		<DOM_VK_PRINT get="inline" set="null" line="242" static="1"><x path="Int"/></DOM_VK_PRINT>
		<DOM_VK_EXECUTE get="inline" set="null" line="243" static="1"><x path="Int"/></DOM_VK_EXECUTE>
		<DOM_VK_SLEEP get="inline" set="null" line="244" static="1"><x path="Int"/></DOM_VK_SLEEP>
		<capsLock public="1" set="null" static="1"><x path="Bool"/></capsLock>
		<numLock public="1" set="null" static="1"><x path="Bool"/></numLock>
		<isAccessible public="1" set="method" line="250" static="1"><f a=""><x path="Bool"/></f></isAccessible>
		<__convertMozillaCode public="1" set="method" line="258" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__convertMozillaCode>
		<__convertWebkitCode public="1" set="method" line="289" static="1">
			<f a="code">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__convertWebkitCode>
	</class>
	<class path="openfl.ui.Mouse" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/ui/Mouse.hx">
		<hide public="1" set="method" line="11" static="1"><f a=""><x path="Void"/></f></hide>
		<show public="1" set="method" line="18" static="1"><f a=""><x path="Void"/></f></show>
		<meta><m n=":access"><e>'???'</e></m></meta>
	</class>
	<class path="openfl.ui.Multitouch" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/ui/Multitouch.hx">
		<inputMode public="1" get="accessor" set="accessor" static="1"><e path="openfl.ui.MultitouchInputMode"/></inputMode>
		<maxTouchPoints public="1" set="null" static="1"><x path="Int"/></maxTouchPoints>
		<supportedGestures public="1" set="null" static="1"><c path="Array"><c path="String"/></c></supportedGestures>
		<supportsGestureEvents public="1" set="null" static="1"><x path="Bool"/></supportsGestureEvents>
		<supportsTouchEvents public="1" get="accessor" set="null" static="1"><x path="Bool"/></supportsTouchEvents>
		<get_inputMode set="method" line="38" static="1">
			<f a=""><e path="openfl.ui.MultitouchInputMode"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_inputMode>
		<set_inputMode set="method" line="45" static="1">
			<f a="inMode">
				<e path="openfl.ui.MultitouchInputMode"/>
				<e path="openfl.ui.MultitouchInputMode"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_inputMode>
		<get_supportsTouchEvents set="method" line="59" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_supportsTouchEvents>
	</class>
	<enum path="openfl.ui.MultitouchInputMode" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/ui/MultitouchInputMode.hx">
		<NONE/>
		<TOUCH_POINT/>
		<GESTURE/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="openfl.utils.ArrayBuffer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/ArrayBuffer.hx"><t path="lime.utils.ArrayBuffer"/></typedef>
	<typedef path="openfl.utils.ArrayBufferView" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/ArrayBufferView.hx"><c path="lime.utils.ArrayBufferView"/></typedef>
	<typedef path="openfl.utils.ByteArray" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/ByteArray.hx"><c path="lime.utils.ByteArray"/></typedef>
	<typedef path="openfl.utils.CompressionAlgorithm" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/CompressionAlgorithm.hx"><e path="lime.utils.CompressionAlgorithm"/></typedef>
	<class path="openfl.utils.Endian" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/Endian.hx">
		<BIG_ENDIAN public="1" get="inline" set="null" line="7" static="1"><c path="String"/></BIG_ENDIAN>
		<LITTLE_ENDIAN public="1" get="inline" set="null" line="8" static="1"><c path="String"/></LITTLE_ENDIAN>
	</class>
	<typedef path="openfl.utils.Float32Array" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/Float32Array.hx"><c path="lime.utils.Float32Array"/></typedef>
	<class path="openfl.utils.IDataInput" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/IDataInput.hx" interface="1">
		<bytesAvailable public="1" set="null"><x path="Int"/></bytesAvailable>
		<endian public="1"><c path="openfl.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="Int"/></objectEncoding>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<t path="openfl.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedShort>
	</class>
	<class path="openfl.utils.IDataOutput" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/IDataOutput.hx" interface="1">
		<endian public="1"><c path="openfl.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="Int"/></objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<t path="openfl.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
	</class>
	<typedef path="openfl.utils.Int16Array" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/Int16Array.hx"><c path="lime.utils.Int16Array"/></typedef>
	<typedef path="openfl.utils.Int32Array" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/Int32Array.hx"><c path="lime.utils.Int32Array"/></typedef>
	<class path="openfl.utils.Timer" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/Timer.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<currentCount public="1" set="null"><x path="Int"/></currentCount>
		<delay public="1" get="accessor" set="accessor"><x path="Float"/></delay>
		<repeatCount public="1" set="accessor"><x path="Int"/></repeatCount>
		<running public="1" set="null"><x path="Bool"/></running>
		<__delay>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__delay>
		<__timer>
			<t path="haxe._Timer.HaxeTimer"/>
			<meta><m n=":noCompletion"/></meta>
		</__timer>
		<__timerID>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__timerID>
		<reset public="1" set="method" line="46"><f a=""><x path="Void"/></f></reset>
		<start public="1" set="method" line="59"><f a=""><x path="Void"/></f></start>
		<stop public="1" set="method" line="77"><f a=""><x path="Void"/></f></stop>
		<get_delay set="method" line="107">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_delay>
		<set_delay set="method" line="114">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_delay>
		<set_repeatCount set="method" line="130">
			<f a="v">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_repeatCount>
		<timer_onTimer set="method" line="151">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</timer_onTimer>
		<new public="1" set="method" line="27"><f a="delay:?repeatCount" v=":0">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="openfl.utils.UInt8Array" params="" file="/usr/lib/haxe/lib/openfl/2,1,6/openfl/utils/UInt8Array.hx"><c path="lime.utils.UInt8Array"/></typedef>
	<class path="sys.net.Host" params="" file="/usr/lib/haxe/std/cpp/_std/sys/net/Host.hx">
		<host_resolve line="49" static="1"><f a="">
	<c path="String"/>
	<x path="Int"/>
</f></host_resolve>
		<host_to_string line="51" static="1"><f a="">
	<x path="Int"/>
	<c path="String"/>
</f></host_to_string>
		<ip public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The actual IP corresponding to the host.</haxe_doc>
		</ip>
		<toString public="1" set="method" line="33">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the IP representation of the host</haxe_doc>
		</toString>
		<new public="1" set="method" line="29">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Host : the name can be an IP in the form "127.0.0.1" or an host name such as "google.com", in which case
		the corresponding IP address is resolved using DNS. An exception occur if the host name could not be found.</haxe_doc>
		</new>
		<haxe_doc>A given IP host name.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.net._Socket.SocketInput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket">
		<extends path="haxe.io.Input"/>
		<socket_recv line="69" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></socket_recv>
		<socket_recv_char line="70" static="1"><f a="">
	<d/>
	<x path="Int"/>
</f></socket_recv_char>
		<socket_close line="71" static="1"><f a="">
	<d/>
	<unknown/>
</f></socket_close>
		<__s><d/></__s>
		<readByte public="1" set="method" line="34" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="47" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="64" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="30"><f a="s">
	<unknown/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="sys.net._Socket.SocketOutput" params="" file="/usr/lib/haxe/std/cpp/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket">
		<extends path="haxe.io.Output"/>
		<socket_close line="112" static="1"><f a="">
	<d/>
	<unknown/>
</f></socket_close>
		<socket_send_char line="113" static="1"><f a=":">
	<d/>
	<x path="Int"/>
	<unknown/>
</f></socket_send_char>
		<socket_send line="114" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></socket_send>
		<__s><d/></__s>
		<writeByte public="1" set="method" line="83" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="96" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="107" override="1"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="79"><f a="s">
	<unknown/>
	<x path="Void"/>
</f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="sys.net.Socket" params="" file="/usr/lib/haxe/std/cpp/_std/sys/net/Socket.hx">
		<select public="1" set="method" line="217" static="1">
			<f a="read:write:others:?timeout" v=":::null">
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<x path="Float"/>
				<a>
					<write><c path="Array"><c path="sys.net.Socket"/></c></write>
					<read><c path="Array"><c path="sys.net.Socket"/></c></read>
					<others><c path="Array"><c path="sys.net.Socket"/></c></others>
				</a>
			</f>
			<haxe_doc>Wait until one of the sockets groups is ready for the given operation :
		[read] contains sockets on which we want to wait for available data to be read,
		[write] contains sockets on which we want to wait until we are allowed to write some data to their output buffers,
		[others] contains sockets on which we want to wait for exceptional conditions.
		[select] will block until one of the condition is met, in which case it will return the sockets for which the condition was true.
		In case a [timeout] (in seconds) is specified, select might wait at worse until the timeout expires.</haxe_doc>
		</select>
		<socket_new line="228" static="1"><f a="">
	<x path="Bool"/>
	<unknown/>
</f></socket_new>
		<socket_close line="229" static="1"><f a="">
	<d/>
	<unknown/>
</f></socket_close>
		<socket_connect line="232" static="1"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<unknown/>
</f></socket_connect>
		<socket_select line="234" static="1"><f a=":::">
	<c path="Array"><c path="sys.net.Socket"/></c>
	<c path="Array"><c path="sys.net.Socket"/></c>
	<c path="Array"><c path="sys.net.Socket"/></c>
	<t path="Null"><x path="Float"/></t>
	<c path="Array"><c path="Array"><c path="sys.net.Socket"/></c></c>
</f></socket_select>
		<socket_set_blocking line="241" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></socket_set_blocking>
		<socket_set_fast_send line="242" static="1"><f a=":">
	<d/>
	<x path="Bool"/>
	<unknown/>
</f></socket_set_fast_send>
		<__s><d/></__s>
		<input public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>The stream on which you can read available data. By default the stream is blocking until the requested data is available,
		use [setBlocking(false)] or [setTimeout] to prevent infinite waiting.</haxe_doc>
		</input>
		<output public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use [setBlocking(false)] or [setTimeout] to prevent that.</haxe_doc>
		</output>
		<close public="1" set="method" line="133">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.</haxe_doc>
		</close>
		<connect public="1" set="method" line="155">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Connect to the given server host/port. Throw an exception in case we couldn't sucessfully connect.</haxe_doc>
		</connect>
		<setBlocking public="1" set="method" line="209">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediatly by throwing a haxe.io.Error.Blocking value.</haxe_doc>
		</setBlocking>
		<setFastSend public="1" set="method" line="213">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows the socket to immediatly send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.</haxe_doc>
		</setFastSend>
		<new public="1" set="method" line="127">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new unconnected socket.</haxe_doc>
		</new>
		<haxe_doc>A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
</haxe>